00001    ; minimal monitor for EhBASIC 2.22 running under the 2m5.de 6502 emulator
00002    ; 25-mar-2014 - save/load to match V0.83 or higher DMA register
00003    
00004    ; some minor modifications are in the basic program itself
00005    
00006    ; RAM scan has been removed.
00007    ; maximum RAM must be defined here, you can still configure less RAM during at coldstart
00008    
00009    ; 32k RAM mirrored = 12k EhBASIC code at top + 20k work space at bottom
00010    
00011      0300             Ram_base		= $0300	; start of user RAM (set as needed, should be page aligned)
00012      5000             Ram_top		= $5000	; end of user RAM+1 (set as needed, should be page aligned)
00013    
00014    ; This start can be changed to suit your system
00015    
00016    D000               	*=	$D000
00017    
00018    D000  4C 00 FE     	JMP	RES_vec	;startup soft reset
00019    
00020    	.INCLUDE "basic.asm"
00021    
00022    ; Enhanced BASIC to assemble under 6502 simulator, $ver 2.22
00023    
00024    ; modified for use with the 2m5.de 6502 emulator 04-mar-2013
00025    ; removed RAM scan - has to be configured, period.
00026    ; altered interrupt related statements to make propper use of CLI/SEI
00027    
00028    ; $E7E1 $E7CF $E7C6 $E7D3 $E7D1 $E7D5 $E7CF $E81E $E825
00029    
00030    ; 2.00	new revision numbers start here
00031    ; 2.01	fixed LCASE$() and UCASE$()
00032    ; 2.02	new get value routine done
00033    ; 2.03	changed RND() to galoise method
00034    ; 2.04	fixed SPC()
00035    ; 2.05	new get value routine fixed
00036    ; 2.06	changed USR() code
00037    ; 2.07	fixed STR$()
00038    ; 2.08	changed INPUT and READ to remove need for $00 start to input buffer
00039    ; 2.09	fixed RND()
00040    ; 2.10	integrated missed changes from an earlier version
00041    ; 2.20	added ELSE to IF .. THEN and fixed IF .. GOTO <statement> to cause error
00042    ; 2.21	fixed IF .. THEN RETURN to not cause error
00043    ; 2.22	fixed RND() breaking the get byte routine
00044    
00045    ; zero page use ..
00046    
00047      0000             LAB_WARM 		= $00		; BASIC warm start entry point
00048      0001             Wrmjpl 		= LAB_WARM+1; BASIC warm start vector jump low byte
00049      0002             Wrmjph 		= LAB_WARM+2; BASIC warm start vector jump high byte
00050    
00051      000A             Usrjmp		= $0A		; USR function JMP address
00052      000B             Usrjpl		= Usrjmp+1	; USR function JMP vector low byte
00053      000C             Usrjph		= Usrjmp+2	; USR function JMP vector high byte
00054      000D             Nullct		= $0D		; nulls output after each line
00055      000E             TPos			= $0E		; BASIC terminal position byte
00056      000F             TWidth		= $0F		; BASIC terminal width byte
00057      0010             Iclim			= $10		; input column limit
00058      0011             Itempl		= $11		; temporary integer low byte
00059      0012             Itemph		= Itempl+1	; temporary integer high byte
00060    
00061      0011             nums_1		= Itempl	; number to bin/hex string convert MSB
00062      0012             nums_2		= nums_1+1	; number to bin/hex string convert
00063      0013             nums_3		= nums_1+2	; number to bin/hex string convert LSB
00064    
00065      005B             Srchc			= $5B		; search character
00066      005B             Temp3			= Srchc	; temp byte used in number routines
00067      005C             Scnquo		= $5C		; scan-between-quotes flag
00068      005C             Asrch			= Scnquo	; alt search character
00069    
00070      005B             XOAw_l		= Srchc	; eXclusive OR, OR and AND word low byte
00071      005C             XOAw_h		= Scnquo	; eXclusive OR, OR and AND word high byte
00072    
00073      005D             Ibptr			= $5D		; input buffer pointer
00074      005D             Dimcnt		= Ibptr	; # of dimensions
00075      005D             Tindx			= Ibptr	; token index
00076    
00077      005E             Defdim		= $5E		; default DIM flag
00078      005F             Dtypef		= $5F		; data type flag, $FF=string, $00=numeric
00079      0060             Oquote		= $60		; open quote flag (b7) (Flag: DATA scan; LIST quote; memory)
00080      0060             Gclctd		= $60		; garbage collected flag
00081      0061             Sufnxf		= $61		; subscript/FNX flag, 1xxx xxx = FN(0xxx xxx)
00082      0062             Imode			= $62		; input mode flag, $00=INPUT, $80=READ
00083    
00084      0063             Cflag			= $63		; comparison evaluation flag
00085    
00086      0064             TabSiz		= $64		; TAB step size (was input flag)
00087    
00088      0065             next_s		= $65		; next descriptor stack address
00089    
00090    					; these two bytes form a word pointer to the item
00091    					; currently on top of the descriptor stack
00092      0066             last_sl		= $66		; last descriptor stack address low byte
00093      0067             last_sh		= $67		; last descriptor stack address high byte (always $00)
00094    
00095      0068             des_sk		= $68		; descriptor stack start address (temp strings)
00096    
00097    ;			= $70		; End of descriptor stack
00098    
00099      0071             ut1_pl		= $71		; utility pointer 1 low byte
00100      0072             ut1_ph		= ut1_pl+1	; utility pointer 1 high byte
00101      0073             ut2_pl		= $73		; utility pointer 2 low byte
00102      0074             ut2_ph		= ut2_pl+1	; utility pointer 2 high byte
00103    
00104      0071             Temp_2		= ut1_pl	; temp byte for block move	
00105    
00106      0075             FACt_1		= $75		; FAC temp mantissa1
00107      0076             FACt_2		= FACt_1+1	; FAC temp mantissa2
00108      0077             FACt_3		= FACt_2+1	; FAC temp mantissa3
00109    
00110      0076             dims_l		= FACt_2	; array dimension size low byte
00111      0077             dims_h		= FACt_3	; array dimension size high byte
00112    
00113      0078             TempB			= $78		; temp page 0 byte
00114    
00115      0079             Smeml			= $79		; start of mem low byte		(Start-of-Basic)
00116      007A             Smemh			= Smeml+1	; start of mem high byte	(Start-of-Basic)
00117      007B             Svarl			= $7B		; start of vars low byte	(Start-of-Variables)
00118      007C             Svarh			= Svarl+1	; start of vars high byte	(Start-of-Variables)
00119      007D             Sarryl		= $7D		; var mem end low byte		(Start-of-Arrays)
00120      007E             Sarryh		= Sarryl+1	; var mem end high byte		(Start-of-Arrays)
00121      007F             Earryl		= $7F		; array mem end low byte	(End-of-Arrays)
00122      0080             Earryh		= Earryl+1	; array mem end high byte	(End-of-Arrays)
00123      0081             Sstorl		= $81		; string storage low byte	(String storage (moving down))
00124      0082             Sstorh		= Sstorl+1	; string storage high byte	(String storage (moving down))
00125      0083             Sutill		= $83		; string utility ptr low byte
00126      0084             Sutilh		= Sutill+1	; string utility ptr high byte
00127      0085             Ememl			= $85		; end of mem low byte		(Limit-of-memory)
00128      0086             Ememh			= Ememl+1	; end of mem high byte		(Limit-of-memory)
00129      0087             Clinel		= $87		; current line low byte		(Basic line number)
00130      0088             Clineh		= Clinel+1	; current line high byte	(Basic line number)
00131      0089             Blinel		= $89		; break line low byte		(Previous Basic line number)
00132      008A             Blineh		= Blinel+1	; break line high byte		(Previous Basic line number)
00133    
00134      008B             Cpntrl		= $8B		; continue pointer low byte
00135      008C             Cpntrh		= Cpntrl+1	; continue pointer high byte
00136    
00137      008D             Dlinel		= $8D		; current DATA line low byte
00138      008E             Dlineh		= Dlinel+1	; current DATA line high byte
00139    
00140      008F             Dptrl			= $8F		; DATA pointer low byte
00141      0090             Dptrh			= Dptrl+1	; DATA pointer high byte
00142    
00143      0091             Rdptrl		= $91		; read pointer low byte
00144      0092             Rdptrh		= Rdptrl+1	; read pointer high byte
00145    
00146      0093             Varnm1		= $93		; current var name 1st byte
00147      0094             Varnm2		= Varnm1+1	; current var name 2nd byte
00148    
00149      0095             Cvaral		= $95		; current var address low byte
00150      0096             Cvarah		= Cvaral+1	; current var address high byte
00151    
00152      0097             Frnxtl		= $97		; var pointer for FOR/NEXT low byte
00153      0098             Frnxth		= Frnxtl+1	; var pointer for FOR/NEXT high byte
00154    
00155      0097             Tidx1			= Frnxtl	; temp line index
00156    
00157      0097             Lvarpl		= Frnxtl	; let var pointer low byte
00158      0098             Lvarph		= Frnxth	; let var pointer high byte
00159    
00160      0099             prstk			= $99		; precedence stacked flag
00161    
00162      009B             comp_f		= $9B		; compare function flag, bits 0,1 and 2 used
00163    					; bit 2 set if >
00164    					; bit 1 set if =
00165    					; bit 0 set if <
00166    
00167      009C             func_l		= $9C		; function pointer low byte
00168      009D             func_h		= func_l+1	; function pointer high byte
00169    
00170      009C             garb_l		= func_l	; garbage collection working pointer low byte
00171      009D             garb_h		= func_h	; garbage collection working pointer high byte
00172    
00173      009E             des_2l		= $9E		; string descriptor_2 pointer low byte
00174      009F             des_2h		= des_2l+1	; string descriptor_2 pointer high byte
00175    
00176      00A0             g_step		= $A0		; garbage collect step size
00177    
00178      00A1             Fnxjmp		= $A1		; jump vector for functions
00179      00A2             Fnxjpl		= Fnxjmp+1	; functions jump vector low byte
00180      00A3             Fnxjph		= Fnxjmp+2	; functions jump vector high byte
00181    
00182      00A2             g_indx		= Fnxjpl	; garbage collect temp index
00183    
00184      00A3             FAC2_r		= $A3		; FAC2 rounding byte
00185    
00186      00A4             Adatal		= $A4		; array data pointer low byte
00187      00A5             Adatah		= Adatal+1	; array data pointer high  byte
00188    
00189      00A4             Nbendl		= Adatal	; new block end pointer low byte
00190      00A5             Nbendh		= Adatah	; new block end pointer high  byte
00191    
00192      00A6             Obendl		= $A6		; old block end pointer low byte
00193      00A7             Obendh		= Obendl+1	; old block end pointer high  byte
00194    
00195      00A8             numexp		= $A8		; string to float number exponent count
00196      00A9             expcnt		= $A9		; string to float exponent count
00197    
00198      00A8             numbit		= numexp	; bit count for array element calculations
00199    
00200      00AA             numdpf		= $AA		; string to float decimal point flag
00201      00AB             expneg		= $AB		; string to float eval exponent -ve flag
00202    
00203      00AA             Astrtl		= numdpf	; array start pointer low byte
00204      00AB             Astrth		= expneg	; array start pointer high  byte
00205    
00206      00AA             Histrl		= numdpf	; highest string low byte
00207      00AB             Histrh		= expneg	; highest string high  byte
00208    
00209      00AA             Baslnl		= numdpf	; BASIC search line pointer low byte
00210      00AB             Baslnh		= expneg	; BASIC search line pointer high  byte
00211    
00212      00AA             Fvar_l		= numdpf	; find/found variable pointer low byte
00213      00AB             Fvar_h		= expneg	; find/found variable pointer high  byte
00214    
00215      00AA             Ostrtl		= numdpf	; old block start pointer low byte
00216      00AB             Ostrth		= expneg	; old block start pointer high  byte
00217    
00218      00AA             Vrschl		= numdpf	; variable search pointer low byte
00219      00AB             Vrschh		= expneg	; variable search pointer high  byte
00220    
00221      00AC             FAC1_e		= $AC		; FAC1 exponent
00222      00AD             FAC1_1		= FAC1_e+1	; FAC1 mantissa1
00223      00AE             FAC1_2		= FAC1_e+2	; FAC1 mantissa2
00224      00AF             FAC1_3		= FAC1_e+3	; FAC1 mantissa3
00225      00B0             FAC1_s		= FAC1_e+4	; FAC1 sign (b7)
00226    
00227      00AC             str_ln		= FAC1_e	; string length
00228      00AD             str_pl		= FAC1_1	; string pointer low byte
00229      00AE             str_ph		= FAC1_2	; string pointer high byte
00230    
00231      00AE             des_pl		= FAC1_2	; string descriptor pointer low byte
00232      00AF             des_ph		= FAC1_3	; string descriptor pointer high byte
00233    
00234      00AF             mids_l		= FAC1_3	; MID$ string temp length byte
00235    
00236      00B1             negnum		= $B1		; string to float eval -ve flag
00237      00B1             numcon		= $B1		; series evaluation constant count
00238    
00239      00B2             FAC1_o		= $B2		; FAC1 overflow byte
00240    
00241      00B3             FAC2_e		= $B3		; FAC2 exponent
00242      00B4             FAC2_1		= FAC2_e+1	; FAC2 mantissa1
00243      00B5             FAC2_2		= FAC2_e+2	; FAC2 mantissa2
00244      00B6             FAC2_3		= FAC2_e+3	; FAC2 mantissa3
00245      00B7             FAC2_s		= FAC2_e+4	; FAC2 sign (b7)
00246    
00247      00B8             FAC_sc		= $B8		; FAC sign comparison, Acc#1 vs #2
00248      00B9             FAC1_r		= $B9		; FAC1 rounding byte
00249    
00250      00B8             ssptr_l		= FAC_sc	; string start pointer low byte
00251      00B9             ssptr_h		= FAC1_r	; string start pointer high byte
00252    
00253      00B8             sdescr		= FAC_sc	; string descriptor pointer
00254    
00255      00BA             csidx			= $BA		; line crunch save index
00256      00BA             Asptl			= csidx	; array size/pointer low byte
00257      00BB             Aspth			= $BB		; array size/pointer high byte
00258    
00259      00BA             Btmpl			= Asptl	; BASIC pointer temp low byte
00260      00BB             Btmph			= Aspth	; BASIC pointer temp low byte
00261    
00262      00BA             Cptrl			= Asptl	; BASIC pointer temp low byte
00263      00BB             Cptrh			= Aspth	; BASIC pointer temp low byte
00264    
00265      00BA             Sendl			= Asptl	; BASIC pointer temp low byte
00266      00BB             Sendh			= Aspth	; BASIC pointer temp low byte
00267    
00268      00BC             LAB_IGBY		= $BC		; get next BASIC byte subroutine
00269    
00270      00C2             LAB_GBYT		= $C2		; get current BASIC byte subroutine
00271      00C3             Bpntrl		= $C3		; BASIC execute (get byte) pointer low byte
00272      00C4             Bpntrh		= Bpntrl+1	; BASIC execute (get byte) pointer high byte
00273    
00274    ;			= $D7		; end of get BASIC char subroutine
00275    
00276      00D8             Rbyte4		= $D8		; extra PRNG byte
00277      00D9             Rbyte1		= Rbyte4+1	; most significant PRNG byte
00278      00DA             Rbyte2		= Rbyte4+2	; middle PRNG byte
00279      00DB             Rbyte3		= Rbyte4+3	; least significant PRNG byte
00280    
00281      00DC             NmiBase		= $DC		; NMI handler enabled/setup/triggered flags
00282    					; bit	function
00283    					; ===	========
00284    					; 7	interrupt setup
00285    					; 6	interrupt enabled
00286    					; 5	interrupt happened
00287    ;			= $DD		; NMI handler addr low byte
00288    ;			= $DE		; NMI handler addr high byte
00289      00DF             IrqBase		= $DF		; IRQ handler enabled/setup/triggered flags
00290    ;			= $E0		; IRQ handler addr low byte
00291    ;			= $E1		; IRQ handler addr high byte
00292    
00293      00E2             irq_a_reg		= $E2		; save A during IRQ
00294    ;			= $E3		; unused
00295    ;			= $E4		; unused
00296    ;			= $E5		; unused
00297    ;			= $E6		; unused
00298    ;			= $E7		; unused
00299    ;			= $E8		; unused
00300    ;			= $E9		; unused
00301    ;			= $EA		; unused
00302    ;			= $EB		; unused
00303    ;			= $EC		; unused
00304    ;			= $ED		; unused
00305    ;			= $EE		; unused
00306    
00307      00EF             Decss			= $EF		; number to decimal string start
00308      00F0             Decssp1		= Decss+1	; number to decimal string start
00309    
00310    ;			= $FF		; decimal string end
00311    
00312    ; token values needed for BASIC
00313    
00314    ; primary command tokens (can start a statement)
00315    
00316      0080             TK_END		= $80			; END token
00317      0081             TK_FOR		= TK_END+1		; FOR token
00318      0082             TK_NEXT		= TK_FOR+1		; NEXT token
00319      0083             TK_DATA		= TK_NEXT+1		; DATA token
00320      0084             TK_INPUT		= TK_DATA+1		; INPUT token
00321      0085             TK_DIM		= TK_INPUT+1	; DIM token
00322      0086             TK_READ		= TK_DIM+1		; READ token
00323      0087             TK_LET		= TK_READ+1		; LET token
00324      0088             TK_DEC		= TK_LET+1		; DEC token
00325      0089             TK_GOTO		= TK_DEC+1		; GOTO token
00326      008A             TK_RUN		= TK_GOTO+1		; RUN token
00327      008B             TK_IF			= TK_RUN+1		; IF token
00328      008C             TK_RESTORE		= TK_IF+1		; RESTORE token
00329      008D             TK_GOSUB		= TK_RESTORE+1	; GOSUB token
00330      008E             TK_RETIRQ		= TK_GOSUB+1	; RETIRQ token
00331      008F             TK_RETNMI		= TK_RETIRQ+1	; RETNMI token
00332      0090             TK_RETURN		= TK_RETNMI+1	; RETURN token
00333      0091             TK_REM		= TK_RETURN+1	; REM token
00334      0092             TK_STOP		= TK_REM+1		; STOP token
00335      0093             TK_ON			= TK_STOP+1		; ON token
00336      0094             TK_NULL		= TK_ON+1		; NULL token
00337      0095             TK_INC		= TK_NULL+1		; INC token
00338      0096             TK_WAIT		= TK_INC+1		; WAIT token
00339      0097             TK_LOAD		= TK_WAIT+1		; LOAD token
00340      0098             TK_SAVE		= TK_LOAD+1		; SAVE token
00341      0099             TK_DEF		= TK_SAVE+1		; DEF token
00342      009A             TK_POKE		= TK_DEF+1		; POKE token
00343      009B             TK_DOKE		= TK_POKE+1		; DOKE token
00344      009C             TK_CALL		= TK_DOKE+1		; CALL token
00345      009D             TK_DO			= TK_CALL+1		; DO token
00346      009E             TK_LOOP		= TK_DO+1		; LOOP token
00347      009F             TK_PRINT		= TK_LOOP+1		; PRINT token
00348      00A0             TK_CONT		= TK_PRINT+1	; CONT token
00349      00A1             TK_LIST		= TK_CONT+1		; LIST token
00350      00A2             TK_CLEAR		= TK_LIST+1		; CLEAR token
00351      00A3             TK_NEW		= TK_CLEAR+1	; NEW token
00352      00A4             TK_WIDTH		= TK_NEW+1		; WIDTH token
00353      00A5             TK_GET		= TK_WIDTH+1	; GET token
00354      00A6             TK_SWAP		= TK_GET+1		; SWAP token
00355      00A7             TK_BITSET		= TK_SWAP+1		; BITSET token
00356      00A8             TK_BITCLR		= TK_BITSET+1	; BITCLR token
00357      00A9             TK_IRQ		= TK_BITCLR+1	; IRQ token
00358      00AA             TK_NMI		= TK_IRQ+1		; NMI token
00359    
00360    ; secondary command tokens, can't start a statement
00361    
00362      00AB             TK_TAB		= TK_NMI+1		; TAB token
00363      00AC             TK_ELSE		= TK_TAB+1		; ELSE token
00364      00AD             TK_TO			= TK_ELSE+1		; TO token
00365      00AE             TK_FN			= TK_TO+1		; FN token
00366      00AF             TK_SPC		= TK_FN+1		; SPC token
00367      00B0             TK_THEN		= TK_SPC+1		; THEN token
00368      00B1             TK_NOT		= TK_THEN+1		; NOT token
00369      00B2             TK_STEP		= TK_NOT+1		; STEP token
00370      00B3             TK_UNTIL		= TK_STEP+1		; UNTIL token
00371      00B4             TK_WHILE		= TK_UNTIL+1	; WHILE token
00372      00B5             TK_OFF		= TK_WHILE+1	; OFF token
00373    
00374    ; opperator tokens
00375    
00376      00B6             TK_PLUS		= TK_OFF+1		; + token
00377      00B7             TK_MINUS		= TK_PLUS+1		; - token
00378      00B8             TK_MUL		= TK_MINUS+1	; * token
00379      00B9             TK_DIV		= TK_MUL+1		; / token
00380      00BA             TK_POWER		= TK_DIV+1		; ^ token
00381      00BB             TK_AND		= TK_POWER+1	; AND token
00382      00BC             TK_EOR		= TK_AND+1		; EOR token
00383      00BD             TK_OR			= TK_EOR+1		; OR token
00384      00BE             TK_RSHIFT		= TK_OR+1		; RSHIFT token
00385      00BF             TK_LSHIFT		= TK_RSHIFT+1	; LSHIFT token
00386      00C0             TK_GT			= TK_LSHIFT+1	; > token
00387      00C1             TK_EQUAL		= TK_GT+1		; = token
00388      00C2             TK_LT			= TK_EQUAL+1	; < token
00389    
00390    ; functions tokens
00391    
00392      00C3             TK_SGN		= TK_LT+1		; SGN token
00393      00C4             TK_INT		= TK_SGN+1		; INT token
00394      00C5             TK_ABS		= TK_INT+1		; ABS token
00395      00C6             TK_USR		= TK_ABS+1		; USR token
00396      00C7             TK_FRE		= TK_USR+1		; FRE token
00397      00C8             TK_POS		= TK_FRE+1		; POS token
00398      00C9             TK_SQR		= TK_POS+1		; SQR token
00399      00CA             TK_RND		= TK_SQR+1		; RND token
00400      00CB             TK_LOG		= TK_RND+1		; LOG token
00401      00CC             TK_EXP		= TK_LOG+1		; EXP token
00402      00CD             TK_COS		= TK_EXP+1		; COS token
00403      00CE             TK_SIN		= TK_COS+1		; SIN token
00404      00CF             TK_TAN		= TK_SIN+1		; TAN token
00405      00D0             TK_ATN		= TK_TAN+1		; ATN token
00406      00D1             TK_PEEK		= TK_ATN+1		; PEEK token
00407      00D2             TK_DEEK		= TK_PEEK+1		; DEEK token
00408      00D3             TK_SADD		= TK_DEEK+1		; SADD token
00409      00D4             TK_LEN		= TK_SADD+1		; LEN token
00410      00D5             TK_STRS		= TK_LEN+1		; STR$ token
00411      00D6             TK_VAL		= TK_STRS+1		; VAL token
00412      00D7             TK_ASC		= TK_VAL+1		; ASC token
00413      00D8             TK_UCASES		= TK_ASC+1		; UCASE$ token
00414      00D9             TK_LCASES		= TK_UCASES+1	; LCASE$ token
00415      00DA             TK_CHRS		= TK_LCASES+1	; CHR$ token
00416      00DB             TK_HEXS		= TK_CHRS+1		; HEX$ token
00417      00DC             TK_BINS		= TK_HEXS+1		; BIN$ token
00418      00DD             TK_BITTST		= TK_BINS+1		; BITTST token
00419      00DE             TK_MAX		= TK_BITTST+1	; MAX token
00420      00DF             TK_MIN		= TK_MAX+1		; MIN token
00421      00E0             TK_PI			= TK_MIN+1		; PI token
00422      00E1             TK_TWOPI		= TK_PI+1		; TWOPI token
00423      00E2             TK_VPTR		= TK_TWOPI+1	; VARPTR token
00424      00E3             TK_LEFTS		= TK_VPTR+1		; LEFT$ token
00425      00E4             TK_RIGHTS		= TK_LEFTS+1	; RIGHT$ token
00426      00E5             TK_MIDS		= TK_RIGHTS+1	; MID$ token
00427    
00428    ; offsets from a base of X or Y
00429    
00430      0000             PLUS_0		= $00		; X or Y plus 0
00431      0001             PLUS_1		= $01		; X or Y plus 1
00432      0002             PLUS_2		= $02		; X or Y plus 2
00433      0003             PLUS_3		= $03		; X or Y plus 3
00434    
00435      0100             LAB_STAK		= $0100	; stack bottom, no offset
00436    
00437      01FE             LAB_SKFE		= LAB_STAK+$FE
00438    					; flushed stack address
00439      01FF             LAB_SKFF		= LAB_STAK+$FF
00440    					; flushed stack address
00441    
00442      0200             ccflag		= $0200	; BASIC CTRL-C flag, 00 = enabled, 01 = dis
00443      0201             ccbyte		= ccflag+1	; BASIC CTRL-C byte
00444      0202             ccnull		= ccbyte+1	; BASIC CTRL-C byte timeout
00445    
00446      0203             VEC_CC		= ccnull+1	; ctrl c check vector
00447    
00448      0205             VEC_IN		= VEC_CC+2	; input vector
00449      0207             VEC_OUT		= VEC_IN+2	; output vector
00450      0209             VEC_LD		= VEC_OUT+2	; load vector
00451      020B             VEC_SV		= VEC_LD+2	; save vector
00452      020D             IRQ_indirect	= VEC_SV+2		; IRQ code vector
00453      020F             NMI_indirect	= IRQ_indirect+2	; NMI code vector
00454    
00455    ; Ibuffs can now be anywhere in RAM, ensure that the max length is < $80
00456    
00457      0211             Ibuffs		= NMI_indirect+2
00458    					; start of input buffer after IRQ/NMI code
00459      0290             Ibuffe		= Ibuffs+$7f; end of input buffer
00460    
00461    ; BASIC cold start entry point
00462    
00463    ; new page 2 initialisation, copy block to ccflag on
00464    
00465    LAB_COLD
00466    D003  A0 04        	LDY	#PG2_TABE-PG2_TABS-1
00467    					; byte count-1
00468    LAB_2D13
00469    D005  B9 03 F1     	LDA	PG2_TABS,Y		; get byte
00470    D008  99 00 02     	STA	ccflag,Y		; store in page 2
00471    D00B  88           	DEY				; decrement count
00472    D00C  10 F7        	BPL	LAB_2D13		; loop if not done
00473    
00474    D00E  A2 FF        	LDX	#$FF			; set byte
00475    D010  86 88        	STX	Clineh		; set current line high byte (set immediate mode)
00476    D012  9A           	TXS				; reset stack pointer
00477    
00478    D013  A9 4C        	LDA	#$4C			; code for JMP
00479    D015  85 A1        	STA	Fnxjmp		; save for jump vector for functions
00480    
00481    ; copy block from LAB_2CEE to $00BC - $00D3
00482    
00483    D017  A2 1C        	LDX	#StrTab-LAB_2CEE	; set byte count
00484    LAB_2D4E
00485    D019  BD 07 F1     	LDA	LAB_2CEE-1,X	; get byte from table
00486    D01C  95 BB        	STA	LAB_IGBY-1,X	; save byte in page zero
00487    D01E  CA           	DEX				; decrement count
00488    D01F  D0 F8        	BNE	LAB_2D4E		; loop if not all done
00489    
00490    ; copy block from StrTab to $0000 - $0012
00491    
00492    LAB_GMEM
00493    D021  A2 12        	LDX	#EndTab-StrTab-1	; set byte count-1
00494    TabLoop
00495    D023  BD 24 F1     	LDA	StrTab,X		; get byte from table
00496    D026  95 00        	STA	PLUS_0,X		; save byte in page zero
00497    D028  CA           	DEX				; decrement count
00498    D029  10 F8        	BPL	TabLoop		; loop if not all done
00499    
00500    ; set-up start values
00501    
00502    D02B  A9 00        	LDA	#$00			; clear A
00503    D02D  85 DC        	STA	NmiBase		; clear NMI handler enabled flag
00504    D02F  85 DF        	STA	IrqBase		; clear IRQ handler enabled flag
00505    D031  85 B2        	STA	FAC1_o		; clear FAC1 overflow byte
00506    D033  85 67        	STA	last_sh		; clear descriptor stack top item pointer high byte
00507    
00508    D035  A9 0E        	LDA	#$0E			; set default tab size
00509    D037  85 64        	STA	TabSiz		; save it
00510    D039  A9 03        	LDA	#$03			; set garbage collect step size for descriptor stack
00511    D03B  85 A0        	STA	g_step		; save it
00512    D03D  A2 68        	LDX	#des_sk		; descriptor stack start
00513    D03F  86 65        	STX	next_s		; set descriptor stack pointer
00514    D041  20 86 D8     	JSR	LAB_CRLF		; print CR/LF
00515    D044  A9 37        	LDA	#<LAB_MSZM		; point to memory size message (low addr)
00516    D046  A0 F1        	LDY	#>LAB_MSZM		; point to memory size message (high addr)
00517    D048  20 C7 D8     	JSR	LAB_18C3		; print null terminated string from memory
00518    D04B  20 33 D2     	JSR	LAB_INLN		; print "? " and get BASIC input
00519    D04E  86 C3        	STX	Bpntrl		; set BASIC execute pointer low byte
00520    D050  84 C4        	STY	Bpntrh		; set BASIC execute pointer high byte
00521    D052  20 C2 00     	JSR	LAB_GBYT		; get last byte back
00522    D055  F0 1E        	BEQ	set_RAM_max		; RAM not specified, set maximum
00523    
00524    D057  20 9A E9     	JSR	LAB_2887		; get FAC1 from string
00525    D05A  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
00526    D05C  C9 98        	CMP	#$98			; compare with exponent = 2^24
00527    D05E  B0 C1        	BCS	LAB_GMEM		; if too large go try again
00528    
00529    D060  20 EB E4     	JSR	LAB_F2FU		; save integer part of FAC1 in temporary integer
00530    					; (no range check)
00531    D063  A5 11        	LDA	Itempl		; get temporary integer low byte
00532    D065  A4 12        	LDY	Itemph		; get temporary integer high byte
00533    D067  C0 04        	CPY	#>Ram_base+1	; compare with start of RAM+$100 high byte
00534    D069  90 B6        	BCC	LAB_GMEM		; if too small go try again
00535    
00536    D06B  C0 50        	CPY	#>Ram_top		; compare with top of RAM high byte
00537    D06D  90 0A        	BCC	MEM_OK		; < RAM top = valid
00538    D06F  D0 04        	BNE	set_RAM_max		; if too large set maximum
00539    					; else was = so compare low bytes
00540    D071  C9 00        	CMP	#<Ram_top		; compare with top of RAM low byte
00541    D073  90 04        	BCC	MEM_OK		; < RAM_top = valid
00542    set_RAM_max
00543    D075  A0 50        	LDY	#>Ram_top		; set maximum RAM as configured
00544    D077  A9 00        	LDA	#<Ram_top
00545    MEM_OK
00546    D079  85 85        	STA	Ememl			; set end of mem low byte
00547    D07B  84 86        	STY	Ememh			; set end of mem high byte
00548    D07D  85 81        	STA	Sstorl		; set bottom of string space low byte
00549    D07F  84 82        	STY	Sstorh		; set bottom of string space high byte
00550    
00551    D081  A0 00        	LDY	#<Ram_base		; set start addr low byte
00552    D083  A2 03        	LDX	#>Ram_base		; set start addr high byte
00553    D085  84 79        	STY	Smeml			; save start of mem low byte
00554    D087  86 7A        	STX	Smemh			; save start of mem high byte
00555    
00556    ; this line is only needed if Ram_base is not $xx00
00557    
00558    ;	LDY	#$00			; clear Y
00559    D089  98           	TYA				; clear A
00560    D08A  91 79        	STA	(Smeml),Y		; clear first byte
00561    D08C  E6 79        	INC	Smeml			; increment start of mem low byte
00562    
00563    ; these two lines are only needed if Ram_base is $xxFF
00564    
00565    ;	BNE	LAB_2E05		; branch if no rollover
00566    
00567    ;	INC	Smemh			; increment start of mem high byte
00568    LAB_2E05
00569    D08E  20 86 D8     	JSR	LAB_CRLF		; print CR/LF
00570    D091  20 44 D3     	JSR	LAB_1463		; do "NEW" and "CLEAR"
00571    D094  A5 85        	LDA	Ememl			; get end of mem low byte
00572    D096  38           	SEC				; set carry for subtract
00573    D097  E5 79        	SBC	Smeml			; subtract start of mem low byte
00574    D099  AA           	TAX				; copy to X
00575    D09A  A5 86        	LDA	Ememh			; get end of mem high byte
00576    D09C  E5 7A        	SBC	Smemh			; subtract start of mem high byte
00577    D09E  20 76 EA     	JSR	LAB_295E		; print XA as unsigned integer (bytes free)
00578    D0A1  A9 46        	LDA	#<LAB_SMSG		; point to sign-on message (low addr)
00579    D0A3  A0 F1        	LDY	#>LAB_SMSG		; point to sign-on message (high addr)
00580    D0A5  20 C7 D8     	JSR	LAB_18C3		; print null terminated string from memory
00581    D0A8  A9 4C        	LDA	#<LAB_1274		; warm start vector low byte
00582    D0AA  A0 D1        	LDY	#>LAB_1274		; warm start vector high byte
00583    D0AC  85 01        	STA	Wrmjpl		; save warm start vector low byte
00584    D0AE  84 02        	STY	Wrmjph		; save warm start vector high byte
00585    D0B0  6C 01 00     	JMP	(Wrmjpl)		; go do warm start
00586    
00587    ; open up space in memory
00588    ; move (Ostrtl)-(Obendl) to new block ending at (Nbendl)
00589    
00590    ; Nbendl,Nbendh - new block end address (A/Y)
00591    ; Obendl,Obendh - old block end address
00592    ; Ostrtl,Ostrth - old block start address
00593    
00594    ; returns with ..
00595    
00596    ; Nbendl,Nbendh - new block start address (high byte - $100)
00597    ; Obendl,Obendh - old block start address (high byte - $100)
00598    ; Ostrtl,Ostrth - old block start address (unchanged)
00599    
00600    LAB_11CF
00601    D0B3  20 FD D0     	JSR	LAB_121F		; check available memory, "Out of memory" error if no room
00602    					; addr to check is in AY (low/high)
00603    D0B6  85 7F        	STA	Earryl		; save new array mem end low byte
00604    D0B8  84 80        	STY	Earryh		; save new array mem end high byte
00605    
00606    ; open up space in memory
00607    ; move (Ostrtl)-(Obendl) to new block ending at (Nbendl)
00608    ; don't set array end
00609    
00610    LAB_11D6
00611    D0BA  38           	SEC				; set carry for subtract
00612    D0BB  A5 A6        	LDA	Obendl		; get block end low byte
00613    D0BD  E5 AA        	SBC	Ostrtl		; subtract block start low byte
00614    D0BF  A8           	TAY				; copy MOD(block length/$100) byte to Y
00615    D0C0  A5 A7        	LDA	Obendh		; get block end high byte
00616    D0C2  E5 AB        	SBC	Ostrth		; subtract block start high byte
00617    D0C4  AA           	TAX				; copy block length high byte to X
00618    D0C5  E8           	INX				; +1 to allow for count=0 exit
00619    D0C6  98           	TYA				; copy block length low byte to A
00620    D0C7  F0 24        	BEQ	LAB_120A		; branch if length low byte=0
00621    
00622    					; block is (X-1)*256+Y bytes, do the Y bytes first
00623    
00624    D0C9  38           	SEC				; set carry for add + 1, two's complement
00625    D0CA  49 FF        	EOR	#$FF			; invert low byte for subtract
00626    D0CC  65 A6        	ADC	Obendl		; add block end low byte
00627    
00628    D0CE  85 A6        	STA	Obendl		; save corrected old block end low byte
00629    D0D0  B0 03        	BCS	LAB_11F3		; branch if no underflow
00630    
00631    D0D2  C6 A7        	DEC	Obendh		; else decrement block end high byte
00632    D0D4  38           	SEC				; set carry for add + 1, two's complement
00633    LAB_11F3
00634    D0D5  98           	TYA				; get MOD(block length/$100) byte
00635    D0D6  49 FF        	EOR	#$FF			; invert low byte for subtract
00636    D0D8  65 A4        	ADC	Nbendl		; add destination end low byte
00637    D0DA  85 A4        	STA	Nbendl		; save modified new block end low byte
00638    D0DC  B0 08        	BCS	LAB_1203		; branch if no underflow
00639    
00640    D0DE  C6 A5        	DEC	Nbendh		; else decrement block end high byte
00641    D0E0  90 04        	BCC	LAB_1203		; branch always
00642    
00643    LAB_11FF
00644    D0E2  B1 A6        	LDA	(Obendl),Y		; get byte from source
00645    D0E4  91 A4        	STA	(Nbendl),Y		; copy byte to destination
00646    LAB_1203
00647    D0E6  88           	DEY				; decrement index
00648    D0E7  D0 F9        	BNE	LAB_11FF		; loop until Y=0
00649    
00650    					; now do Y=0 indexed byte
00651    D0E9  B1 A6        	LDA	(Obendl),Y		; get byte from source
00652    D0EB  91 A4        	STA	(Nbendl),Y		; save byte to destination
00653    LAB_120A
00654    D0ED  C6 A7        	DEC	Obendh		; decrement source pointer high byte
00655    D0EF  C6 A5        	DEC	Nbendh		; decrement destination pointer high byte
00656    D0F1  CA           	DEX				; decrement block count
00657    D0F2  D0 F2        	BNE	LAB_1203		; loop until count = $0
00658    
00659    D0F4  60           	RTS
00660    
00661    ; check room on stack for A bytes
00662    ; stack too deep? do OM error
00663    
00664    LAB_1212
00665    D0F5  85 78        	STA	TempB			; save result in temp byte
00666    D0F7  BA           	TSX				; copy stack
00667    D0F8  E4 78        	CPX	TempB			; compare new "limit" with stack
00668    D0FA  90 30        	BCC	LAB_OMER		; if stack < limit do "Out of memory" error then warm start
00669    
00670    D0FC  60           	RTS
00671    
00672    ; check available memory, "Out of memory" error if no room
00673    ; addr to check is in AY (low/high)
00674    
00675    LAB_121F
00676    D0FD  C4 82        	CPY	Sstorh		; compare bottom of string mem high byte
00677    D0FF  90 2A        	BCC	LAB_124B		; if less then exit (is ok)
00678    
00679    D101  D0 04        	BNE	LAB_1229		; skip next test if greater (tested <)
00680    
00681    					; high byte was =, now do low byte
00682    D103  C5 81        	CMP	Sstorl		; compare with bottom of string mem low byte
00683    D105  90 24        	BCC	LAB_124B		; if less then exit (is ok)
00684    
00685    					; addr is > string storage ptr (oops!)
00686    LAB_1229
00687    D107  48           	PHA				; push addr low byte
00688    D108  A2 08        	LDX	#$08			; set index to save Adatal to expneg inclusive
00689    D10A  98           	TYA				; copy addr high byte (to push on stack)
00690    
00691    					; save misc numeric work area
00692    LAB_122D
00693    D10B  48           	PHA				; push byte
00694    D10C  B5 A3        	LDA	Adatal-1,X		; get byte from Adatal to expneg ( ,$00 not pushed)
00695    D10E  CA           	DEX				; decrement index
00696    D10F  10 FA        	BPL	LAB_122D		; loop until all done
00697    
00698    D111  20 D3 E1     	JSR	LAB_GARB		; garbage collection routine
00699    
00700    					; restore misc numeric work area
00701    D114  A2 00        	LDX	#$00			; clear the index to restore bytes
00702    LAB_1238
00703    D116  68           	PLA				; pop byte
00704    D117  95 A4        	STA	Adatal,X		; save byte to Adatal to expneg
00705    D119  E8           	INX				; increment index
00706    D11A  E0 08        	CPX	#$08			; compare with end + 1
00707    D11C  30 F8        	BMI	LAB_1238		; loop if more to do
00708    
00709    D11E  68           	PLA				; pop addr high byte
00710    D11F  A8           	TAY				; copy back to Y
00711    D120  68           	PLA				; pop addr low byte
00712    D121  C4 82        	CPY	Sstorh		; compare bottom of string mem high byte
00713    D123  90 06        	BCC	LAB_124B		; if less then exit (is ok)
00714    
00715    D125  D0 05        	BNE	LAB_OMER		; if greater do "Out of memory" error then warm start
00716    
00717    					; high byte was =, now do low byte
00718    D127  C5 81        	CMP	Sstorl		; compare with bottom of string mem low byte
00719    D129  B0 01        	BCS	LAB_OMER		; if >= do "Out of memory" error then warm start
00720    
00721    					; ok exit, carry clear
00722    LAB_124B
00723    D12B  60           	RTS
00724    
00725    ; do "Out of memory" error then warm start
00726    
00727    LAB_OMER
00728    D12C  A2 0C        	LDX	#$0C			; error code $0C ("Out of memory" error)
00729    
00730    ; do error #X, then warm start
00731    
00732    LAB_XERR
00733    D12E  20 86 D8     	JSR	LAB_CRLF		; print CR/LF
00734    
00735    D131  BD B6 F6     	LDA	LAB_BAER,X		; get error message pointer low byte
00736    D134  BC B7 F6     	LDY	LAB_BAER+1,X	; get error message pointer high byte
00737    D137  20 C7 D8     	JSR	LAB_18C3		; print null terminated string from memory
00738    
00739    D13A  20 7D D3     	JSR	LAB_1491		; flush stack and clear continue flag
00740    D13D  A9 F3        	LDA	#<LAB_EMSG		; point to " Error" low addr
00741    D13F  A0 F7        	LDY	#>LAB_EMSG		; point to " Error" high addr
00742    LAB_1269
00743    D141  20 C7 D8     	JSR	LAB_18C3		; print null terminated string from memory
00744    D144  A4 88        	LDY	Clineh		; get current line high byte
00745    D146  C8           	INY				; increment it
00746    D147  F0 03        	BEQ	LAB_1274		; go do warm start (was immediate mode)
00747    
00748    					; else print line number
00749    D149  20 6B EA     	JSR	LAB_2953		; print " in line [LINE #]"
00750    
00751    ; BASIC warm start entry point
00752    ; wait for Basic command
00753    
00754    LAB_1274
00755    					; clear ON IRQ/NMI bytes
00756    D14C  A9 00        	LDA	#$00			; clear A
00757    D14E  85 DF        	STA	IrqBase		; clear enabled byte
00758    D150  85 DC        	STA	NmiBase		; clear enabled byte
00759    D152  58           	CLI				; allow interrupts
00760    D153  A9 04        	LDA	#<LAB_RMSG		; point to "Ready" message low byte
00761    D155  A0 F8        	LDY	#>LAB_RMSG		; point to "Ready" message high byte
00762    
00763    D157  20 C7 D8     	JSR	LAB_18C3		; go do print string
00764    
00765    ; wait for Basic command (no "Ready")
00766    
00767    LAB_127D
00768    D15A  20 40 D2     	JSR	LAB_1357		; call for BASIC input
00769    LAB_1280
00770    D15D  86 C3        	STX	Bpntrl		; set BASIC execute pointer low byte
00771    D15F  84 C4        	STY	Bpntrh		; set BASIC execute pointer high byte
00772    D161  20 C2 00     	JSR	LAB_GBYT		; scan memory
00773    D164  F0 F4        	BEQ	LAB_127D		; loop while null
00774    
00775    ; got to interpret input line now ..
00776    
00777    D166  A2 FF        	LDX	#$FF			; current line to null value
00778    D168  86 88        	STX	Clineh		; set current line high byte
00779    D16A  90 06        	BCC	LAB_1295		; branch if numeric character (handle new BASIC line)
00780    
00781    					; no line number .. immediate mode
00782    D16C  20 72 D2     	JSR	LAB_13A6		; crunch keywords into Basic tokens
00783    D16F  4C E7 D4     	JMP	LAB_15F6		; go scan and interpret code
00784    
00785    ; handle new BASIC line
00786    
00787    LAB_1295
00788    D172  20 49 D7     	JSR	LAB_GFPN		; get fixed-point number into temp integer
00789    D175  20 72 D2     	JSR	LAB_13A6		; crunch keywords into Basic tokens
00790    D178  84 5D        	STY	Ibptr			; save index pointer to end of crunched line
00791    D17A  20 18 D3     	JSR	LAB_SSLN		; search BASIC for temp integer line number
00792    D17D  90 44        	BCC	LAB_12E6		; branch if not found
00793    
00794    					; aroooogah! line # already exists! delete it
00795    D17F  A0 01        	LDY	#$01			; set index to next line pointer high byte
00796    D181  B1 AA        	LDA	(Baslnl),Y		; get next line pointer high byte
00797    D183  85 72        	STA	ut1_ph		; save it
00798    D185  A5 7B        	LDA	Svarl			; get start of vars low byte
00799    D187  85 71        	STA	ut1_pl		; save it
00800    D189  A5 AB        	LDA	Baslnh		; get found line pointer high byte
00801    D18B  85 74        	STA	ut2_ph		; save it
00802    D18D  A5 AA        	LDA	Baslnl		; get found line pointer low byte
00803    D18F  88           	DEY				; decrement index
00804    D190  F1 AA        	SBC	(Baslnl),Y		; subtract next line pointer low byte
00805    D192  18           	CLC				; clear carry for add
00806    D193  65 7B        	ADC	Svarl			; add start of vars low byte
00807    D195  85 7B        	STA	Svarl			; save new start of vars low byte
00808    D197  85 73        	STA	ut2_pl		; save destination pointer low byte
00809    D199  A5 7C        	LDA	Svarh			; get start of vars high byte
00810    D19B  69 FF        	ADC	#$FF			; -1 + carry
00811    D19D  85 7C        	STA	Svarh			; save start of vars high byte
00812    D19F  E5 AB        	SBC	Baslnh		; subtract found line pointer high byte
00813    D1A1  AA           	TAX				; copy to block count
00814    D1A2  38           	SEC				; set carry for subtract
00815    D1A3  A5 AA        	LDA	Baslnl		; get found line pointer low byte
00816    D1A5  E5 7B        	SBC	Svarl			; subtract start of vars low byte
00817    D1A7  A8           	TAY				; copy to bytes in first block count
00818    D1A8  B0 03        	BCS	LAB_12D0		; branch if overflow
00819    
00820    D1AA  E8           	INX				; increment block count (correct for =0 loop exit)
00821    D1AB  C6 74        	DEC	ut2_ph		; decrement destination high byte
00822    LAB_12D0
00823    D1AD  18           	CLC				; clear carry for add
00824    D1AE  65 71        	ADC	ut1_pl		; add source pointer low byte
00825    D1B0  90 03        	BCC	LAB_12D8		; branch if no overflow
00826    
00827    D1B2  C6 72        	DEC	ut1_ph		; else decrement source pointer high byte
00828    D1B4  18           	CLC				; clear carry
00829    
00830    					; close up memory to delete old line
00831    LAB_12D8
00832    D1B5  B1 71        	LDA	(ut1_pl),Y		; get byte from source
00833    D1B7  91 73        	STA	(ut2_pl),Y		; copy to destination
00834    D1B9  C8           	INY				; increment index
00835    D1BA  D0 F9        	BNE	LAB_12D8		; while <> 0 do this block
00836    
00837    D1BC  E6 72        	INC	ut1_ph		; increment source pointer high byte
00838    D1BE  E6 74        	INC	ut2_ph		; increment destination pointer high byte
00839    D1C0  CA           	DEX				; decrement block count
00840    D1C1  D0 F2        	BNE	LAB_12D8		; loop until all done
00841    
00842    					; got new line in buffer and no existing same #
00843    LAB_12E6
00844    D1C3  AD 11 02     	LDA	Ibuffs		; get byte from start of input buffer
00845    D1C6  F0 3F        	BEQ	LAB_1319		; if null line just go flush stack/vars and exit
00846    
00847    					; got new line and it isn't empty line
00848    D1C8  A5 85        	LDA	Ememl			; get end of mem low byte
00849    D1CA  A4 86        	LDY	Ememh			; get end of mem high byte
00850    D1CC  85 81        	STA	Sstorl		; set bottom of string space low byte
00851    D1CE  84 82        	STY	Sstorh		; set bottom of string space high byte
00852    D1D0  A5 7B        	LDA	Svarl			; get start of vars low byte	(end of BASIC)
00853    D1D2  85 A6        	STA	Obendl		; save old block end low byte
00854    D1D4  A4 7C        	LDY	Svarh			; get start of vars high byte	(end of BASIC)
00855    D1D6  84 A7        	STY	Obendh		; save old block end high byte
00856    D1D8  65 5D        	ADC	Ibptr			; add input buffer pointer	(also buffer length)
00857    D1DA  90 01        	BCC	LAB_1301		; branch if no overflow from add
00858    
00859    D1DC  C8           	INY				; else increment high byte
00860    LAB_1301
00861    D1DD  85 A4        	STA	Nbendl		; save new block end low byte	(move to, low byte)
00862    D1DF  84 A5        	STY	Nbendh		; save new block end high byte
00863    D1E1  20 B3 D0     	JSR	LAB_11CF		; open up space in memory
00864    					; old start pointer Ostrtl,Ostrth set by the find line call
00865    D1E4  A5 7F        	LDA	Earryl		; get array mem end low byte
00866    D1E6  A4 80        	LDY	Earryh		; get array mem end high byte
00867    D1E8  85 7B        	STA	Svarl			; save start of vars low byte
00868    D1EA  84 7C        	STY	Svarh			; save start of vars high byte
00869    D1EC  A4 5D        	LDY	Ibptr			; get input buffer pointer	(also buffer length)
00870    D1EE  88           	DEY				; adjust for loop type
00871    LAB_1311
00872    D1EF  B9 0D 02     	LDA	Ibuffs-4,Y		; get byte from crunched line
00873    D1F2  91 AA        	STA	(Baslnl),Y		; save it to program memory
00874    D1F4  88           	DEY				; decrement count
00875    D1F5  C0 03        	CPY	#$03			; compare with first byte-1
00876    D1F7  D0 F6        	BNE	LAB_1311		; continue while count <> 3
00877    
00878    D1F9  A5 12        	LDA	Itemph		; get line # high byte
00879    D1FB  91 AA        	STA	(Baslnl),Y		; save it to program memory
00880    D1FD  88           	DEY				; decrement count
00881    D1FE  A5 11        	LDA	Itempl		; get line # low byte
00882    D200  91 AA        	STA	(Baslnl),Y		; save it to program memory
00883    D202  88           	DEY				; decrement count
00884    D203  A9 FF        	LDA	#$FF			; set byte to allow chain rebuild. if you didn't set this
00885    					; byte then a zero already here would stop the chain rebuild
00886    					; as it would think it was the [EOT] marker.
00887    D205  91 AA        	STA	(Baslnl),Y		; save it to program memory
00888    
00889    LAB_1319
00890    D207  20 59 D3     	JSR	LAB_1477		; reset execution to start, clear vars and flush stack
00891    D20A  A6 79        	LDX	Smeml			; get start of mem low byte
00892    D20C  A5 7A        	LDA	Smemh			; get start of mem high byte
00893    D20E  A0 01        	LDY	#$01			; index to high byte of next line pointer
00894    LAB_1325
00895    D210  86 71        	STX	ut1_pl		; set line start pointer low byte
00896    D212  85 72        	STA	ut1_ph		; set line start pointer high byte
00897    D214  B1 71        	LDA	(ut1_pl),Y		; get it
00898    D216  F0 18        	BEQ	LAB_133E		; exit if end of program
00899    
00900    ; rebuild chaining of Basic lines
00901    
00902    D218  A0 04        	LDY	#$04			; point to first code byte of line
00903    					; there is always 1 byte + [EOL] as null entries are deleted
00904    LAB_1330
00905    D21A  C8           	INY				; next code byte
00906    D21B  B1 71        	LDA	(ut1_pl),Y		; get byte
00907    D21D  D0 FB        	BNE	LAB_1330		; loop if not [EOL]
00908    
00909    D21F  38           	SEC				; set carry for add + 1
00910    D220  98           	TYA				; copy end index
00911    D221  65 71        	ADC	ut1_pl		; add to line start pointer low byte
00912    D223  AA           	TAX				; copy to X
00913    D224  A0 00        	LDY	#$00			; clear index, point to this line's next line pointer
00914    D226  91 71        	STA	(ut1_pl),Y		; set next line pointer low byte
00915    D228  98           	TYA				; clear A
00916    D229  65 72        	ADC	ut1_ph		; add line start pointer high byte + carry
00917    D22B  C8           	INY				; increment index to high byte
00918    D22C  91 71        	STA	(ut1_pl),Y		; save next line pointer low byte
00919    D22E  90 E0        	BCC	LAB_1325		; go do next line, branch always, carry clear
00920    
00921    
00922    LAB_133E
00923    D230  4C 5A D1     	JMP	LAB_127D		; else we just wait for Basic command, no "Ready"
00924    
00925    ; print "? " and get BASIC input
00926    
00927    LAB_INLN
00928    D233  20 DF D8     	JSR	LAB_18E3		; print "?" character
00929    D236  20 DC D8     	JSR	LAB_18E0		; print " "
00930    D239  D0 05        	BNE	LAB_1357		; call for BASIC input and return
00931    
00932    ; receive line from keyboard
00933    
00934    					; $08 as delete key (BACKSPACE on standard keyboard)
00935    LAB_134B
00936    D23B  20 E1 D8     	JSR	LAB_PRNA		; go print the character
00937    D23E  CA           	DEX				; decrement the buffer counter (delete)
00938    	.byte	$2C			; make LDX into BIT abs
00939    
00940    ; call for BASIC input (main entry point)
00941    
00942    LAB_1357
00943    D240  A2 00        	LDX	#$00			; clear BASIC line buffer pointer
00944    LAB_1359
00945    D242  58           	CLI				; force allow interrupts while waiting
00946    D243  20 F7 F0     	JSR	V_INPT		; call scan input device
00947    D246  90 FA        	BCC	LAB_1359		; loop if no byte
00948    
00949    D248  F0 F8        	BEQ	LAB_1359		; loop until valid input (ignore NULLs)
00950    
00951    D24A  C9 07        	CMP	#$07			; compare with [BELL]
00952    D24C  F0 10        	BEQ	LAB_1378		; branch if [BELL]
00953    
00954    D24E  C9 0D        	CMP	#$0D			; compare with [CR]
00955    D250  F0 19        	BEQ	LAB_1384		; do CR/LF exit if [CR]
00956    
00957    D252  E0 00        	CPX	#$00			; compare pointer with $00
00958    D254  D0 04        	BNE	LAB_1374		; branch if not empty
00959    
00960    ; next two lines ignore any non print character and [SPACE] if input buffer empty
00961    
00962    D256  C9 21        	CMP	#$21			; compare with [SP]+1
00963    D258  90 E8        	BCC	LAB_1359		; if < ignore character
00964    
00965    LAB_1374
00966    D25A  C9 08        	CMP	#$08			; compare with [BACKSPACE] (delete last character)
00967    D25C  F0 DD        	BEQ	LAB_134B		; go delete last character
00968    
00969    LAB_1378
00970    D25E  E0 7F        	CPX	#Ibuffe-Ibuffs	; compare character count with max
00971    D260  B0 0C        	BCS	LAB_138E		; skip store and do [BELL] if buffer full
00972    
00973    D262  9D 11 02     	STA	Ibuffs,X		; else store in buffer
00974    D265  E8           	INX				; increment pointer
00975    LAB_137F
00976    D266  20 E1 D8     	JSR	LAB_PRNA		; go print the character
00977    D269  D0 D7        	BNE	LAB_1359		; always loop for next character
00978    
00979    LAB_1384
00980    D26B  4C 7D D8     	JMP	LAB_1866		; do CR/LF exit to BASIC
00981    
00982    ; announce buffer full
00983    
00984    LAB_138E
00985    D26E  A9 07        	LDA	#$07			; [BELL] character into A
00986    D270  D0 F4        	BNE	LAB_137F		; go print the [BELL] but ignore input character
00987    					; branch always
00988    
00989    ; crunch keywords into Basic tokens
00990    ; position independent buffer version ..
00991    ; faster, dictionary search version ....
00992    
00993    LAB_13A6
00994    D272  A0 FF        	LDY	#$FF			; set save index (makes for easy math later)
00995    
00996    D274  38           	SEC				; set carry for subtract
00997    D275  A5 C3        	LDA	Bpntrl		; get basic execute pointer low byte
00998    D277  E9 11        	SBC	#<Ibuffs		; subtract input buffer start pointer
00999    D279  AA           	TAX				; copy result to X (index past line # if any)
01000    
01001    D27A  86 60        	STX	Oquote		; clear open quote/DATA flag
01002    LAB_13AC
01003    D27C  BD 11 02     	LDA	Ibuffs,X		; get byte from input buffer
01004    D27F  F0 51        	BEQ	LAB_13EC		; if null save byte then exit
01005    
01006    D281  C9 5F        	CMP	#'_'			; compare with "_"
01007    D283  B0 4D        	BCS	LAB_13EC		; if >= go save byte then continue crunching
01008    
01009    D285  C9 3C        	CMP	#'<'			; compare with "<"
01010    D287  B0 0E        	BCS	LAB_13CC		; if >= go crunch now
01011    
01012    D289  C9 30        	CMP	#'0'			; compare with "0"
01013    D28B  B0 45        	BCS	LAB_13EC		; if >= go save byte then continue crunching
01014    
01015    D28D  85 5C        	STA	Scnquo		; save buffer byte as search character
01016    D28F  C9 22        	CMP	#$22			; is it quote character?
01017    D291  F0 61        	BEQ	LAB_1410		; branch if so (copy quoted string)
01018    
01019    D293  C9 2A        	CMP	#'*'			; compare with "*"
01020    D295  90 3B        	BCC	LAB_13EC		; if < go save byte then continue crunching
01021    
01022    					; else crunch now
01023    LAB_13CC
01024    D297  24 60        	BIT	Oquote		; get open quote/DATA token flag
01025    D299  70 37        	BVS	LAB_13EC		; branch if b6 of Oquote set (was DATA)
01026    					; go save byte then continue crunching
01027    
01028    D29B  86 78        	STX	TempB			; save buffer read index
01029    D29D  84 BA        	STY	csidx			; copy buffer save index
01030    D29F  A0 1D        	LDY	#<TAB_1STC		; get keyword first character table low address
01031    D2A1  84 73        	STY	ut2_pl		; save pointer low byte
01032    D2A3  A0 F3        	LDY	#>TAB_1STC		; get keyword first character table high address
01033    D2A5  84 74        	STY	ut2_ph		; save pointer high byte
01034    D2A7  A0 00        	LDY	#$00			; clear table pointer
01035    
01036    LAB_13D0
01037    D2A9  D1 73        	CMP	(ut2_pl),Y		; compare with keyword first character table byte
01038    D2AB  F0 05        	BEQ	LAB_13D1		; go do word_table_chr if match
01039    
01040    D2AD  90 21        	BCC	LAB_13EA		; if < keyword first character table byte go restore
01041    					; Y and save to crunched
01042    
01043    D2AF  C8           	INY				; else increment pointer
01044    D2B0  D0 F7        	BNE	LAB_13D0		; and loop (branch always)
01045    
01046    ; have matched first character of some keyword
01047    
01048    LAB_13D1
01049    D2B2  98           	TYA				; copy matching index
01050    D2B3  0A           	ASL				; *2 (bytes per pointer)
01051    D2B4  AA           	TAX				; copy to new index
01052    D2B5  BD 3B F3     	LDA	TAB_CHRT,X		; get keyword table pointer low byte
01053    D2B8  85 73        	STA	ut2_pl		; save pointer low byte
01054    D2BA  BD 3C F3     	LDA	TAB_CHRT+1,X	; get keyword table pointer high byte
01055    D2BD  85 74        	STA	ut2_ph		; save pointer high byte
01056    
01057    D2BF  A0 FF        	LDY	#$FF			; clear table pointer (make -1 for start)
01058    
01059    D2C1  A6 78        	LDX	TempB			; restore buffer read index
01060    
01061    LAB_13D6
01062    D2C3  C8           	INY				; next table byte
01063    D2C4  B1 73        	LDA	(ut2_pl),Y		; get byte from table
01064    LAB_13D8
01065    D2C6  30 08        	BMI	LAB_13EA		; all bytes matched so go save token
01066    
01067    D2C8  E8           	INX				; next buffer byte
01068    D2C9  DD 11 02     	CMP	Ibuffs,X		; compare with byte from input buffer
01069    D2CC  F0 F5        	BEQ	LAB_13D6		; go compare next if match
01070    
01071    D2CE  D0 2B        	BNE	LAB_1417		; branch if >< (not found keyword)
01072    
01073    LAB_13EA
01074    D2D0  A4 BA        	LDY	csidx			; restore save index
01075    
01076    					; save crunched to output
01077    LAB_13EC
01078    D2D2  E8           	INX				; increment buffer index (to next input byte)
01079    D2D3  C8           	INY				; increment save index (to next output byte)
01080    D2D4  99 11 02     	STA	Ibuffs,Y		; save byte to output
01081    D2D7  C9 00        	CMP	#$00			; set the flags, set carry
01082    D2D9  F0 32        	BEQ	LAB_142A		; do exit if was null [EOL]
01083    
01084    					; A holds token or byte here
01085    D2DB  E9 3A        	SBC	#':'			; subtract ":" (carry set by CMP #00)
01086    D2DD  F0 04        	BEQ	LAB_13FF		; branch if it was ":" (is now $00)
01087    
01088    					; A now holds token-$3A
01089    D2DF  C9 49        	CMP	#TK_DATA-$3A	; compare with DATA token - $3A
01090    D2E1  D0 02        	BNE	LAB_1401		; branch if not DATA
01091    
01092    					; token was : or DATA
01093    LAB_13FF
01094    D2E3  85 60        	STA	Oquote		; save token-$3A (clear for ":", TK_DATA-$3A for DATA)
01095    LAB_1401
01096    D2E5  49 57        	EOR	#TK_REM-$3A		; effectively subtract REM token offset
01097    D2E7  D0 93        	BNE	LAB_13AC		; If wasn't REM then go crunch rest of line
01098    
01099    D2E9  85 5C        	STA	Asrch			; else was REM so set search for [EOL]
01100    
01101    					; loop for REM, "..." etc.
01102    LAB_1408
01103    D2EB  BD 11 02     	LDA	Ibuffs,X		; get byte from input buffer
01104    D2EE  F0 E2        	BEQ	LAB_13EC		; branch if null [EOL]
01105    
01106    D2F0  C5 5C        	CMP	Asrch			; compare with stored character
01107    D2F2  F0 DE        	BEQ	LAB_13EC		; branch if match (end quote)
01108    
01109    					; entry for copy string in quotes, don't crunch
01110    LAB_1410
01111    D2F4  C8           	INY				; increment buffer save index
01112    D2F5  99 11 02     	STA	Ibuffs,Y		; save byte to output
01113    D2F8  E8           	INX				; increment buffer read index
01114    D2F9  D0 F0        	BNE	LAB_1408		; loop while <> 0 (should never be 0!)
01115    
01116    					; not found keyword this go
01117    LAB_1417
01118    D2FB  A6 78        	LDX	TempB			; compare has failed, restore buffer index (start byte!)
01119    
01120    					; now find the end of this word in the table
01121    LAB_141B
01122    D2FD  B1 73        	LDA	(ut2_pl),Y		; get table byte
01123    D2FF  08           	PHP				; save status
01124    D300  C8           	INY				; increment table index
01125    D301  28           	PLP				; restore byte status
01126    D302  10 F9        	BPL	LAB_141B		; if not end of keyword go do next
01127    
01128    D304  B1 73        	LDA	(ut2_pl),Y		; get byte from keyword table
01129    D306  D0 BE        	BNE	LAB_13D8		; go test next word if not zero byte (end of table)
01130    
01131    					; reached end of table with no match
01132    D308  BD 11 02     	LDA	Ibuffs,X		; restore byte from input buffer
01133    D30B  10 C3        	BPL	LAB_13EA		; branch always (all bytes in buffer are $00-$7F)
01134    					; go save byte in output and continue crunching
01135    
01136    					; reached [EOL]
01137    LAB_142A
01138    D30D  C8           	INY				; increment pointer
01139    D30E  C8           	INY				; increment pointer (makes it next line pointer high byte)
01140    D30F  99 11 02     	STA	Ibuffs,Y		; save [EOL] (marks [EOT] in immediate mode)
01141    D312  C8           	INY				; adjust for line copy
01142    D313  C8           	INY				; adjust for line copy
01143    D314  C8           	INY				; adjust for line copy
01144    D315  C6 C3        	DEC	Bpntrl		; allow for increment (change if buffer starts at $xxFF)
01145    D317  60           	RTS
01146    
01147    ; search Basic for temp integer line number from start of mem
01148    
01149    LAB_SSLN
01150    D318  A5 79        	LDA	Smeml			; get start of mem low byte
01151    D31A  A6 7A        	LDX	Smemh			; get start of mem high byte
01152    
01153    ; search Basic for temp integer line number from AX
01154    ; returns carry set if found
01155    ; returns Baslnl/Baslnh pointer to found or next higher (not found) line
01156    
01157    ; old 541 new 507
01158    
01159    LAB_SHLN
01160    D31C  A0 01        	LDY	#$01			; set index
01161    D31E  85 AA        	STA	Baslnl		; save low byte as current
01162    D320  86 AB        	STX	Baslnh		; save high byte as current
01163    D322  B1 AA        	LDA	(Baslnl),Y		; get pointer high byte from addr
01164    D324  F0 1A        	BEQ	LAB_145F		; pointer was zero so we're done, do 'not found' exit
01165    
01166    D326  A0 03        	LDY	#$03			; set index to line # high byte
01167    D328  B1 AA        	LDA	(Baslnl),Y		; get line # high byte
01168    D32A  88           	DEY				; decrement index (point to low byte)
01169    D32B  C5 12        	CMP	Itemph		; compare with temporary integer high byte
01170    D32D  D0 04        	BNE	LAB_1455		; if <> skip low byte check
01171    
01172    D32F  B1 AA        	LDA	(Baslnl),Y		; get line # low byte
01173    D331  C5 11        	CMP	Itempl		; compare with temporary integer low byte
01174    LAB_1455
01175    D333  B0 09        	BCS	LAB_145E		; else if temp < this line, exit (passed line#)
01176    
01177    LAB_1456
01178    D335  88           	DEY				; decrement index to next line ptr high byte
01179    D336  B1 AA        	LDA	(Baslnl),Y		; get next line pointer high byte
01180    D338  AA           	TAX				; copy to X
01181    D339  88           	DEY				; decrement index to next line ptr low byte
01182    D33A  B1 AA        	LDA	(Baslnl),Y		; get next line pointer low byte
01183    D33C  90 DE        	BCC	LAB_SHLN		; go search for line # in temp (Itempl/Itemph) from AX
01184    					; (carry always clear)
01185    
01186    LAB_145E
01187    D33E  F0 01        	BEQ	LAB_1460		; exit if temp = found line #, carry is set
01188    
01189    LAB_145F
01190    D340  18           	CLC				; clear found flag
01191    LAB_1460
01192    D341  60           	RTS
01193    
01194    ; perform NEW
01195    
01196    LAB_NEW
01197    D342  D0 FD        	BNE	LAB_1460		; exit if not end of statement (to do syntax error)
01198    
01199    LAB_1463
01200    D344  A9 00        	LDA	#$00			; clear A
01201    D346  A8           	TAY				; clear Y
01202    D347  91 79        	STA	(Smeml),Y		; clear first line, next line pointer, low byte
01203    D349  C8           	INY				; increment index
01204    D34A  91 79        	STA	(Smeml),Y		; clear first line, next line pointer, high byte
01205    D34C  18           	CLC				; clear carry
01206    D34D  A5 79        	LDA	Smeml			; get start of mem low byte
01207    D34F  69 02        	ADC	#$02			; calculate end of BASIC low byte
01208    D351  85 7B        	STA	Svarl			; save start of vars low byte
01209    D353  A5 7A        	LDA	Smemh			; get start of mem high byte
01210    D355  69 00        	ADC	#$00			; add any carry
01211    D357  85 7C        	STA	Svarh			; save start of vars high byte
01212    
01213    ; reset execution to start, clear vars and flush stack
01214    
01215    LAB_1477
01216    D359  18           	CLC				; clear carry
01217    D35A  A5 79        	LDA	Smeml			; get start of mem low byte
01218    D35C  69 FF        	ADC	#$FF			; -1
01219    D35E  85 C3        	STA	Bpntrl		; save BASIC execute pointer low byte
01220    D360  A5 7A        	LDA	Smemh			; get start of mem high byte
01221    D362  69 FF        	ADC	#$FF			; -1+carry
01222    D364  85 C4        	STA	Bpntrh		; save BASIC execute pointer high byte
01223    
01224    ; "CLEAR" command gets here
01225    
01226    LAB_147A
01227    D366  A5 85        	LDA	Ememl			; get end of mem low byte
01228    D368  A4 86        	LDY	Ememh			; get end of mem high byte
01229    D36A  85 81        	STA	Sstorl		; set bottom of string space low byte
01230    D36C  84 82        	STY	Sstorh		; set bottom of string space high byte
01231    D36E  A5 7B        	LDA	Svarl			; get start of vars low byte
01232    D370  A4 7C        	LDY	Svarh			; get start of vars high byte
01233    D372  85 7D        	STA	Sarryl		; save var mem end low byte
01234    D374  84 7E        	STY	Sarryh		; save var mem end high byte
01235    D376  85 7F        	STA	Earryl		; save array mem end low byte
01236    D378  84 80        	STY	Earryh		; save array mem end high byte
01237    D37A  20 38 D5     	JSR	LAB_161A		; perform RESTORE command
01238    
01239    ; flush stack and clear continue flag
01240    
01241    LAB_1491
01242    D37D  A2 68        	LDX	#des_sk		; set descriptor stack pointer
01243    D37F  86 65        	STX	next_s		; save descriptor stack pointer
01244    D381  68           	PLA				; pull return address low byte
01245    D382  AA           	TAX				; copy return address low byte
01246    D383  68           	PLA				; pull return address high byte
01247    D384  8E FE 01     	STX	LAB_SKFE		; save to cleared stack
01248    D387  8D FF 01     	STA	LAB_SKFF		; save to cleared stack
01249    D38A  A2 FD        	LDX	#$FD			; new stack pointer
01250    D38C  9A           	TXS				; reset stack
01251    D38D  A9 00        	LDA	#$00			; clear byte
01252    D38F  85 8C        	STA	Cpntrh		; clear continue pointer high byte
01253    D391  85 61        	STA	Sufnxf		; clear subscript/FNX flag
01254    LAB_14A6
01255    D393  60           	RTS
01256    
01257    ; perform CLEAR
01258    
01259    LAB_CLEAR
01260    D394  F0 D0        	BEQ	LAB_147A		; if no following token go do "CLEAR"
01261    
01262    					; else there was a following token (go do syntax error)
01263    D396  60           	RTS
01264    
01265    ; perform LIST [n][-m]
01266    ; bigger, faster version (a _lot_ faster)
01267    
01268    LAB_LIST
01269    D397  90 06        	BCC	LAB_14BD		; branch if next character numeric (LIST n..)
01270    
01271    D399  F0 04        	BEQ	LAB_14BD		; branch if next character [NULL] (LIST)
01272    
01273    D39B  C9 B7        	CMP	#TK_MINUS		; compare with token for -
01274    D39D  D0 F4        	BNE	LAB_14A6		; exit if not - (LIST -m)
01275    
01276    					; LIST [[n][-m]]
01277    					; this bit sets the n , if present, as the start and end
01278    LAB_14BD
01279    D39F  20 49 D7     	JSR	LAB_GFPN		; get fixed-point number into temp integer
01280    D3A2  20 18 D3     	JSR	LAB_SSLN		; search BASIC for temp integer line number
01281    					; (pointer in Baslnl/Baslnh)
01282    D3A5  20 C2 00     	JSR	LAB_GBYT		; scan memory
01283    D3A8  F0 0C        	BEQ	LAB_14D4		; branch if no more characters
01284    
01285    					; this bit checks the - is present
01286    D3AA  C9 B7        	CMP	#TK_MINUS		; compare with token for -
01287    D3AC  D0 93        	BNE	LAB_1460		; return if not "-" (will be Syntax error)
01288    
01289    					; LIST [n]-m
01290    					; the - was there so set m as the end value
01291    D3AE  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory
01292    D3B1  20 49 D7     	JSR	LAB_GFPN		; get fixed-point number into temp integer
01293    D3B4  D0 8B        	BNE	LAB_1460		; exit if not ok
01294    
01295    LAB_14D4
01296    D3B6  A5 11        	LDA	Itempl		; get temporary integer low byte
01297    D3B8  05 12        	ORA	Itemph		; OR temporary integer high byte
01298    D3BA  D0 06        	BNE	LAB_14E2		; branch if start set
01299    
01300    D3BC  A9 FF        	LDA	#$FF			; set for -1
01301    D3BE  85 11        	STA	Itempl		; set temporary integer low byte
01302    D3C0  85 12        	STA	Itemph		; set temporary integer high byte
01303    LAB_14E2
01304    D3C2  A0 01        	LDY	#$01			; set index for line
01305    D3C4  84 60        	STY	Oquote		; clear open quote flag
01306    D3C6  20 86 D8     	JSR	LAB_CRLF		; print CR/LF
01307    D3C9  B1 AA        	LDA	(Baslnl),Y		; get next line pointer high byte
01308    					; pointer initially set by search at LAB_14BD
01309    D3CB  F0 3E        	BEQ	LAB_152B		; if null all done so exit
01310    D3CD  20 08 D5     	JSR	LAB_1629		; do CRTL-C check vector
01311    
01312    D3D0  C8           	INY				; increment index for line
01313    D3D1  B1 AA        	LDA	(Baslnl),Y		; get line # low byte
01314    D3D3  AA           	TAX				; copy to X
01315    D3D4  C8           	INY				; increment index
01316    D3D5  B1 AA        	LDA	(Baslnl),Y		; get line # high byte
01317    D3D7  C5 12        	CMP	Itemph		; compare with temporary integer high byte
01318    D3D9  D0 04        	BNE	LAB_14FF		; branch if no high byte match
01319    
01320    D3DB  E4 11        	CPX	Itempl		; compare with temporary integer low byte
01321    D3DD  F0 02        	BEQ	LAB_1501		; branch if = last line to do (< will pass next branch)
01322    
01323    LAB_14FF				; else ..
01324    D3DF  B0 2A        	BCS	LAB_152B		; if greater all done so exit
01325    
01326    LAB_1501
01327    D3E1  84 97        	STY	Tidx1			; save index for line
01328    D3E3  20 76 EA     	JSR	LAB_295E		; print XA as unsigned integer
01329    D3E6  A9 20        	LDA	#$20			; space is the next character
01330    LAB_1508
01331    D3E8  A4 97        	LDY	Tidx1			; get index for line
01332    D3EA  29 7F        	AND	#$7F			; mask top out bit of character
01333    LAB_150C
01334    D3EC  20 E1 D8     	JSR	LAB_PRNA		; go print the character
01335    D3EF  C9 22        	CMP	#$22			; was it " character
01336    D3F1  D0 06        	BNE	LAB_1519		; branch if not
01337    
01338    					; we are either entering or leaving a pair of quotes
01339    D3F3  A5 60        	LDA	Oquote		; get open quote flag
01340    D3F5  49 FF        	EOR	#$FF			; toggle it
01341    D3F7  85 60        	STA	Oquote		; save it back
01342    LAB_1519
01343    D3F9  C8           	INY				; increment index
01344    D3FA  B1 AA        	LDA	(Baslnl),Y		; get next byte
01345    D3FC  D0 0E        	BNE	LAB_152E		; branch if not [EOL] (go print character)
01346    D3FE  A8           	TAY				; else clear index
01347    D3FF  B1 AA        	LDA	(Baslnl),Y		; get next line pointer low byte
01348    D401  AA           	TAX				; copy to X
01349    D402  C8           	INY				; increment index
01350    D403  B1 AA        	LDA	(Baslnl),Y		; get next line pointer high byte
01351    D405  86 AA        	STX	Baslnl		; set pointer to line low byte
01352    D407  85 AB        	STA	Baslnh		; set pointer to line high byte
01353    D409  D0 B7        	BNE	LAB_14E2		; go do next line if not [EOT]
01354    					; else ..
01355    LAB_152B
01356    D40B  60           	RTS
01357    
01358    LAB_152E
01359    D40C  10 DE        	BPL	LAB_150C		; just go print it if not token byte
01360    
01361    					; else was token byte so uncrunch it (maybe)
01362    D40E  24 60        	BIT	Oquote		; test the open quote flag
01363    D410  30 DA        	BMI	LAB_150C		; just go print character if open quote set
01364    
01365    D412  A2 F5        	LDX	#>LAB_KEYT		; get table address high byte
01366    D414  0A           	ASL				; *2
01367    D415  0A           	ASL				; *4
01368    D416  90 02        	BCC	LAB_152F		; branch if no carry
01369    
01370    D418  E8           	INX				; else increment high byte
01371    D419  18           	CLC				; clear carry for add
01372    LAB_152F
01373    D41A  69 1E        	ADC	#<LAB_KEYT		; add low byte
01374    D41C  90 01        	BCC	LAB_1530		; branch if no carry
01375    
01376    D41E  E8           	INX				; else increment high byte
01377    LAB_1530
01378    D41F  85 73        	STA	ut2_pl		; save table pointer low byte
01379    D421  86 74        	STX	ut2_ph		; save table pointer high byte
01380    D423  84 97        	STY	Tidx1			; save index for line
01381    D425  A0 00        	LDY	#$00			; clear index
01382    D427  B1 73        	LDA	(ut2_pl),Y		; get length
01383    D429  AA           	TAX				; copy length
01384    D42A  C8           	INY				; increment index
01385    D42B  B1 73        	LDA	(ut2_pl),Y		; get 1st character
01386    D42D  CA           	DEX				; decrement length
01387    D42E  F0 B8        	BEQ	LAB_1508		; if no more characters exit and print
01388    
01389    D430  20 E1 D8     	JSR	LAB_PRNA		; go print the character
01390    D433  C8           	INY				; increment index
01391    D434  B1 73        	LDA	(ut2_pl),Y		; get keyword address low byte
01392    D436  48           	PHA				; save it for now
01393    D437  C8           	INY				; increment index
01394    D438  B1 73        	LDA	(ut2_pl),Y		; get keyword address high byte
01395    D43A  A0 00        	LDY	#$00
01396    D43C  85 74        	STA	ut2_ph		; save keyword pointer high byte
01397    D43E  68           	PLA				; pull low byte
01398    D43F  85 73        	STA	ut2_pl		; save keyword pointer low byte
01399    LAB_1540
01400    D441  B1 73        	LDA	(ut2_pl),Y		; get character
01401    D443  CA           	DEX				; decrement character count
01402    D444  F0 A2        	BEQ	LAB_1508		; if last character exit and print
01403    
01404    D446  20 E1 D8     	JSR	LAB_PRNA		; go print the character
01405    D449  C8           	INY				; increment index
01406    D44A  D0 F5        	BNE	LAB_1540		; loop for next character
01407    
01408    ; perform FOR
01409    
01410    LAB_FOR
01411    D44C  A9 80        	LDA	#$80			; set FNX
01412    D44E  85 61        	STA	Sufnxf		; set subscript/FNX flag
01413    D450  20 A8 D7     	JSR	LAB_LET		; go do LET
01414    D453  68           	PLA				; pull return address
01415    D454  68           	PLA				; pull return address
01416    D455  A9 10        	LDA	#$10			; we need 16d bytes !
01417    D457  20 F5 D0     	JSR	LAB_1212		; check room on stack for A bytes
01418    D45A  20 91 D6     	JSR	LAB_SNBS		; scan for next BASIC statement ([:] or [EOL])
01419    D45D  18           	CLC				; clear carry for add
01420    D45E  98           	TYA				; copy index to A
01421    D45F  65 C3        	ADC	Bpntrl		; add BASIC execute pointer low byte
01422    D461  48           	PHA				; push onto stack
01423    D462  A5 C4        	LDA	Bpntrh		; get BASIC execute pointer high byte
01424    D464  69 00        	ADC	#$00			; add carry
01425    D466  48           	PHA				; push onto stack
01426    D467  A5 88        	LDA	Clineh		; get current line high byte
01427    D469  48           	PHA				; push onto stack
01428    D46A  A5 87        	LDA	Clinel		; get current line low byte
01429    D46C  48           	PHA				; push onto stack
01430    D46D  A9 AD        	LDA	#TK_TO		; get "TO" token
01431    D46F  20 E5 DB     	JSR	LAB_SCCA		; scan for CHR$(A) , else do syntax error then warm start
01432    D472  20 C4 DA     	JSR	LAB_CTNM		; check if source is numeric, else do type mismatch
01433    D475  20 C1 DA     	JSR	LAB_EVNM		; evaluate expression and check is numeric,
01434    					; else do type mismatch
01435    D478  A5 B0        	LDA	FAC1_s		; get FAC1 sign (b7)
01436    D47A  09 7F        	ORA	#$7F			; set all non sign bits
01437    D47C  25 AD        	AND	FAC1_1		; and FAC1 mantissa1
01438    D47E  85 AD        	STA	FAC1_1		; save FAC1 mantissa1
01439    D480  A9 8B        	LDA	#<LAB_159F		; set return address low byte
01440    D482  A0 D4        	LDY	#>LAB_159F		; set return address high byte
01441    D484  85 71        	STA	ut1_pl		; save return address low byte
01442    D486  84 72        	STY	ut1_ph		; save return address high byte
01443    D488  4C 78 DB     	JMP	LAB_1B66		; round FAC1 and put on stack (returns to next instruction)
01444    
01445    LAB_159F
01446    D48B  A9 ED        	LDA	#<LAB_259C		; set 1 pointer low addr (default step size)
01447    D48D  A0 F1        	LDY	#>LAB_259C		; set 1 pointer high addr
01448    D48F  20 71 E8     	JSR	LAB_UFAC		; unpack memory (AY) into FAC1
01449    D492  20 C2 00     	JSR	LAB_GBYT		; scan memory
01450    D495  C9 B2        	CMP	#TK_STEP		; compare with STEP token
01451    D497  D0 06        	BNE	LAB_15B3		; jump if not "STEP"
01452    
01453    					;.was step so ..
01454    D499  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory
01455    D49C  20 C1 DA     	JSR	LAB_EVNM		; evaluate expression and check is numeric,
01456    					; else do type mismatch
01457    LAB_15B3
01458    D49F  20 DD E8     	JSR	LAB_27CA		; return A=FF,C=1/-ve A=01,C=0/+ve
01459    D4A2  85 B0        	STA	FAC1_s		; set FAC1 sign (b7)
01460    					; this is +1 for +ve step and -1 for -ve step, in NEXT we
01461    					; compare the FOR value and the TO value and return +1 if
01462    					; FOR > TO, 0 if FOR = TO and -1 if FOR < TO. the value
01463    					; here (+/-1) is then compared to that result and if they
01464    					; are the same (+ve and FOR > TO or -ve and FOR < TO) then
01465    					; the loop is done
01466    D4A4  20 6D DB     	JSR	LAB_1B5B		; push sign, round FAC1 and put on stack
01467    D4A7  A5 98        	LDA	Frnxth		; get var pointer for FOR/NEXT high byte
01468    D4A9  48           	PHA				; push on stack
01469    D4AA  A5 97        	LDA	Frnxtl		; get var pointer for FOR/NEXT low byte
01470    D4AC  48           	PHA				; push on stack
01471    D4AD  A9 81        	LDA	#TK_FOR		; get FOR token
01472    D4AF  48           	PHA				; push on stack
01473    
01474    ; interpreter inner loop
01475    
01476    LAB_15C2
01477    D4B0  20 08 D5     	JSR	LAB_1629		; do CRTL-C check vector
01478    on_interrupt
01479    D4B3  A5 C3        	LDA	Bpntrl		; get BASIC execute pointer low byte
01480    D4B5  A4 C4        	LDY	Bpntrh		; get BASIC execute pointer high byte
01481    
01482    D4B7  A6 88        	LDX	Clineh		; continue line is $FFxx for immediate mode
01483    					; ($00xx for RUN from immediate mode)
01484    D4B9  E8           	INX				; increment it (now $00 if immediate mode)
01485    D4BA  F0 04        	BEQ	LAB_15D1		; branch if null (immediate mode)
01486    
01487    D4BC  85 8B        	STA	Cpntrl		; save continue pointer low byte
01488    D4BE  84 8C        	STY	Cpntrh		; save continue pointer high byte
01489    LAB_15D1
01490    D4C0  A0 00        	LDY	#$00			; clear index
01491    D4C2  B1 C3        	LDA	(Bpntrl),Y		; get next byte
01492    D4C4  F0 07        	BEQ	LAB_15DC		; branch if null [EOL]
01493    
01494    D4C6  C9 3A        	CMP	#':'			; compare with ":"
01495    D4C8  F0 1D        	BEQ	LAB_15F6		; branch if = (statement separator)
01496    
01497    LAB_15D9
01498    D4CA  4C F6 DB     	JMP	LAB_SNER		; else syntax error then warm start
01499    
01500    					; have reached [EOL]
01501    LAB_15DC
01502    D4CD  A0 02        	LDY	#$02			; set index
01503    D4CF  B1 C3        	LDA	(Bpntrl),Y		; get next line pointer high byte
01504    D4D1  18           	CLC				; clear carry for no "BREAK" message
01505    D4D2  F0 56        	BEQ	LAB_1651		; if null go to immediate mode (was immediate or [EOT]
01506    					; marker)
01507    
01508    D4D4  C8           	INY				; increment index
01509    D4D5  B1 C3        	LDA	(Bpntrl),Y		; get line # low byte
01510    D4D7  85 87        	STA	Clinel		; save current line low byte
01511    D4D9  C8           	INY				; increment index
01512    D4DA  B1 C3        	LDA	(Bpntrl),Y		; get line # high byte
01513    D4DC  85 88        	STA	Clineh		; save current line high byte
01514    D4DE  98           	TYA				; A now = 4
01515    D4DF  65 C3        	ADC	Bpntrl		; add BASIC execute pointer low byte
01516    D4E1  85 C3        	STA	Bpntrl		; save BASIC execute pointer low byte
01517    D4E3  90 02        	BCC	LAB_15F6		; branch if no overflow
01518    
01519    D4E5  E6 C4        	INC	Bpntrh		; else increment BASIC execute pointer high byte
01520    LAB_15F6
01521    D4E7  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory
01522    
01523    LAB_15F9
01524    D4EA  20 F0 D4     	JSR	LAB_15FF		; go interpret BASIC code from (Bpntrl)
01525    
01526    LAB_15FC
01527    D4ED  4C B0 D4     	JMP	LAB_15C2		; loop
01528    
01529    ; interpret BASIC code from (Bpntrl)
01530    
01531    LAB_15FF
01532    D4F0  F0 54        	BEQ	LAB_1628		; exit if zero [EOL]
01533    
01534    LAB_1602
01535    D4F2  0A           	ASL				; *2 bytes per vector and normalise token
01536    D4F3  B0 03        	BCS	LAB_1609		; branch if was token
01537    
01538    D4F5  4C A8 D7     	JMP	LAB_LET		; else go do implied LET
01539    
01540    LAB_1609
01541    D4F8  C9 56        	CMP	#[TK_TAB-$80]*2	; compare normalised token * 2 with TAB
01542    D4FA  B0 CE        	BCS	LAB_15D9		; branch if A>=TAB (do syntax error then warm start)
01543    					; only tokens before TAB can start a line
01544    D4FC  A8           	TAY				; copy to index
01545    D4FD  B9 15 F2     	LDA	LAB_CTBL+1,Y	; get vector high byte
01546    D500  48           	PHA				; onto stack
01547    D501  B9 14 F2     	LDA	LAB_CTBL,Y		; get vector low byte
01548    D504  48           	PHA				; onto stack
01549    D505  4C BC 00     	JMP	LAB_IGBY		; jump to increment and scan memory
01550    					; then "return" to vector
01551    
01552    ; CTRL-C check jump. this is called as a subroutine but exits back via a jump if a
01553    ; key press is detected.
01554    
01555    LAB_1629
01556    D508  6C 03 02     	JMP	(VEC_CC)		; ctrl c check vector
01557    
01558    ; if there was a key press it gets back here ..
01559    
01560    LAB_1636
01561    D50B  C9 03        	CMP	#$03			; compare with CTRL-C
01562    
01563    ; perform STOP
01564    
01565    LAB_STOP
01566    D50D  B0 01        	BCS	LAB_163B		; branch if token follows STOP
01567    					; else just END
01568    ; END
01569    
01570    LAB_END
01571    D50F  18           	CLC				; clear the carry, indicate a normal program end
01572    LAB_163B
01573    D510  D0 67        	BNE	LAB_167A		; if wasn't CTRL-C or there is a following byte return
01574    
01575    D512  A5 C4        	LDA	Bpntrh		; get the BASIC execute pointer high byte
01576    D514  49 02        	EOR	#>Ibuffs		; compare with buffer address high byte (Cb unchanged)
01577    D516  F0 10        	BEQ	LAB_164F		; branch if the BASIC pointer is in the input buffer
01578    					; (can't continue in immediate mode)
01579    
01580    					; else ..
01581    D518  49 02        	EOR	#>Ibuffs		; correct the bits
01582    D51A  A4 C3        	LDY	Bpntrl		; get BASIC execute pointer low byte
01583    D51C  84 8B        	STY	Cpntrl		; save continue pointer low byte
01584    D51E  85 8C        	STA	Cpntrh		; save continue pointer high byte
01585    LAB_1647
01586    D520  A5 87        	LDA	Clinel		; get current line low byte
01587    D522  A4 88        	LDY	Clineh		; get current line high byte
01588    D524  85 89        	STA	Blinel		; save break line low byte
01589    D526  84 8A        	STY	Blineh		; save break line high byte
01590    LAB_164F
01591    D528  68           	PLA				; pull return address low
01592    D529  68           	PLA				; pull return address high
01593    LAB_1651
01594    D52A  90 07        	BCC	LAB_165E		; if was program end just do warm start
01595    
01596    					; else ..
01597    D52C  A9 EB        	LDA	#<LAB_BMSG		; point to "Break" low byte
01598    D52E  A0 F7        	LDY	#>LAB_BMSG		; point to "Break" high byte
01599    D530  4C 41 D1     	JMP	LAB_1269		; print "Break" and do warm start
01600    
01601    LAB_165E
01602    D533  4C 4C D1     	JMP	LAB_1274		; go do warm start
01603    
01604    ; perform RESTORE
01605    
01606    LAB_RESTORE
01607    D536  D0 0F        	BNE	LAB_RESTOREn	; branch if next character not null (RESTORE n)
01608    
01609    LAB_161A
01610    D538  38           	SEC				; set carry for subtract
01611    D539  A5 79        	LDA	Smeml			; get start of mem low byte
01612    D53B  E9 01        	SBC	#$01			; -1
01613    D53D  A4 7A        	LDY	Smemh			; get start of mem high byte
01614    D53F  B0 01        	BCS	LAB_1624		; branch if no underflow
01615    
01616    LAB_uflow
01617    D541  88           	DEY				; else decrement high byte
01618    LAB_1624
01619    D542  85 8F        	STA	Dptrl			; save DATA pointer low byte
01620    D544  84 90        	STY	Dptrh			; save DATA pointer high byte
01621    LAB_1628
01622    D546  60           	RTS
01623    
01624    					; is RESTORE n
01625    LAB_RESTOREn
01626    D547  20 49 D7     	JSR	LAB_GFPN		; get fixed-point number into temp integer
01627    D54A  20 94 D6     	JSR	LAB_SNBL		; scan for next BASIC line
01628    D54D  A5 88        	LDA	Clineh		; get current line high byte
01629    D54F  C5 12        	CMP	Itemph		; compare with temporary integer high byte
01630    D551  B0 0B        	BCS	LAB_reset_search	; branch if >= (start search from beginning)
01631    
01632    D553  98           	TYA				; else copy line index to A
01633    D554  38           	SEC				; set carry (+1)
01634    D555  65 C3        	ADC	Bpntrl		; add BASIC execute pointer low byte
01635    D557  A6 C4        	LDX	Bpntrh		; get BASIC execute pointer high byte
01636    D559  90 07        	BCC	LAB_go_search	; branch if no overflow to high byte
01637    
01638    D55B  E8           	INX				; increment high byte
01639    D55C  B0 04        	BCS	LAB_go_search	; branch always (can never be carry clear)
01640    
01641    ; search for line # in temp (Itempl/Itemph) from start of mem pointer (Smeml)
01642    
01643    LAB_reset_search
01644    D55E  A5 79        	LDA	Smeml			; get start of mem low byte
01645    D560  A6 7A        	LDX	Smemh			; get start of mem high byte
01646    
01647    ; search for line # in temp (Itempl/Itemph) from (AX)
01648    
01649    LAB_go_search
01650    
01651    D562  20 1C D3     	JSR	LAB_SHLN		; search Basic for temp integer line number from AX
01652    D565  B0 03        	BCS	LAB_line_found	; if carry set go set pointer
01653    
01654    D567  4C 66 D6     	JMP	LAB_16F7		; else go do "Undefined statement" error
01655    
01656    LAB_line_found
01657    					; carry already set for subtract
01658    D56A  A5 AA        	LDA	Baslnl		; get pointer low byte
01659    D56C  E9 01        	SBC	#$01			; -1
01660    D56E  A4 AB        	LDY	Baslnh		; get pointer high byte
01661    D570  B0 D0        	BCS	LAB_1624		; branch if no underflow (save DATA pointer and return)
01662    
01663    D572  90 CD        	BCC	LAB_uflow		; else decrement high byte then save DATA pointer and
01664    					; return (branch always)
01665    
01666    ; perform NULL
01667    
01668    LAB_NULL
01669    D574  20 80 E4     	JSR	LAB_GTBY		; get byte parameter
01670    D577  86 0D        	STX	Nullct		; save new NULL count
01671    LAB_167A
01672    D579  60           	RTS
01673    
01674    ; perform CONT
01675    
01676    LAB_CONT
01677    D57A  D0 FD        	BNE	LAB_167A		; if following byte exit to do syntax error
01678    
01679    D57C  A4 8C        	LDY	Cpntrh		; get continue pointer high byte
01680    D57E  D0 05        	BNE	LAB_166C		; go do continue if we can
01681    
01682    D580  A2 1E        	LDX	#$1E			; error code $1E ("Can't continue" error)
01683    D582  4C 2E D1     	JMP	LAB_XERR		; do error #X, then warm start
01684    
01685    					; we can continue so ..
01686    LAB_166C
01687    D585  A9 93        	LDA	#TK_ON		; set token for ON
01688    D587  20 0A EF     	JSR	LAB_IRQ		; set IRQ flags
01689    D58A  A9 93        	LDA	#TK_ON		; set token for ON
01690    D58C  20 0E EF     	JSR	LAB_NMI		; set NMI flags
01691    
01692    D58F  84 C4        	STY	Bpntrh		; save BASIC execute pointer high byte
01693    D591  A5 8B        	LDA	Cpntrl		; get continue pointer low byte
01694    D593  85 C3        	STA	Bpntrl		; save BASIC execute pointer low byte
01695    D595  A5 89        	LDA	Blinel		; get break line low byte
01696    D597  A4 8A        	LDY	Blineh		; get break line high byte
01697    D599  85 87        	STA	Clinel		; set current line low byte
01698    D59B  84 88        	STY	Clineh		; set current line high byte
01699    D59D  60           	RTS
01700    
01701    ; perform RUN
01702    
01703    LAB_RUN
01704    D59E  D0 03        	BNE	LAB_1696		; branch if RUN n
01705    D5A0  4C 59 D3     	JMP	LAB_1477		; reset execution to start, clear variables, flush stack and
01706    					; return
01707    
01708    ; does RUN n
01709    
01710    LAB_1696
01711    D5A3  20 66 D3     	JSR	LAB_147A		; go do "CLEAR"
01712    D5A6  F0 2E        	BEQ	LAB_16B0		; get n and do GOTO n (branch always as CLEAR sets Z=1)
01713    
01714    ; perform DO
01715    
01716    LAB_DO
01717    D5A8  A9 05        	LDA	#$05			; need 5 bytes for DO
01718    D5AA  20 F5 D0     	JSR	LAB_1212		; check room on stack for A bytes
01719    D5AD  A5 C4        	LDA	Bpntrh		; get BASIC execute pointer high byte
01720    D5AF  48           	PHA				; push on stack
01721    D5B0  A5 C3        	LDA	Bpntrl		; get BASIC execute pointer low byte
01722    D5B2  48           	PHA				; push on stack
01723    D5B3  A5 88        	LDA	Clineh		; get current line high byte
01724    D5B5  48           	PHA				; push on stack
01725    D5B6  A5 87        	LDA	Clinel		; get current line low byte
01726    D5B8  48           	PHA				; push on stack
01727    D5B9  A9 9D        	LDA	#TK_DO		; token for DO
01728    D5BB  48           	PHA				; push on stack
01729    D5BC  20 C2 00     	JSR	LAB_GBYT		; scan memory
01730    D5BF  4C B0 D4     	JMP	LAB_15C2		; go do interpreter inner loop
01731    
01732    ; perform GOSUB
01733    
01734    LAB_GOSUB
01735    D5C2  A9 05        	LDA	#$05			; need 5 bytes for GOSUB
01736    D5C4  20 F5 D0     	JSR	LAB_1212		; check room on stack for A bytes
01737    D5C7  A5 C4        	LDA	Bpntrh		; get BASIC execute pointer high byte
01738    D5C9  48           	PHA				; push on stack
01739    D5CA  A5 C3        	LDA	Bpntrl		; get BASIC execute pointer low byte
01740    D5CC  48           	PHA				; push on stack
01741    D5CD  A5 88        	LDA	Clineh		; get current line high byte
01742    D5CF  48           	PHA				; push on stack
01743    D5D0  A5 87        	LDA	Clinel		; get current line low byte
01744    D5D2  48           	PHA				; push on stack
01745    D5D3  A9 8D        	LDA	#TK_GOSUB		; token for GOSUB
01746    D5D5  48           	PHA				; push on stack
01747    LAB_16B0
01748    D5D6  20 C2 00     	JSR	LAB_GBYT		; scan memory
01749    D5D9  20 DF D5     	JSR	LAB_GOTO		; perform GOTO n
01750    D5DC  4C B0 D4     	JMP	LAB_15C2		; go do interpreter inner loop
01751    					; (can't RTS, we used the stack!)
01752    
01753    ; perform GOTO
01754    
01755    LAB_GOTO
01756    D5DF  20 49 D7     	JSR	LAB_GFPN		; get fixed-point number into temp integer
01757    D5E2  20 94 D6     	JSR	LAB_SNBL		; scan for next BASIC line
01758    D5E5  A5 88        	LDA	Clineh		; get current line high byte
01759    D5E7  C5 12        	CMP	Itemph		; compare with temporary integer high byte
01760    D5E9  B0 0B        	BCS	LAB_16D0		; branch if >= (start search from beginning)
01761    
01762    D5EB  98           	TYA				; else copy line index to A
01763    D5EC  38           	SEC				; set carry (+1)
01764    D5ED  65 C3        	ADC	Bpntrl		; add BASIC execute pointer low byte
01765    D5EF  A6 C4        	LDX	Bpntrh		; get BASIC execute pointer high byte
01766    D5F1  90 07        	BCC	LAB_16D4		; branch if no overflow to high byte
01767    
01768    D5F3  E8           	INX				; increment high byte
01769    D5F4  B0 04        	BCS	LAB_16D4		; branch always (can never be carry)
01770    
01771    ; search for line # in temp (Itempl/Itemph) from start of mem pointer (Smeml)
01772    
01773    LAB_16D0
01774    D5F6  A5 79        	LDA	Smeml			; get start of mem low byte
01775    D5F8  A6 7A        	LDX	Smemh			; get start of mem high byte
01776    
01777    ; search for line # in temp (Itempl/Itemph) from (AX)
01778    
01779    LAB_16D4
01780    D5FA  20 1C D3     	JSR	LAB_SHLN		; search Basic for temp integer line number from AX
01781    D5FD  90 67        	BCC	LAB_16F7		; if carry clear go do "Undefined statement" error
01782    					; (unspecified statement)
01783    
01784    					; carry already set for subtract
01785    D5FF  A5 AA        	LDA	Baslnl		; get pointer low byte
01786    D601  E9 01        	SBC	#$01			; -1
01787    D603  85 C3        	STA	Bpntrl		; save BASIC execute pointer low byte
01788    D605  A5 AB        	LDA	Baslnh		; get pointer high byte
01789    D607  E9 00        	SBC	#$00			; subtract carry
01790    D609  85 C4        	STA	Bpntrh		; save BASIC execute pointer high byte
01791    LAB_16E5
01792    D60B  60           	RTS
01793    
01794    LAB_DONOK
01795    D60C  A2 22        	LDX	#$22			; error code $22 ("LOOP without DO" error)
01796    D60E  4C 2E D1     	JMP	LAB_XERR		; do error #X, then warm start
01797    
01798    ; perform LOOP
01799    
01800    LAB_LOOP
01801    D611  A8           	TAY				; save following token
01802    D612  BA           	TSX				; copy stack pointer
01803    D613  BD 03 01     	LDA	LAB_STAK+3,X	; get token byte from stack
01804    D616  C9 9D        	CMP	#TK_DO		; compare with DO token
01805    D618  D0 F2        	BNE	LAB_DONOK		; branch if no matching DO
01806    
01807    D61A  E8           	INX				; dump calling routine return address
01808    D61B  E8           	INX				; dump calling routine return address
01809    D61C  9A           	TXS				; correct stack
01810    D61D  98           	TYA				; get saved following token back
01811    D61E  F0 20        	BEQ	LoopAlways		; if no following token loop forever
01812    					; (stack pointer in X)
01813    
01814    D620  C9 3A        	CMP	#':'			; could be ':'
01815    D622  F0 1C        	BEQ	LoopAlways		; if :... loop forever
01816    
01817    D624  E9 B3        	SBC	#TK_UNTIL		; subtract token for UNTIL, we know carry is set here
01818    D626  AA           	TAX				; copy to X (if it was UNTIL then Y will be correct)
01819    D627  F0 04        	BEQ	DoRest		; branch if was UNTIL
01820    
01821    D629  CA           	DEX				; decrement result
01822    D62A  D0 62        	BNE	LAB_16FC		; if not WHILE go do syntax error and warm start
01823    					; only if the token was WHILE will this fail
01824    
01825    D62C  CA           	DEX				; set invert result byte
01826    DoRest
01827    D62D  86 98        	STX	Frnxth		; save invert result byte
01828    D62F  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory
01829    D632  20 D5 DA     	JSR	LAB_EVEX		; evaluate expression
01830    D635  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
01831    D637  F0 02        	BEQ	DoCmp			; if =0 go do straight compare
01832    
01833    D639  A9 FF        	LDA	#$FF			; else set all bits
01834    DoCmp
01835    D63B  BA           	TSX				; copy stack pointer
01836    D63C  45 98        	EOR	Frnxth		; EOR with invert byte
01837    D63E  D0 1A        	BNE	LoopDone		; if <> 0 clear stack and back to interpreter loop
01838    
01839    					; loop condition wasn't met so do it again
01840    LoopAlways
01841    D640  BD 02 01     	LDA	LAB_STAK+2,X	; get current line low byte
01842    D643  85 87        	STA	Clinel		; save current line low byte
01843    D645  BD 03 01     	LDA	LAB_STAK+3,X	; get current line high byte
01844    D648  85 88        	STA	Clineh		; save current line high byte
01845    D64A  BD 04 01     	LDA	LAB_STAK+4,X	; get BASIC execute pointer low byte
01846    D64D  85 C3        	STA	Bpntrl		; save BASIC execute pointer low byte
01847    D64F  BD 05 01     	LDA	LAB_STAK+5,X	; get BASIC execute pointer high byte
01848    D652  85 C4        	STA	Bpntrh		; save BASIC execute pointer high byte
01849    D654  20 C2 00     	JSR	LAB_GBYT		; scan memory
01850    D657  4C B0 D4     	JMP	LAB_15C2		; go do interpreter inner loop
01851    
01852    					; clear stack and back to interpreter loop
01853    LoopDone
01854    D65A  E8           	INX				; dump DO token
01855    D65B  E8           	INX				; dump current line low byte
01856    D65C  E8           	INX				; dump current line high byte
01857    D65D  E8           	INX				; dump BASIC execute pointer low byte
01858    D65E  E8           	INX				; dump BASIC execute pointer high byte
01859    D65F  9A           	TXS				; correct stack
01860    D660  4C 80 D6     	JMP	LAB_DATA		; go perform DATA (find : or [EOL])
01861    
01862    ; do the return without gosub error
01863    
01864    LAB_16F4
01865    D663  A2 04        	LDX	#$04			; error code $04 ("RETURN without GOSUB" error)
01866    	.byte	$2C			; makes next line BIT LAB_0EA2
01867    
01868    LAB_16F7				; do undefined statement error
01869    D666  A2 0E        	LDX	#$0E			; error code $0E ("Undefined statement" error)
01870    D668  4C 2E D1     	JMP	LAB_XERR		; do error #X, then warm start
01871    
01872    ; perform RETURN
01873    
01874    LAB_RETURN
01875    D66B  D0 9E        	BNE	LAB_16E5		; exit if following token (to allow syntax error)
01876    
01877    LAB_16E8
01878    D66D  68           	PLA				; dump calling routine return address
01879    D66E  68           	PLA				; dump calling routine return address
01880    D66F  68           	PLA				; pull token
01881    D670  C9 8D        	CMP	#TK_GOSUB		; compare with GOSUB token
01882    D672  D0 EF        	BNE	LAB_16F4		; branch if no matching GOSUB
01883    
01884    LAB_16FF
01885    D674  68           	PLA				; pull current line low byte
01886    D675  85 87        	STA	Clinel		; save current line low byte
01887    D677  68           	PLA				; pull current line high byte
01888    D678  85 88        	STA	Clineh		; save current line high byte
01889    D67A  68           	PLA				; pull BASIC execute pointer low byte
01890    D67B  85 C3        	STA	Bpntrl		; save BASIC execute pointer low byte
01891    D67D  68           	PLA				; pull BASIC execute pointer high byte
01892    D67E  85 C4        	STA	Bpntrh		; save BASIC execute pointer high byte
01893    
01894    					; now do the DATA statement as we could be returning into
01895    					; the middle of an ON <var> GOSUB n,m,p,q line
01896    					; (the return address used by the DATA statement is the one
01897    					; pushed before the GOSUB was executed!)
01898    
01899    ; perform DATA
01900    
01901    LAB_DATA
01902    D680  20 91 D6     	JSR	LAB_SNBS		; scan for next BASIC statement ([:] or [EOL])
01903    
01904    					; set BASIC execute pointer
01905    LAB_170F
01906    D683  98           	TYA				; copy index to A
01907    D684  18           	CLC				; clear carry for add
01908    D685  65 C3        	ADC	Bpntrl		; add BASIC execute pointer low byte
01909    D687  85 C3        	STA	Bpntrl		; save BASIC execute pointer low byte
01910    D689  90 02        	BCC	LAB_1719		; skip next if no carry
01911    
01912    D68B  E6 C4        	INC	Bpntrh		; else increment BASIC execute pointer high byte
01913    LAB_1719
01914    D68D  60           	RTS
01915    
01916    LAB_16FC
01917    D68E  4C F6 DB     	JMP	LAB_SNER		; do syntax error then warm start
01918    
01919    ; scan for next BASIC statement ([:] or [EOL])
01920    ; returns Y as index to [:] or [EOL]
01921    
01922    LAB_SNBS
01923    D691  A2 3A        	LDX	#':'			; set look for character = ":"
01924    	.byte	$2C			; makes next line BIT $00A2
01925    
01926    ; scan for next BASIC line
01927    ; returns Y as index to [EOL]
01928    
01929    LAB_SNBL
01930    D694  A2 00        	LDX	#$00			; set alt search character = [EOL]
01931    D696  A0 00        	LDY	#$00			; set search character = [EOL]
01932    D698  84 5C        	STY	Asrch			; store search character
01933    LAB_1725
01934    D69A  8A           	TXA				; get alt search character
01935    D69B  45 5C        	EOR	Asrch			; toggle search character, effectively swap with $00
01936    D69D  85 5C        	STA	Asrch			; save swapped search character
01937    LAB_172D
01938    D69F  B1 C3        	LDA	(Bpntrl),Y		; get next byte
01939    D6A1  F0 EA        	BEQ	LAB_1719		; exit if null [EOL]
01940    
01941    D6A3  C5 5C        	CMP	Asrch			; compare with search character
01942    D6A5  F0 E6        	BEQ	LAB_1719		; exit if found
01943    
01944    D6A7  C8           	INY				; increment index
01945    D6A8  C9 22        	CMP	#$22			; compare current character with open quote
01946    D6AA  D0 F3        	BNE	LAB_172D		; if not open quote go get next character
01947    
01948    D6AC  F0 EC        	BEQ	LAB_1725		; if found go swap search character for alt search character
01949    
01950    ; perform IF
01951    
01952    LAB_IF
01953    D6AE  20 D5 DA     	JSR	LAB_EVEX		; evaluate the expression
01954    D6B1  20 C2 00     	JSR	LAB_GBYT		; scan memory
01955    D6B4  C9 B0        	CMP	#TK_THEN		; compare with THEN token
01956    D6B6  F0 11        	BEQ	LAB_174B		; if it was THEN go do IF
01957    
01958    					; wasn't IF .. THEN so must be IF .. GOTO
01959    D6B8  C9 89        	CMP	#TK_GOTO		; compare with GOTO token
01960    D6BA  D0 D2        	BNE	LAB_16FC		; if it wasn't GOTO go do syntax error
01961    
01962    D6BC  A6 C3        	LDX	Bpntrl		; save the basic pointer low byte
01963    D6BE  A4 C4        	LDY	Bpntrh		; save the basic pointer high byte
01964    D6C0  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory
01965    D6C3  B0 C9        	BCS	LAB_16FC		; if not numeric go do syntax error
01966    
01967    D6C5  86 C3        	STX	Bpntrl		; restore the basic pointer low byte
01968    D6C7  84 C4        	STY	Bpntrh		; restore the basic pointer high byte
01969    LAB_174B
01970    D6C9  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
01971    D6CB  F0 1B        	BEQ	LAB_174E		; if the result was zero go look for an ELSE
01972    
01973    D6CD  20 BC 00     	JSR	LAB_IGBY		; else increment and scan memory
01974    D6D0  B0 03        	BCS	LAB_174D		; if not numeric go do var or keyword
01975    
01976    LAB_174C
01977    D6D2  4C DF D5     	JMP	LAB_GOTO		; else was numeric so do GOTO n
01978    
01979    					; is var or keyword
01980    LAB_174D
01981    D6D5  C9 90        	CMP	#TK_RETURN		; compare the byte with the token for RETURN
01982    D6D7  D0 03        	BNE	LAB_174G		; if it wasn't RETURN go interpret BASIC code from (Bpntrl)
01983    					; and return to this code to process any following code
01984    
01985    D6D9  4C F2 D4     	JMP	LAB_1602		; else it was RETURN so interpret BASIC code from (Bpntrl)
01986    					; but don't return here
01987    
01988    LAB_174G
01989    D6DC  20 F0 D4     	JSR	LAB_15FF		; interpret BASIC code from (Bpntrl)
01990    
01991    ; the IF was executed and there may be a following ELSE so the code needs to return
01992    ; here to check and ignore the ELSE if present
01993    
01994    D6DF  A0 00        	LDY	#$00			; clear the index
01995    D6E1  B1 C3        	LDA	(Bpntrl),Y		; get the next BASIC byte
01996    D6E3  C9 AC        	CMP	#TK_ELSE		; compare it with the token for ELSE
01997    D6E5  F0 99        	BEQ	LAB_DATA		; if ELSE ignore the following statement
01998    
01999    ; there was no ELSE so continue execution of IF <expr> THEN <stat> [: <stat>]. any
02000    ; following ELSE will, correctly, cause a syntax error
02001    
02002    D6E7  60           	RTS				; else return to the interpreter inner loop
02003    
02004    ; perform ELSE after IF
02005    
02006    LAB_174E
02007    D6E8  A0 00        	LDY	#$00			; clear the BASIC byte index
02008    D6EA  A2 01        	LDX	#$01			; clear the nesting depth
02009    LAB_1750
02010    D6EC  C8           	INY				; increment the BASIC byte index
02011    D6ED  B1 C3        	LDA	(Bpntrl),Y		; get the next BASIC byte
02012    D6EF  F0 0F        	BEQ	LAB_1753		; if EOL go add the pointer and return
02013    
02014    D6F1  C9 8B        	CMP	#TK_IF		; compare the byte with the token for IF
02015    D6F3  D0 03        	BNE	LAB_1752		; if not IF token skip the depth increment
02016    
02017    D6F5  E8           	INX				; else increment the nesting depth ..
02018    D6F6  D0 F4        	BNE	LAB_1750		; .. and continue looking
02019    
02020    LAB_1752
02021    D6F8  C9 AC        	CMP	#TK_ELSE		; compare the byte with the token for ELSE
02022    D6FA  D0 F0        	BNE	LAB_1750		; if not ELSE token continue looking
02023    
02024    D6FC  CA           	DEX				; was ELSE so decrement the nesting depth
02025    D6FD  D0 ED        	BNE	LAB_1750		; loop if still nested
02026    
02027    D6FF  C8           	INY				; increment the BASIC byte index past the ELSE
02028    
02029    ; found the matching ELSE, now do <{n|statement}>
02030    
02031    LAB_1753
02032    D700  98           	TYA				; else copy line index to A
02033    D701  18           	CLC				; clear carry for add
02034    D702  65 C3        	ADC	Bpntrl		; add the BASIC execute pointer low byte
02035    D704  85 C3        	STA	Bpntrl		; save the BASIC execute pointer low byte
02036    D706  90 02        	BCC	LAB_1754		; branch if no overflow to high byte
02037    
02038    D708  E6 C4        	INC	Bpntrh		; else increment the BASIC execute pointer high byte
02039    LAB_1754
02040    D70A  20 C2 00     	JSR	LAB_GBYT		; scan memory
02041    D70D  90 C3        	BCC	LAB_174C		; if numeric do GOTO n
02042    					; the code will return to the interpreter loop at the
02043    					; tail end of the GOTO <n>
02044    
02045    D70F  4C F0 D4     	JMP	LAB_15FF		; interpret BASIC code from (Bpntrl)
02046    					; the code will return to the interpreter loop at the
02047    					; tail end of the <statement>
02048    
02049    ; perform REM, skip (rest of) line
02050    
02051    LAB_REM
02052    D712  20 94 D6     	JSR	LAB_SNBL		; scan for next BASIC line
02053    D715  4C 83 D6     	JMP	LAB_170F		; go set BASIC execute pointer and return, branch always
02054    
02055    LAB_16FD
02056    D718  4C F6 DB     	JMP	LAB_SNER		; do syntax error then warm start
02057    
02058    ; perform ON
02059    
02060    LAB_ON
02061    D71B  C9 A9        	CMP	#TK_IRQ		; was it IRQ token ?
02062    D71D  D0 03        	BNE	LAB_NOIN		; if not go check NMI
02063    
02064    D71F  4C 3D EF     	JMP	LAB_SIRQ		; else go set-up IRQ
02065    
02066    LAB_NOIN
02067    D722  C9 AA        	CMP	#TK_NMI		; was it NMI token ?
02068    D724  D0 03        	BNE	LAB_NONM		; if not go do normal ON command
02069    
02070    D726  4C 41 EF     	JMP	LAB_SNMI		; else go set-up NMI
02071    
02072    LAB_NONM
02073    D729  20 80 E4     	JSR	LAB_GTBY		; get byte parameter
02074    D72C  48           	PHA				; push GOTO/GOSUB token
02075    D72D  C9 8D        	CMP	#TK_GOSUB		; compare with GOSUB token
02076    D72F  F0 04        	BEQ	LAB_176B		; branch if GOSUB
02077    
02078    D731  C9 89        	CMP	#TK_GOTO		; compare with GOTO token
02079    LAB_1767
02080    D733  D0 E3        	BNE	LAB_16FD		; if not GOTO do syntax error then warm start
02081    
02082    
02083    ; next character was GOTO or GOSUB
02084    
02085    LAB_176B
02086    D735  C6 AF        	DEC	FAC1_3		; decrement index (byte value)
02087    D737  D0 04        	BNE	LAB_1773		; branch if not zero
02088    
02089    D739  68           	PLA				; pull GOTO/GOSUB token
02090    D73A  4C F2 D4     	JMP	LAB_1602		; go execute it
02091    
02092    LAB_1773
02093    D73D  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory
02094    D740  20 49 D7     	JSR	LAB_GFPN		; get fixed-point number into temp integer (skip this n)
02095    					; (we could LDX #',' and JSR LAB_SNBL+2, then we
02096    					; just BNE LAB_176B for the loop. should be quicker ..
02097    					; no we can't, what if we meet a colon or [EOL]?)
02098    D743  C9 2C        	CMP	#$2C			; compare next character with ","
02099    D745  F0 EE        	BEQ	LAB_176B		; loop if ","
02100    
02101    LAB_177E
02102    D747  68           	PLA				; else pull keyword token (run out of options)
02103    					; also dump +/-1 pointer low byte and exit
02104    LAB_177F
02105    D748  60           	RTS
02106    
02107    ; takes n * 106 + 11 cycles where n is the number of digits
02108    
02109    ; get fixed-point number into temp integer
02110    
02111    LAB_GFPN
02112    D749  A2 00        	LDX	#$00			; clear reg
02113    D74B  86 11        	STX	Itempl		; clear temporary integer low byte
02114    LAB_1785
02115    D74D  86 12        	STX	Itemph		; save temporary integer high byte
02116    D74F  B0 F7        	BCS	LAB_177F		; return if carry set, end of scan, character was
02117    					; not 0-9
02118    
02119    D751  E0 19        	CPX	#$19			; compare high byte with $19
02120    D753  A8           	TAY				; ensure Zb = 0 if the branch is taken
02121    D754  B0 DD        	BCS	LAB_1767		; branch if >=, makes max line # 63999 because next
02122    					; bit does *$0A, = 64000, compare at target will fail
02123    					; and do syntax error
02124    
02125    D756  E9 2F        	SBC	#'0'-1		; subtract "0", $2F + carry, from byte
02126    D758  A8           	TAY				; copy binary digit
02127    D759  A5 11        	LDA	Itempl		; get temporary integer low byte
02128    D75B  0A           	ASL				; *2 low byte
02129    D75C  26 12        	ROL	Itemph		; *2 high byte
02130    D75E  0A           	ASL				; *2 low byte
02131    D75F  26 12        	ROL	Itemph		; *2 high byte, *4
02132    D761  65 11        	ADC	Itempl		; + low byte, *5
02133    D763  85 11        	STA	Itempl		; save it
02134    D765  8A           	TXA				; get high byte copy to A
02135    D766  65 12        	ADC	Itemph		; + high byte, *5
02136    D768  06 11        	ASL	Itempl		; *2 low byte, *10d
02137    D76A  2A           	ROL				; *2 high byte, *10d
02138    D76B  AA           	TAX				; copy high byte back to X
02139    D76C  98           	TYA				; get binary digit back
02140    D76D  65 11        	ADC	Itempl		; add number low byte
02141    D76F  85 11        	STA	Itempl		; save number low byte
02142    D771  90 01        	BCC	LAB_17B3		; if no overflow to high byte get next character
02143    
02144    D773  E8           	INX				; else increment high byte
02145    LAB_17B3
02146    D774  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory
02147    D777  4C 4D D7     	JMP	LAB_1785		; loop for next character
02148    
02149    ; perform DEC
02150    
02151    LAB_DEC
02152    D77A  A9 F1        	LDA	#<LAB_2AFD		; set -1 pointer low byte
02153    	.byte	$2C			; BIT abs to skip the LDA below
02154    
02155    ; perform INC
02156    
02157    LAB_INC
02158    D77D  A9 ED        	LDA	#<LAB_259C		; set 1 pointer low byte
02159    LAB_17B5
02160    D77F  48           	PHA				; save +/-1 pointer low byte
02161    LAB_17B7
02162    D780  20 9E DD     	JSR	LAB_GVAR		; get var address
02163    D783  A6 5F        	LDX	Dtypef		; get data type flag, $FF=string, $00=numeric
02164    D785  30 1E        	BMI	IncrErr		; exit if string
02165    
02166    D787  85 97        	STA	Lvarpl		; save var address low byte
02167    D789  84 98        	STY	Lvarph		; save var address high byte
02168    D78B  20 71 E8     	JSR	LAB_UFAC		; unpack memory (AY) into FAC1
02169    D78E  68           	PLA				; get +/-1 pointer low byte
02170    D78F  48           	PHA				; save +/-1 pointer low byte
02171    D790  A0 F1        	LDY	#>LAB_259C		; set +/-1 pointer high byte (both the same)
02172    D792  20 B2 E5     	JSR	LAB_246C		; add (AY) to FAC1
02173    D795  20 97 E8     	JSR	LAB_PFAC		; pack FAC1 into variable (Lvarpl)
02174    
02175    D798  20 C2 00     	JSR	LAB_GBYT		; scan memory
02176    D79B  C9 2C        	CMP	#','			; compare with ","
02177    D79D  D0 A8        	BNE	LAB_177E		; exit if not "," (either end or error)
02178    
02179    					; was "," so another INCR variable to do
02180    D79F  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory
02181    D7A2  4C 80 D7     	JMP	LAB_17B7		; go do next var
02182    
02183    IncrErr
02184    D7A5  4C D0 DA     	JMP	LAB_1ABC		; do "Type mismatch" error then warm start
02185    
02186    ; perform LET
02187    
02188    LAB_LET
02189    D7A8  20 9E DD     	JSR	LAB_GVAR		; get var address
02190    D7AB  85 97        	STA	Lvarpl		; save var address low byte
02191    D7AD  84 98        	STY	Lvarph		; save var address high byte
02192    D7AF  A9 C1        	LDA	#TK_EQUAL		; get = token
02193    D7B1  20 E5 DB     	JSR	LAB_SCCA		; scan for CHR$(A), else do syntax error then warm start
02194    D7B4  A5 5F        	LDA	Dtypef		; get data type flag, $FF=string, $00=numeric
02195    D7B6  48           	PHA				; push data type flag
02196    D7B7  20 D5 DA     	JSR	LAB_EVEX		; evaluate expression
02197    D7BA  68           	PLA				; pop data type flag
02198    D7BB  2A           	ROL				; set carry if type = string
02199    D7BC  20 C7 DA     	JSR	LAB_CKTM		; type match check, set C for string
02200    D7BF  D0 03        	BNE	LAB_17D5		; branch if string
02201    
02202    D7C1  4C 97 E8     	JMP	LAB_PFAC		; pack FAC1 into variable (Lvarpl) and return
02203    
02204    ; string LET
02205    
02206    LAB_17D5
02207    D7C4  A0 02        	LDY	#$02			; set index to pointer high byte
02208    D7C6  B1 AE        	LDA	(des_pl),Y		; get string pointer high byte
02209    D7C8  C5 82        	CMP	Sstorh		; compare bottom of string space high byte
02210    D7CA  90 17        	BCC	LAB_17F4		; if less assign value and exit (was in program memory)
02211    
02212    D7CC  D0 07        	BNE	LAB_17E6		; branch if >
02213    					; else was equal so compare low bytes
02214    D7CE  88           	DEY				; decrement index
02215    D7CF  B1 AE        	LDA	(des_pl),Y		; get pointer low byte
02216    D7D1  C5 81        	CMP	Sstorl		; compare bottom of string space low byte
02217    D7D3  90 0E        	BCC	LAB_17F4		; if less assign value and exit (was in program memory)
02218    
02219    					; pointer was >= to bottom of string space pointer
02220    LAB_17E6
02221    D7D5  A4 AF        	LDY	des_ph		; get descriptor pointer high byte
02222    D7D7  C4 7C        	CPY	Svarh			; compare start of vars high byte
02223    D7D9  90 08        	BCC	LAB_17F4		; branch if less (descriptor is on stack)
02224    
02225    D7DB  D0 0D        	BNE	LAB_17FB		; branch if greater (descriptor is not on stack)
02226    
02227    					; else high bytes were equal so ..
02228    D7DD  A5 AE        	LDA	des_pl		; get descriptor pointer low byte
02229    D7DF  C5 7B        	CMP	Svarl			; compare start of vars low byte
02230    D7E1  B0 07        	BCS	LAB_17FB		; branch if >= (descriptor is not on stack)
02231    
02232    LAB_17F4
02233    D7E3  A5 AE        	LDA	des_pl		; get descriptor pointer low byte
02234    D7E5  A4 AF        	LDY	des_ph		; get descriptor pointer high byte
02235    D7E7  4C 00 D8     	JMP	LAB_1811		; clean stack, copy descriptor to variable and return
02236    
02237    					; make space and copy string
02238    LAB_17FB
02239    D7EA  A0 00        	LDY	#$00			; index to length
02240    D7EC  B1 AE        	LDA	(des_pl),Y		; get string length
02241    D7EE  20 26 E1     	JSR	LAB_209C		; copy string
02242    D7F1  A5 9E        	LDA	des_2l		; get descriptor pointer low byte
02243    D7F3  A4 9F        	LDY	des_2h		; get descriptor pointer high byte
02244    D7F5  85 B8        	STA	ssptr_l		; save descriptor pointer low byte
02245    D7F7  84 B9        	STY	ssptr_h		; save descriptor pointer high byte
02246    D7F9  20 05 E3     	JSR	LAB_228A		; copy string from descriptor (sdescr) to (Sutill)
02247    D7FC  A9 AC        	LDA	#<FAC1_e		; set descriptor pointer low byte
02248    D7FE  A0 00        	LDY	#>FAC1_e		; get descriptor pointer high byte
02249    
02250    					; clean stack and assign value to string variable
02251    LAB_1811
02252    D800  85 9E        	STA	des_2l		; save descriptor_2 pointer low byte
02253    D802  84 9F        	STY	des_2h		; save descriptor_2 pointer high byte
02254    D804  20 67 E3     	JSR	LAB_22EB		; clean descriptor stack, YA = pointer
02255    D807  A0 00        	LDY	#$00			; index to length
02256    D809  B1 9E        	LDA	(des_2l),Y		; get string length
02257    D80B  91 97        	STA	(Lvarpl),Y		; copy to let string variable
02258    D80D  C8           	INY				; index to string pointer low byte
02259    D80E  B1 9E        	LDA	(des_2l),Y		; get string pointer low byte
02260    D810  91 97        	STA	(Lvarpl),Y		; copy to let string variable
02261    D812  C8           	INY				; index to string pointer high byte
02262    D813  B1 9E        	LDA	(des_2l),Y		; get string pointer high byte
02263    D815  91 97        	STA	(Lvarpl),Y		; copy to let string variable
02264    D817  60           	RTS
02265    
02266    ; perform GET
02267    
02268    LAB_GET
02269    D818  20 9E DD     	JSR	LAB_GVAR		; get var address
02270    D81B  85 97        	STA	Lvarpl		; save var address low byte
02271    D81D  84 98        	STY	Lvarph		; save var address high byte
02272    D81F  20 F6 EE     	JSR	INGET			; get input byte
02273    D822  A6 5F        	LDX	Dtypef		; get data type flag, $FF=string, $00=numeric
02274    D824  30 07        	BMI	LAB_GETS		; go get string character
02275    
02276    					; was numeric get
02277    D826  A8           	TAY				; copy character to Y
02278    D827  20 5A E0     	JSR	LAB_1FD0		; convert Y to byte in FAC1
02279    D82A  4C 97 E8     	JMP	LAB_PFAC		; pack FAC1 into variable (Lvarpl) and return
02280    
02281    LAB_GETS
02282    D82D  48           	PHA				; save character
02283    D82E  A9 01        	LDA	#$01			; string is single byte
02284    D830  B0 01        	BCS	LAB_IsByte		; branch if byte received
02285    
02286    D832  68           	PLA				; string is null
02287    LAB_IsByte
02288    D833  20 2E E1     	JSR	LAB_MSSP		; make string space A bytes long A=$AC=length,
02289    					; X=$AD=Sutill=ptr low byte, Y=$AE=Sutilh=ptr high byte
02290    D836  F0 05        	BEQ	LAB_NoSt		; skip store if null string
02291    
02292    D838  68           	PLA				; get character back
02293    D839  A0 00        	LDY	#$00			; clear index
02294    D83B  91 AD        	STA	(str_pl),Y		; save byte in string (byte IS string!)
02295    LAB_NoSt
02296    D83D  20 79 E1     	JSR	LAB_RTST		; check for space on descriptor stack then put address
02297    					; and length on descriptor stack and update stack pointers
02298    
02299    D840  4C C4 D7     	JMP	LAB_17D5		; do string LET and return
02300    
02301    ; perform PRINT
02302    
02303    LAB_1829
02304    D843  20 CA D8     	JSR	LAB_18C6		; print string from Sutill/Sutilh
02305    LAB_182C
02306    D846  20 C2 00     	JSR	LAB_GBYT		; scan memory
02307    
02308    ; PRINT
02309    
02310    LAB_PRINT
02311    D849  F0 3B        	BEQ	LAB_CRLF		; if nothing following just print CR/LF
02312    
02313    LAB_1831
02314    D84B  C9 AB        	CMP	#TK_TAB		; compare with TAB( token
02315    D84D  F0 56        	BEQ	LAB_18A2		; go do TAB/SPC
02316    
02317    D84F  C9 AF        	CMP	#TK_SPC		; compare with SPC( token
02318    D851  F0 52        	BEQ	LAB_18A2		; go do TAB/SPC
02319    
02320    D853  C9 2C        	CMP	#','			; compare with ","
02321    D855  F0 38        	BEQ	LAB_188B		; go do move to next TAB mark
02322    
02323    D857  C9 3B        	CMP	#';'			; compare with ";"
02324    D859  F0 66        	BEQ	LAB_18BD		; if ";" continue with PRINT processing
02325    
02326    D85B  20 D5 DA     	JSR	LAB_EVEX		; evaluate expression
02327    D85E  24 5F        	BIT	Dtypef		; test data type flag, $FF=string, $00=numeric
02328    D860  30 E1        	BMI	LAB_1829		; branch if string
02329    
02330    D862  20 89 EA     	JSR	LAB_296E		; convert FAC1 to string
02331    D865  20 38 E1     	JSR	LAB_20AE		; print " terminated string to Sutill/Sutilh
02332    D868  A0 00        	LDY	#$00			; clear index
02333    
02334    ; don't check fit if terminal width byte is zero
02335    
02336    D86A  A5 0F        	LDA	TWidth		; get terminal width byte
02337    D86C  F0 0A        	BEQ	LAB_185E		; skip check if zero
02338    
02339    D86E  38           	SEC				; set carry for subtract
02340    D86F  E5 0E        	SBC	TPos			; subtract terminal position
02341    D871  F1 AE        	SBC	(des_pl),Y		; subtract string length
02342    D873  B0 03        	BCS	LAB_185E		; branch if less than terminal width
02343    
02344    D875  20 86 D8     	JSR	LAB_CRLF		; else print CR/LF
02345    LAB_185E
02346    D878  20 CA D8     	JSR	LAB_18C6		; print string from Sutill/Sutilh
02347    D87B  F0 C9        	BEQ	LAB_182C		; always go continue processing line
02348    
02349    ; CR/LF return to BASIC from BASIC input handler
02350    
02351    LAB_1866
02352    D87D  A9 00        	LDA	#$00			; clear byte
02353    D87F  9D 11 02     	STA	Ibuffs,X		; null terminate input
02354    D882  A2 11        	LDX	#<Ibuffs		; set X to buffer start-1 low byte
02355    D884  A0 02        	LDY	#>Ibuffs		; set Y to buffer start-1 high byte
02356    
02357    ; print CR/LF
02358    
02359    LAB_CRLF
02360    D886  A9 0D        	LDA	#$0D			; load [CR]
02361    D888  20 E1 D8     	JSR	LAB_PRNA		; go print the character
02362    D88B  A9 0A        	LDA	#$0A			; load [LF]
02363    D88D  D0 52        	BNE	LAB_PRNA		; go print the character and return, branch always
02364    
02365    LAB_188B
02366    D88F  A5 0E        	LDA	TPos			; get terminal position
02367    D891  C5 10        	CMP	Iclim			; compare with input column limit
02368    D893  90 05        	BCC	LAB_1897		; branch if less
02369    
02370    D895  20 86 D8     	JSR	LAB_CRLF		; else print CR/LF (next line)
02371    D898  D0 27        	BNE	LAB_18BD		; continue with PRINT processing (branch always)
02372    
02373    LAB_1897
02374    D89A  38           	SEC				; set carry for subtract
02375    LAB_1898
02376    D89B  E5 64        	SBC	TabSiz		; subtract TAB size
02377    D89D  B0 FC        	BCS	LAB_1898		; loop if result was +ve
02378    
02379    D89F  49 FF        	EOR	#$FF			; complement it
02380    D8A1  69 01        	ADC	#$01			; +1 (twos complement)
02381    D8A3  D0 12        	BNE	LAB_18B6		; always print A spaces (result is never $00)
02382    
02383    					; do TAB/SPC
02384    LAB_18A2
02385    D8A5  48           	PHA				; save token
02386    D8A6  20 7D E4     	JSR	LAB_SGBY		; scan and get byte parameter
02387    D8A9  C9 29        	CMP	#$29			; is next character )
02388    D8AB  D0 7B        	BNE	LAB_1910		; if not do syntax error then warm start
02389    
02390    D8AD  68           	PLA				; get token back
02391    D8AE  C9 AB        	CMP	#TK_TAB		; was it TAB ?
02392    D8B0  D0 06        	BNE	LAB_18B7		; if not go do SPC
02393    
02394    					; calculate TAB offset
02395    D8B2  8A           	TXA				; copy integer value to A
02396    D8B3  E5 0E        	SBC	TPos			; subtract terminal position
02397    D8B5  90 0A        	BCC	LAB_18BD		; branch if result was < 0 (can't TAB backwards)
02398    
02399    					; print A spaces
02400    LAB_18B6
02401    D8B7  AA           	TAX				; copy result to X
02402    LAB_18B7
02403    D8B8  8A           	TXA				; set flags on size for SPC
02404    D8B9  F0 06        	BEQ	LAB_18BD		; branch if result was = $0, already here
02405    
02406    					; print X spaces
02407    LAB_18BA
02408    D8BB  20 DC D8     	JSR	LAB_18E0		; print " "
02409    D8BE  CA           	DEX				; decrement count
02410    D8BF  D0 FA        	BNE	LAB_18BA		; loop if not all done
02411    
02412    					; continue with PRINT processing
02413    LAB_18BD
02414    D8C1  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory
02415    D8C4  D0 85        	BNE	LAB_1831		; if more to print go do it
02416    
02417    D8C6  60           	RTS
02418    
02419    ; print null terminated string from memory
02420    
02421    LAB_18C3
02422    D8C7  20 38 E1     	JSR	LAB_20AE		; print " terminated string to Sutill/Sutilh
02423    
02424    ; print string from Sutill/Sutilh
02425    
02426    LAB_18C6
02427    D8CA  20 32 E3     	JSR	LAB_22B6		; pop string off descriptor stack, or from top of string
02428    					; space returns with A = length, X=$71=pointer low byte,
02429    					; Y=$72=pointer high byte
02430    D8CD  A0 00        	LDY	#$00			; reset index
02431    D8CF  AA           	TAX				; copy length to X
02432    D8D0  F0 49        	BEQ	LAB_188C		; exit (RTS) if null string
02433    
02434    LAB_18CD
02435    
02436    D8D2  B1 71        	LDA	(ut1_pl),Y		; get next byte
02437    D8D4  20 E1 D8     	JSR	LAB_PRNA		; go print the character
02438    D8D7  C8           	INY				; increment index
02439    D8D8  CA           	DEX				; decrement count
02440    D8D9  D0 F7        	BNE	LAB_18CD		; loop if not done yet
02441    
02442    D8DB  60           	RTS
02443    
02444    					; Print single format character
02445    ; print " "
02446    
02447    LAB_18E0
02448    D8DC  A9 20        	LDA	#$20			; load " "
02449    	.byte	$2C			; change next line to BIT LAB_3FA9
02450    
02451    ; print "?" character
02452    
02453    LAB_18E3
02454    D8DF  A9 3F        	LDA	#$3F			; load "?" character
02455    
02456    ; print character in A
02457    ; now includes the null handler
02458    ; also includes infinite line length code
02459    ; note! some routines expect this one to exit with Zb=0
02460    
02461    LAB_PRNA
02462    D8E1  C9 20        	CMP	#' '			; compare with " "
02463    D8E3  90 19        	BCC	LAB_18F9		; branch if less (non printing)
02464    
02465    					; else printable character
02466    D8E5  48           	PHA				; save the character
02467    
02468    ; don't check fit if terminal width byte is zero
02469    
02470    D8E6  A5 0F        	LDA	TWidth		; get terminal width
02471    D8E8  D0 0A        	BNE	LAB_18F0		; branch if not zero (not infinite length)
02472    
02473    ; is "infinite line" so check TAB position
02474    
02475    D8EA  A5 0E        	LDA	TPos			; get position
02476    D8EC  E5 64        	SBC	TabSiz		; subtract TAB size, carry set by CMP #$20 above
02477    D8EE  D0 0B        	BNE	LAB_18F7		; skip reset if different
02478    
02479    D8F0  85 0E        	STA	TPos			; else reset position
02480    D8F2  F0 07        	BEQ	LAB_18F7		; go print character
02481    
02482    LAB_18F0
02483    D8F4  C5 0E        	CMP	TPos			; compare with terminal character position
02484    D8F6  D0 03        	BNE	LAB_18F7		; branch if not at end of line
02485    
02486    D8F8  20 86 D8     	JSR	LAB_CRLF		; else print CR/LF
02487    LAB_18F7
02488    D8FB  E6 0E        	INC	TPos			; increment terminal position
02489    D8FD  68           	PLA				; get character back
02490    LAB_18F9
02491    D8FE  20 FA F0     	JSR	V_OUTP		; output byte via output vector
02492    D901  C9 0D        	CMP	#$0D			; compare with [CR]
02493    D903  D0 14        	BNE	LAB_188A		; branch if not [CR]
02494    
02495    					; else print nullct nulls after the [CR]
02496    D905  86 78        	STX	TempB			; save buffer index
02497    D907  A6 0D        	LDX	Nullct		; get null count
02498    D909  F0 0A        	BEQ	LAB_1886		; branch if no nulls
02499    
02500    D90B  A9 00        	LDA	#$00			; load [NULL]
02501    LAB_1880
02502    D90D  20 E1 D8     	JSR	LAB_PRNA		; go print the character
02503    D910  CA           	DEX				; decrement count
02504    D911  D0 FA        	BNE	LAB_1880		; loop if not all done
02505    
02506    D913  A9 0D        	LDA	#$0D			; restore the character (and set the flags)
02507    LAB_1886
02508    D915  86 0E        	STX	TPos			; clear terminal position (X always = zero when we get here)
02509    D917  A6 78        	LDX	TempB			; restore buffer index
02510    LAB_188A
02511    D919  29 FF        	AND	#$FF			; set the flags
02512    LAB_188C
02513    D91B  60           	RTS
02514    
02515    ; handle bad input data
02516    
02517    LAB_1904
02518    D91C  A5 62        	LDA	Imode			; get input mode flag, $00=INPUT, $00=READ
02519    D91E  10 0B        	BPL	LAB_1913		; branch if INPUT (go do redo)
02520    
02521    D920  A5 8D        	LDA	Dlinel		; get current DATA line low byte
02522    D922  A4 8E        	LDY	Dlineh		; get current DATA line high byte
02523    D924  85 87        	STA	Clinel		; save current line low byte
02524    D926  84 88        	STY	Clineh		; save current line high byte
02525    LAB_1910
02526    D928  4C F6 DB     	JMP	LAB_SNER		; do syntax error then warm start
02527    
02528    					; mode was INPUT
02529    LAB_1913
02530    D92B  A9 1F        	LDA	#<LAB_REDO		; point to redo message (low addr)
02531    D92D  A0 F8        	LDY	#>LAB_REDO		; point to redo message (high addr)
02532    D92F  20 C7 D8     	JSR	LAB_18C3		; print null terminated string from memory
02533    D932  A5 8B        	LDA	Cpntrl		; get continue pointer low byte
02534    D934  A4 8C        	LDY	Cpntrh		; get continue pointer high byte
02535    D936  85 C3        	STA	Bpntrl		; save BASIC execute pointer low byte
02536    D938  84 C4        	STY	Bpntrh		; save BASIC execute pointer high byte
02537    D93A  60           	RTS
02538    
02539    ; perform INPUT
02540    
02541    LAB_INPUT
02542    D93B  C9 22        	CMP	#$22			; compare next byte with open quote
02543    D93D  D0 0B        	BNE	LAB_1934		; branch if no prompt string
02544    
02545    D93F  20 B2 DB     	JSR	LAB_1BC1		; print "..." string
02546    D942  A9 3B        	LDA	#$3B			; load A with ";"
02547    D944  20 E5 DB     	JSR	LAB_SCCA		; scan for CHR$(A), else do syntax error then warm start
02548    D947  20 CA D8     	JSR	LAB_18C6		; print string from Sutill/Sutilh
02549    
02550    					; done with prompt, now get data
02551    LAB_1934
02552    D94A  20 5E E0     	JSR	LAB_CKRN		; check not Direct, back here if ok
02553    D94D  20 33 D2     	JSR	LAB_INLN		; print "? " and get BASIC input
02554    D950  A9 00        	LDA	#$00			; set mode = INPUT
02555    D952  CD 11 02     	CMP	Ibuffs		; test first byte in buffer
02556    D955  D0 0A        	BNE	LAB_1953		; branch if not null input
02557    
02558    D957  18           	CLC				; was null input so clear carry to exit program
02559    D958  4C 20 D5     	JMP	LAB_1647		; go do BREAK exit
02560    
02561    ; perform READ
02562    
02563    LAB_READ
02564    D95B  A6 8F        	LDX	Dptrl			; get DATA pointer low byte
02565    D95D  A4 90        	LDY	Dptrh			; get DATA pointer high byte
02566    D95F  A9 80        	LDA	#$80			; set mode = READ
02567    
02568    LAB_1953
02569    D961  85 62        	STA	Imode			; set input mode flag, $00=INPUT, $80=READ
02570    D963  86 91        	STX	Rdptrl		; save READ pointer low byte
02571    D965  84 92        	STY	Rdptrh		; save READ pointer high byte
02572    
02573    					; READ or INPUT next variable from list
02574    LAB_195B
02575    D967  20 9E DD     	JSR	LAB_GVAR		; get (var) address
02576    D96A  85 97        	STA	Lvarpl		; save address low byte
02577    D96C  84 98        	STY	Lvarph		; save address high byte
02578    D96E  A5 C3        	LDA	Bpntrl		; get BASIC execute pointer low byte
02579    D970  A4 C4        	LDY	Bpntrh		; get BASIC execute pointer high byte
02580    D972  85 11        	STA	Itempl		; save as temporary integer low byte
02581    D974  84 12        	STY	Itemph		; save as temporary integer high byte
02582    D976  A6 91        	LDX	Rdptrl		; get READ pointer low byte
02583    D978  A4 92        	LDY	Rdptrh		; get READ pointer high byte
02584    D97A  86 C3        	STX	Bpntrl		; set BASIC execute pointer low byte
02585    D97C  84 C4        	STY	Bpntrh		; set BASIC execute pointer high byte
02586    D97E  20 C2 00     	JSR	LAB_GBYT		; scan memory
02587    D981  D0 11        	BNE	LAB_1988		; branch if not null
02588    
02589    					; pointer was to null entry
02590    D983  24 62        	BIT	Imode			; test input mode flag, $00=INPUT, $80=READ
02591    D985  30 65        	BMI	LAB_19DD		; branch if READ
02592    
02593    					; mode was INPUT
02594    D987  20 DF D8     	JSR	LAB_18E3		; print "?" character (double ? for extended input)
02595    D98A  20 33 D2     	JSR	LAB_INLN		; print "? " and get BASIC input
02596    D98D  86 C3        	STX	Bpntrl		; set BASIC execute pointer low byte
02597    D98F  84 C4        	STY	Bpntrh		; set BASIC execute pointer high byte
02598    LAB_1985
02599    D991  20 C2 00     	JSR	LAB_GBYT		; scan memory
02600    LAB_1988
02601    D994  24 5F        	BIT	Dtypef		; test data type flag, $FF=string, $00=numeric
02602    D996  10 24        	BPL	LAB_19B0		; branch if numeric
02603    
02604    					; else get string
02605    D998  85 5B        	STA	Srchc			; save search character
02606    D99A  C9 22        	CMP	#$22			; was it " ?
02607    D99C  F0 07        	BEQ	LAB_1999		; branch if so
02608    
02609    D99E  A9 3A        	LDA	#':'			; else search character is ":"
02610    D9A0  85 5B        	STA	Srchc			; set new search character
02611    D9A2  A9 2C        	LDA	#','			; other search character is ","
02612    D9A4  18           	CLC				; clear carry for add
02613    LAB_1999
02614    D9A5  85 5C        	STA	Asrch			; set second search character
02615    D9A7  A5 C3        	LDA	Bpntrl		; get BASIC execute pointer low byte
02616    D9A9  A4 C4        	LDY	Bpntrh		; get BASIC execute pointer high byte
02617    
02618    D9AB  69 00        	ADC	#$00			; c is =1 if we came via the BEQ LAB_1999, else =0
02619    D9AD  90 01        	BCC	LAB_19A4		; branch if no execute pointer low byte rollover
02620    
02621    D9AF  C8           	INY				; else increment high byte
02622    LAB_19A4
02623    D9B0  20 3E E1     	JSR	LAB_20B4		; print Srchc or Asrch terminated string to Sutill/Sutilh
02624    D9B3  20 C3 E4     	JSR	LAB_23F3		; restore BASIC execute pointer from temp (Btmpl/Btmph)
02625    D9B6  20 C4 D7     	JSR	LAB_17D5		; go do string LET
02626    D9B9  4C C2 D9     	JMP	LAB_19B6		; go check string terminator
02627    
02628    					; get numeric INPUT
02629    LAB_19B0
02630    D9BC  20 9A E9     	JSR	LAB_2887		; get FAC1 from string
02631    D9BF  20 97 E8     	JSR	LAB_PFAC		; pack FAC1 into (Lvarpl)
02632    LAB_19B6
02633    D9C2  20 C2 00     	JSR	LAB_GBYT		; scan memory
02634    D9C5  F0 0A        	BEQ	LAB_19C5		; branch if null (last entry)
02635    
02636    D9C7  C9 2C        	CMP	#','			; else compare with ","
02637    D9C9  F0 03        	BEQ	LAB_19C2		; branch if ","
02638    
02639    D9CB  4C 1C D9     	JMP	LAB_1904		; else go handle bad input data
02640    
02641    					; got good input data
02642    LAB_19C2
02643    D9CE  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory
02644    LAB_19C5
02645    D9D1  A5 C3        	LDA	Bpntrl		; get BASIC execute pointer low byte (temp READ/INPUT ptr)
02646    D9D3  A4 C4        	LDY	Bpntrh		; get BASIC execute pointer high byte (temp READ/INPUT ptr)
02647    D9D5  85 91        	STA	Rdptrl		; save for now
02648    D9D7  84 92        	STY	Rdptrh		; save for now
02649    D9D9  A5 11        	LDA	Itempl		; get temporary integer low byte (temp BASIC execute ptr)
02650    D9DB  A4 12        	LDY	Itemph		; get temporary integer high byte (temp BASIC execute ptr)
02651    D9DD  85 C3        	STA	Bpntrl		; set BASIC execute pointer low byte
02652    D9DF  84 C4        	STY	Bpntrh		; set BASIC execute pointer high byte
02653    D9E1  20 C2 00     	JSR	LAB_GBYT		; scan memory
02654    D9E4  F0 2C        	BEQ	LAB_1A03		; if null go do extra ignored message
02655    
02656    D9E6  20 F2 DB     	JSR	LAB_1C01		; else scan for "," , else do syntax error then warm start
02657    D9E9  4C 67 D9     	JMP	LAB_195B		; go INPUT next variable from list
02658    
02659    					; find next DATA statement or do "Out of DATA" error
02660    LAB_19DD
02661    D9EC  20 91 D6     	JSR	LAB_SNBS		; scan for next BASIC statement ([:] or [EOL])
02662    D9EF  C8           	INY				; increment index
02663    D9F0  AA           	TAX				; copy character ([:] or [EOL])
02664    D9F1  D0 12        	BNE	LAB_19F6		; branch if [:]
02665    
02666    D9F3  A2 06        	LDX	#$06			; set for "Out of DATA" error
02667    D9F5  C8           	INY				; increment index, now points to next line pointer high byte
02668    D9F6  B1 C3        	LDA	(Bpntrl),Y		; get next line pointer high byte
02669    D9F8  F0 73        	BEQ	LAB_1A54		; branch if end (eventually does error X)
02670    
02671    D9FA  C8           	INY				; increment index
02672    D9FB  B1 C3        	LDA	(Bpntrl),Y		; get next line # low byte
02673    D9FD  85 8D        	STA	Dlinel		; save current DATA line low byte
02674    D9FF  C8           	INY				; increment index
02675    DA00  B1 C3        	LDA	(Bpntrl),Y		; get next line # high byte
02676    DA02  C8           	INY				; increment index
02677    DA03  85 8E        	STA	Dlineh		; save current DATA line high byte
02678    LAB_19F6
02679    DA05  B1 C3        	LDA	(Bpntrl),Y		; get byte
02680    DA07  C8           	INY				; increment index
02681    DA08  AA           	TAX				; copy to X
02682    DA09  20 83 D6     	JSR	LAB_170F		; set BASIC execute pointer
02683    DA0C  E0 83        	CPX	#TK_DATA		; compare with "DATA" token
02684    DA0E  F0 81        	BEQ	LAB_1985		; was "DATA" so go do next READ
02685    
02686    DA10  D0 DA        	BNE	LAB_19DD		; go find next statement if not "DATA"
02687    
02688    ; end of INPUT/READ routine
02689    
02690    LAB_1A03
02691    DA12  A5 91        	LDA	Rdptrl		; get temp READ pointer low byte
02692    DA14  A4 92        	LDY	Rdptrh		; get temp READ pointer high byte
02693    DA16  A6 62        	LDX	Imode			; get input mode flag, $00=INPUT, $80=READ
02694    DA18  10 03        	BPL	LAB_1A0E		; branch if INPUT
02695    
02696    DA1A  4C 42 D5     	JMP	LAB_1624		; save AY as DATA pointer and return
02697    
02698    					; we were getting INPUT
02699    LAB_1A0E
02700    DA1D  A0 00        	LDY	#$00			; clear index
02701    DA1F  B1 91        	LDA	(Rdptrl),Y		; get next byte
02702    DA21  D0 01        	BNE	LAB_1A1B		; error if not end of INPUT
02703    
02704    DA23  60           	RTS
02705    
02706    					; user typed too much
02707    LAB_1A1B
02708    DA24  A9 0E        	LDA	#<LAB_IMSG		; point to extra ignored message (low addr)
02709    DA26  A0 F8        	LDY	#>LAB_IMSG		; point to extra ignored message (high addr)
02710    DA28  4C C7 D8     	JMP	LAB_18C3		; print null terminated string from memory and return
02711    
02712    ; search the stack for FOR activity
02713    ; exit with z=1 if FOR else exit with z=0
02714    
02715    LAB_11A1
02716    DA2B  BA           	TSX				; copy stack pointer
02717    DA2C  E8           	INX				; +1 pass return address
02718    DA2D  E8           	INX				; +2 pass return address
02719    DA2E  E8           	INX				; +3 pass calling routine return address
02720    DA2F  E8           	INX				; +4 pass calling routine return address
02721    LAB_11A6
02722    DA30  BD 01 01     	LDA	LAB_STAK+1,X	; get token byte from stack
02723    DA33  C9 81        	CMP	#TK_FOR		; is it FOR token
02724    DA35  D0 21        	BNE	LAB_11CE		; exit if not FOR token
02725    
02726    					; was FOR token
02727    DA37  A5 98        	LDA	Frnxth		; get var pointer for FOR/NEXT high byte
02728    DA39  D0 0A        	BNE	LAB_11BB		; branch if not null
02729    
02730    DA3B  BD 02 01     	LDA	LAB_STAK+2,X	; get FOR variable pointer low byte
02731    DA3E  85 97        	STA	Frnxtl		; save var pointer for FOR/NEXT low byte
02732    DA40  BD 03 01     	LDA	LAB_STAK+3,X	; get FOR variable pointer high byte
02733    DA43  85 98        	STA	Frnxth		; save var pointer for FOR/NEXT high byte
02734    LAB_11BB
02735    DA45  DD 03 01     	CMP	LAB_STAK+3,X	; compare var pointer with stacked var pointer (high byte)
02736    DA48  D0 07        	BNE	LAB_11C7		; branch if no match
02737    
02738    DA4A  A5 97        	LDA	Frnxtl		; get var pointer for FOR/NEXT low byte
02739    DA4C  DD 02 01     	CMP	LAB_STAK+2,X	; compare var pointer with stacked var pointer (low byte)
02740    DA4F  F0 07        	BEQ	LAB_11CE		; exit if match found
02741    
02742    LAB_11C7
02743    DA51  8A           	TXA				; copy index
02744    DA52  18           	CLC				; clear carry for add
02745    DA53  69 10        	ADC	#$10			; add FOR stack use size
02746    DA55  AA           	TAX				; copy back to index
02747    DA56  D0 D8        	BNE	LAB_11A6		; loop if not at start of stack
02748    
02749    LAB_11CE
02750    DA58  60           	RTS
02751    
02752    ; perform NEXT
02753    
02754    LAB_NEXT
02755    DA59  D0 04        	BNE	LAB_1A46		; branch if NEXT var
02756    
02757    DA5B  A0 00        	LDY	#$00			; else clear Y
02758    DA5D  F0 03        	BEQ	LAB_1A49		; branch always (no variable to search for)
02759    
02760    ; NEXT var
02761    
02762    LAB_1A46
02763    DA5F  20 9E DD     	JSR	LAB_GVAR		; get variable address
02764    LAB_1A49
02765    DA62  85 97        	STA	Frnxtl		; store variable pointer low byte
02766    DA64  84 98        	STY	Frnxth		; store variable pointer high byte
02767    					; (both cleared if no variable defined)
02768    DA66  20 2B DA     	JSR	LAB_11A1		; search the stack for FOR activity
02769    DA69  F0 04        	BEQ	LAB_1A56		; branch if found
02770    
02771    DA6B  A2 00        	LDX	#$00			; else set error $00 ("NEXT without FOR" error)
02772    LAB_1A54
02773    DA6D  F0 63        	BEQ	LAB_1ABE		; do error #X, then warm start
02774    
02775    LAB_1A56
02776    DA6F  9A           	TXS				; set stack pointer, X set by search, dumps return addresses
02777    
02778    DA70  8A           	TXA				; copy stack pointer
02779    DA71  38           	SEC				; set carry for subtract
02780    DA72  E9 F7        	SBC	#$F7			; point to TO var
02781    DA74  85 73        	STA	ut2_pl		; save pointer to TO var for compare
02782    DA76  69 FB        	ADC	#$FB			; point to STEP var
02783    
02784    DA78  A0 01        	LDY	#>LAB_STAK		; point to stack page high byte
02785    DA7A  20 71 E8     	JSR	LAB_UFAC		; unpack memory (STEP value) into FAC1
02786    DA7D  BA           	TSX				; get stack pointer back
02787    DA7E  BD 08 01     	LDA	LAB_STAK+8,X	; get step sign
02788    DA81  85 B0        	STA	FAC1_s		; save FAC1 sign (b7)
02789    DA83  A5 97        	LDA	Frnxtl		; get FOR variable pointer low byte
02790    DA85  A4 98        	LDY	Frnxth		; get FOR variable pointer high byte
02791    DA87  20 B2 E5     	JSR	LAB_246C		; add (FOR variable) to FAC1
02792    DA8A  20 97 E8     	JSR	LAB_PFAC		; pack FAC1 into (FOR variable)
02793    DA8D  A0 01        	LDY	#>LAB_STAK		; point to stack page high byte
02794    DA8F  20 0D E9     	JSR	LAB_27FA		; compare FAC1 with (Y,ut2_pl) (TO value)
02795    DA92  BA           	TSX				; get stack pointer back
02796    DA93  DD 08 01     	CMP	LAB_STAK+8,X	; compare step sign
02797    DA96  F0 17        	BEQ	LAB_1A9B		; branch if = (loop complete)
02798    
02799    					; loop back and do it all again
02800    DA98  BD 0D 01     	LDA	LAB_STAK+$0D,X	; get FOR line low byte
02801    DA9B  85 87        	STA	Clinel		; save current line low byte
02802    DA9D  BD 0E 01     	LDA	LAB_STAK+$0E,X	; get FOR line high byte
02803    DAA0  85 88        	STA	Clineh		; save current line high byte
02804    DAA2  BD 10 01     	LDA	LAB_STAK+$10,X	; get BASIC execute pointer low byte
02805    DAA5  85 C3        	STA	Bpntrl		; save BASIC execute pointer low byte
02806    DAA7  BD 0F 01     	LDA	LAB_STAK+$0F,X	; get BASIC execute pointer high byte
02807    DAAA  85 C4        	STA	Bpntrh		; save BASIC execute pointer high byte
02808    LAB_1A98
02809    DAAC  4C B0 D4     	JMP	LAB_15C2		; go do interpreter inner loop
02810    
02811    					; loop complete so carry on
02812    LAB_1A9B
02813    DAAF  8A           	TXA				; stack copy to A
02814    DAB0  69 0F        	ADC	#$0F			; add $10 ($0F+carry) to dump FOR structure
02815    DAB2  AA           	TAX				; copy back to index
02816    DAB3  9A           	TXS				; copy to stack pointer
02817    DAB4  20 C2 00     	JSR	LAB_GBYT		; scan memory
02818    DAB7  C9 2C        	CMP	#','			; compare with ","
02819    DAB9  D0 F1        	BNE	LAB_1A98		; branch if not "," (go do interpreter inner loop)
02820    
02821    					; was "," so another NEXT variable to do
02822    DABB  20 BC 00     	JSR	LAB_IGBY		; else increment and scan memory
02823    DABE  20 5F DA     	JSR	LAB_1A46		; do NEXT (var)
02824    
02825    ; evaluate expression and check is numeric, else do type mismatch
02826    
02827    LAB_EVNM
02828    DAC1  20 D5 DA     	JSR	LAB_EVEX		; evaluate expression
02829    
02830    ; check if source is numeric, else do type mismatch
02831    
02832    LAB_CTNM
02833    DAC4  18           	CLC				; destination is numeric
02834    	.byte	$24			; makes next line BIT $38
02835    
02836    ; check if source is string, else do type mismatch
02837    
02838    LAB_CTST
02839    DAC6  38           	SEC				; required type is string
02840    
02841    ; type match check, set C for string, clear C for numeric
02842    
02843    LAB_CKTM
02844    DAC7  24 5F        	BIT	Dtypef		; test data type flag, $FF=string, $00=numeric
02845    DAC9  30 03        	BMI	LAB_1ABA		; branch if data type is string
02846    
02847    					; else data type was numeric
02848    DACB  B0 03        	BCS	LAB_1ABC		; if required type is string do type mismatch error
02849    LAB_1AB9
02850    DACD  60           	RTS
02851    
02852    					; data type was string, now check required type
02853    LAB_1ABA
02854    DACE  B0 FD        	BCS	LAB_1AB9		; exit if required type is string
02855    
02856    					; else do type mismatch error
02857    LAB_1ABC
02858    DAD0  A2 18        	LDX	#$18			; error code $18 ("Type mismatch" error)
02859    LAB_1ABE
02860    DAD2  4C 2E D1     	JMP	LAB_XERR		; do error #X, then warm start
02861    
02862    ; evaluate expression
02863    
02864    LAB_EVEX
02865    DAD5  A6 C3        	LDX	Bpntrl		; get BASIC execute pointer low byte
02866    DAD7  D0 02        	BNE	LAB_1AC7		; skip next if not zero
02867    
02868    DAD9  C6 C4        	DEC	Bpntrh		; else decrement BASIC execute pointer high byte
02869    LAB_1AC7
02870    DADB  C6 C3        	DEC	Bpntrl		; decrement BASIC execute pointer low byte
02871    
02872    LAB_EVEZ
02873    DADD  A9 00        	LDA	#$00			; set null precedence (flag done)
02874    LAB_1ACC
02875    DADF  48           	PHA				; push precedence byte
02876    DAE0  A9 02        	LDA	#$02			; 2 bytes
02877    DAE2  20 F5 D0     	JSR	LAB_1212		; check room on stack for A bytes
02878    DAE5  20 C1 DB     	JSR	LAB_GVAL		; get value from line
02879    DAE8  A9 00        	LDA	#$00			; clear A
02880    DAEA  85 9B        	STA	comp_f		; clear compare function flag
02881    LAB_1ADB
02882    DAEC  20 C2 00     	JSR	LAB_GBYT		; scan memory
02883    LAB_1ADE
02884    DAEF  38           	SEC				; set carry for subtract
02885    DAF0  E9 C0        	SBC	#TK_GT		; subtract token for > (lowest comparison function)
02886    DAF2  90 17        	BCC	LAB_1AFA		; branch if < TK_GT
02887    
02888    DAF4  C9 03        	CMP	#$03			; compare with ">" to "<" tokens
02889    DAF6  B0 13        	BCS	LAB_1AFA		; branch if >= TK_SGN (highest evaluation function +1)
02890    
02891    					; was token for > = or < (A = 0, 1 or 2)
02892    DAF8  C9 01        	CMP	#$01			; compare with token for =
02893    DAFA  2A           	ROL				; *2, b0 = carry (=1 if token was = or <)
02894    					; (A = 0, 3 or 5)
02895    DAFB  49 01        	EOR	#$01			; toggle b0
02896    					; (A = 1, 2 or 4. 1 if >, 2 if =, 4 if <)
02897    DAFD  45 9B        	EOR	comp_f		; EOR with compare function flag bits
02898    DAFF  C5 9B        	CMP	comp_f		; compare with compare function flag
02899    DB01  90 67        	BCC	LAB_1B53		; if <(comp_f) do syntax error then warm start
02900    					; was more than one <, = or >)
02901    
02902    DB03  85 9B        	STA	comp_f		; save new compare function flag
02903    DB05  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory
02904    DB08  4C EF DA     	JMP	LAB_1ADE		; go do next character
02905    
02906    					; token is < ">" or > "<" tokens
02907    LAB_1AFA
02908    DB0B  A6 9B        	LDX	comp_f		; get compare function flag
02909    DB0D  D0 2C        	BNE	LAB_1B2A		; branch if compare function
02910    
02911    DB0F  B0 79        	BCS	LAB_1B78		; go do functions
02912    
02913    					; else was <  TK_GT so is operator or lower
02914    DB11  69 0A        	ADC	#TK_GT-TK_PLUS	; add # of operators (+, -, *, /, ^, AND, OR or EOR)
02915    DB13  90 75        	BCC	LAB_1B78		; branch if < + operator
02916    
02917    					; carry was set so token was +, -, *, /, ^, AND, OR or EOR
02918    DB15  D0 07        	BNE	LAB_1B0B		; branch if not + token
02919    
02920    DB17  24 5F        	BIT	Dtypef		; test data type flag, $FF=string, $00=numeric
02921    DB19  10 03        	BPL	LAB_1B0B		; branch if not string
02922    
02923    					; will only be $00 if type is string and token was +
02924    DB1B  4C C8 E2     	JMP	LAB_224D		; add strings, string 1 is in descriptor des_pl, string 2
02925    					; is in line, and return
02926    
02927    LAB_1B0B
02928    DB1E  85 71        	STA	ut1_pl		; save it
02929    DB20  0A           	ASL				; *2
02930    DB21  65 71        	ADC	ut1_pl		; *3
02931    DB23  A8           	TAY				; copy to index
02932    LAB_1B13
02933    DB24  68           	PLA				; pull previous precedence
02934    DB25  D9 F6 F2     	CMP	LAB_OPPT,Y		; compare with precedence byte
02935    DB28  B0 65        	BCS	LAB_1B7D		; branch if A >=
02936    
02937    DB2A  20 C4 DA     	JSR	LAB_CTNM		; check if source is numeric, else do type mismatch
02938    LAB_1B1C
02939    DB2D  48           	PHA				; save precedence
02940    LAB_1B1D
02941    DB2E  20 56 DB     	JSR	LAB_1B43		; get vector, execute function then continue evaluation
02942    DB31  68           	PLA				; restore precedence
02943    DB32  A4 99        	LDY	prstk			; get precedence stacked flag
02944    DB34  10 19        	BPL	LAB_1B3C		; branch if stacked values
02945    
02946    DB36  AA           	TAX				; copy precedence (set flags)
02947    DB37  F0 76        	BEQ	LAB_1B9D		; exit if done
02948    
02949    DB39  D0 5D        	BNE	LAB_1B86		; else pop FAC2 and return, branch always
02950    
02951    LAB_1B2A
02952    DB3B  26 5F        	ROL	Dtypef		; shift data type flag into Cb
02953    DB3D  8A           	TXA				; copy compare function flag
02954    DB3E  85 5F        	STA	Dtypef		; clear data type flag, X is 0xxx xxxx
02955    DB40  2A           	ROL				; shift data type into compare function byte b0
02956    DB41  A6 C3        	LDX	Bpntrl		; get BASIC execute pointer low byte
02957    DB43  D0 02        	BNE	LAB_1B34		; branch if no underflow
02958    
02959    DB45  C6 C4        	DEC	Bpntrh		; else decrement BASIC execute pointer high byte
02960    LAB_1B34
02961    DB47  C6 C3        	DEC	Bpntrl		; decrement BASIC execute pointer low byte
02962      000C             TK_LT_PLUS	= TK_LT-TK_PLUS
02963    DB49  A0 24        	LDY	#TK_LT_PLUS*3	; set offset to last operator entry
02964    DB4B  85 9B        	STA	comp_f		; save new compare function flag
02965    DB4D  D0 D5        	BNE	LAB_1B13		; branch always
02966    
02967    LAB_1B3C
02968    DB4F  D9 F6 F2     	CMP	LAB_OPPT,Y		;.compare with stacked function precedence
02969    DB52  B0 44        	BCS	LAB_1B86		; branch if A >=, pop FAC2 and return
02970    
02971    DB54  90 D7        	BCC	LAB_1B1C		; branch always
02972    
02973    ;.get vector, execute function then continue evaluation
02974    
02975    LAB_1B43
02976    DB56  B9 F8 F2     	LDA	LAB_OPPT+2,Y	; get function vector high byte
02977    DB59  48           	PHA				; onto stack
02978    DB5A  B9 F7 F2     	LDA	LAB_OPPT+1,Y	; get function vector low byte
02979    DB5D  48           	PHA				; onto stack
02980    					; now push sign, round FAC1 and put on stack
02981    DB5E  20 6D DB     	JSR	LAB_1B5B		; function will return here, then the next RTS will call
02982    					; the function
02983    DB61  A5 9B        	LDA	comp_f		; get compare function flag
02984    DB63  48           	PHA				; push compare evaluation byte
02985    DB64  B9 F6 F2     	LDA	LAB_OPPT,Y		; get precedence byte
02986    DB67  4C DF DA     	JMP	LAB_1ACC		; continue evaluating expression
02987    
02988    LAB_1B53
02989    DB6A  4C F6 DB     	JMP	LAB_SNER		; do syntax error then warm start
02990    
02991    ; push sign, round FAC1 and put on stack
02992    
02993    LAB_1B5B
02994    DB6D  68           	PLA				; get return addr low byte
02995    DB6E  85 71        	STA	ut1_pl		; save it
02996    DB70  E6 71        	INC	ut1_pl		; increment it (was ret-1 pushed? yes!)
02997    					; note! no check is made on the high byte! if the calling
02998    					; routine assembles to a page edge then this all goes
02999    					; horribly wrong !!!
03000    DB72  68           	PLA				; get return addr high byte
03001    DB73  85 72        	STA	ut1_ph		; save it
03002    DB75  A5 B0        	LDA	FAC1_s		; get FAC1 sign (b7)
03003    DB77  48           	PHA				; push sign
03004    
03005    ; round FAC1 and put on stack
03006    
03007    LAB_1B66
03008    DB78  20 CD E8     	JSR	LAB_27BA		; round FAC1
03009    DB7B  A5 AF        	LDA	FAC1_3		; get FAC1 mantissa3
03010    DB7D  48           	PHA				; push on stack
03011    DB7E  A5 AE        	LDA	FAC1_2		; get FAC1 mantissa2
03012    DB80  48           	PHA				; push on stack
03013    DB81  A5 AD        	LDA	FAC1_1		; get FAC1 mantissa1
03014    DB83  48           	PHA				; push on stack
03015    DB84  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
03016    DB86  48           	PHA				; push on stack
03017    DB87  6C 71 00     	JMP	(ut1_pl)		; return, sort of
03018    
03019    ; do functions
03020    
03021    LAB_1B78
03022    DB8A  A0 FF        	LDY	#$FF			; flag function
03023    DB8C  68           	PLA				; pull precedence byte
03024    LAB_1B7B
03025    DB8D  F0 20        	BEQ	LAB_1B9D		; exit if done
03026    
03027    LAB_1B7D
03028    DB8F  C9 64        	CMP	#$64			; compare previous precedence with $64
03029    DB91  F0 03        	BEQ	LAB_1B84		; branch if was $64 (< function)
03030    
03031    DB93  20 C4 DA     	JSR	LAB_CTNM		; check if source is numeric, else do type mismatch
03032    LAB_1B84
03033    DB96  84 99        	STY	prstk			; save precedence stacked flag
03034    
03035    					; pop FAC2 and return
03036    LAB_1B86
03037    DB98  68           	PLA				; pop byte
03038    DB99  4A           	LSR				; shift out comparison evaluation lowest bit
03039    DB9A  85 63        	STA	Cflag			; save comparison evaluation flag
03040    DB9C  68           	PLA				; pop exponent
03041    DB9D  85 B3        	STA	FAC2_e		; save FAC2 exponent
03042    DB9F  68           	PLA				; pop mantissa1
03043    DBA0  85 B4        	STA	FAC2_1		; save FAC2 mantissa1
03044    DBA2  68           	PLA				; pop mantissa2
03045    DBA3  85 B5        	STA	FAC2_2		; save FAC2 mantissa2
03046    DBA5  68           	PLA				; pop mantissa3
03047    DBA6  85 B6        	STA	FAC2_3		; save FAC2 mantissa3
03048    DBA8  68           	PLA				; pop sign
03049    DBA9  85 B7        	STA	FAC2_s		; save FAC2 sign (b7)
03050    DBAB  45 B0        	EOR	FAC1_s		; EOR FAC1 sign (b7)
03051    DBAD  85 B8        	STA	FAC_sc		; save sign compare (FAC1 EOR FAC2)
03052    LAB_1B9D
03053    DBAF  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
03054    DBB1  60           	RTS
03055    
03056    ; print "..." string to string util area
03057    
03058    LAB_1BC1
03059    DBB2  A5 C3        	LDA	Bpntrl		; get BASIC execute pointer low byte
03060    DBB4  A4 C4        	LDY	Bpntrh		; get BASIC execute pointer high byte
03061    DBB6  69 00        	ADC	#$00			; add carry to low byte
03062    DBB8  90 01        	BCC	LAB_1BCA		; branch if no overflow
03063    
03064    DBBA  C8           	INY				; increment high byte
03065    LAB_1BCA
03066    DBBB  20 38 E1     	JSR	LAB_20AE		; print " terminated string to Sutill/Sutilh
03067    DBBE  4C C3 E4     	JMP	LAB_23F3		; restore BASIC execute pointer from temp and return
03068    
03069    ; get value from line
03070    
03071    LAB_GVAL
03072    DBC1  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory
03073    DBC4  B0 03        	BCS	LAB_1BAC		; branch if not numeric character
03074    
03075    					; else numeric string found (e.g. 123)
03076    LAB_1BA9
03077    DBC6  4C 9A E9     	JMP	LAB_2887		; get FAC1 from string and return
03078    
03079    ; get value from line .. continued
03080    
03081    					; wasn't a number so ..
03082    LAB_1BAC
03083    DBC9  AA           	TAX				; set the flags
03084    DBCA  30 2F        	BMI	LAB_1BD0		; if -ve go test token values
03085    
03086    					; else it is either a string, number, variable or (<expr>)
03087    DBCC  C9 24        	CMP	#'$'			; compare with "$"
03088    DBCE  F0 F6        	BEQ	LAB_1BA9		; branch if "$", hex number
03089    
03090    DBD0  C9 25        	CMP	#'%'			; else compare with "%"
03091    DBD2  F0 F2        	BEQ	LAB_1BA9		; branch if "%", binary number
03092    
03093    DBD4  C9 2E        	CMP	#'.'			; compare with "."
03094    DBD6  F0 EE        	BEQ	LAB_1BA9		; if so get FAC1 from string and return (e.g. was .123)
03095    
03096    					; it wasn't any sort of number so ..
03097    DBD8  C9 22        	CMP	#$22			; compare with "
03098    DBDA  F0 D6        	BEQ	LAB_1BC1		; branch if open quote
03099    
03100    					; wasn't any sort of number so ..
03101    
03102    ; evaluate expression within parentheses
03103    
03104    DBDC  C9 28        	CMP	#'('			; compare with "("
03105    DBDE  D0 4F        	BNE	LAB_1C18		; if not "(" get (var), return value in FAC1 and $ flag
03106    
03107    LAB_1BF7
03108    DBE0  20 DD DA     	JSR	LAB_EVEZ		; evaluate expression, no decrement
03109    
03110    ; all the 'scan for' routines return the character after the sought character
03111    
03112    ; scan for ")" , else do syntax error then warm start
03113    
03114    LAB_1BFB
03115    DBE3  A9 29        	LDA	#$29			; load A with ")"
03116    
03117    ; scan for CHR$(A) , else do syntax error then warm start
03118    
03119    LAB_SCCA
03120    DBE5  A0 00        	LDY	#$00			; clear index
03121    DBE7  D1 C3        	CMP	(Bpntrl),Y		; check next byte is = A
03122    DBE9  D0 0B        	BNE	LAB_SNER		; if not do syntax error then warm start
03123    
03124    DBEB  4C BC 00     	JMP	LAB_IGBY		; increment and scan memory then return
03125    
03126    ; scan for "(" , else do syntax error then warm start
03127    
03128    LAB_1BFE
03129    DBEE  A9 28        	LDA	#$28			; load A with "("
03130    DBF0  D0 F3        	BNE	LAB_SCCA		; scan for CHR$(A), else do syntax error then warm start
03131    					; (branch always)
03132    
03133    ; scan for "," , else do syntax error then warm start
03134    
03135    LAB_1C01
03136    DBF2  A9 2C        	LDA	#$2C			; load A with ","
03137    DBF4  D0 EF        	BNE	LAB_SCCA		; scan for CHR$(A), else do syntax error then warm start
03138    					; (branch always)
03139    
03140    ; syntax error then warm start
03141    
03142    LAB_SNER
03143    DBF6  A2 02        	LDX	#$02			; error code $02 ("Syntax" error)
03144    DBF8  4C 2E D1     	JMP	LAB_XERR		; do error #X, then warm start
03145    
03146    ; get value from line .. continued
03147    ; do tokens
03148    
03149    LAB_1BD0
03150    DBFB  C9 B7        	CMP	#TK_MINUS		; compare with token for -
03151    DBFD  F0 29        	BEQ	LAB_1C11		; branch if - token (do set-up for functions)
03152    
03153    					; wasn't -n so ..
03154    DBFF  C9 B6        	CMP	#TK_PLUS		; compare with token for +
03155    DC01  F0 BE        	BEQ	LAB_GVAL		; branch if + token (+n = n so ignore leading +)
03156    
03157    DC03  C9 B1        	CMP	#TK_NOT		; compare with token for NOT
03158    DC05  D0 13        	BNE	LAB_1BE7		; branch if not token for NOT
03159    
03160    					; was NOT token
03161      000B             TK_EQUAL_PLUS	= TK_EQUAL-TK_PLUS
03162    DC07  A0 21        	LDY	#TK_EQUAL_PLUS*3	; offset to NOT function
03163    DC09  D0 1F        	BNE	LAB_1C13		; do set-up for function then execute (branch always)
03164    
03165    ; do = compare
03166    
03167    LAB_EQUAL
03168    DC0B  20 9A DE     	JSR	LAB_EVIR		; evaluate integer expression (no sign check)
03169    DC0E  A5 AF        	LDA	FAC1_3		; get FAC1 mantissa3
03170    DC10  49 FF        	EOR	#$FF			; invert it
03171    DC12  A8           	TAY				; copy it
03172    DC13  A5 AE        	LDA	FAC1_2		; get FAC1 mantissa2
03173    DC15  49 FF        	EOR	#$FF			; invert it
03174    DC17  4C 4D E0     	JMP	LAB_AYFC		; save and convert integer AY to FAC1 and return
03175    
03176    ; get value from line .. continued
03177    
03178    					; wasn't +, -, or NOT so ..
03179    LAB_1BE7
03180    DC1A  C9 AE        	CMP	#TK_FN		; compare with token for FN
03181    DC1C  D0 03        	BNE	LAB_1BEE		; branch if not token for FN
03182    
03183    DC1E  4C A8 E0     	JMP	LAB_201E		; go evaluate FNx
03184    
03185    ; get value from line .. continued
03186    
03187    					; wasn't +, -, NOT or FN so ..
03188    LAB_1BEE
03189    DC21  E9 C3        	SBC	#TK_SGN		; subtract with token for SGN
03190    DC23  B0 19        	BCS	LAB_1C27		; if a function token go do it
03191    
03192    DC25  4C F6 DB     	JMP	LAB_SNER		; else do syntax error
03193    
03194    ; set-up for functions
03195    
03196    LAB_1C11
03197      000A             TK_GT_PLUS	= TK_GT-TK_PLUS
03198    DC28  A0 1E        	LDY	#TK_GT_PLUS*3	; set offset from base to > operator
03199    LAB_1C13
03200    DC2A  68           	PLA				; dump return address low byte
03201    DC2B  68           	PLA				; dump return address high byte
03202    DC2C  4C 2E DB     	JMP	LAB_1B1D		; execute function then continue evaluation
03203    
03204    ; variable name set-up
03205    ; get (var), return value in FAC_1 and $ flag
03206    
03207    LAB_1C18
03208    DC2F  20 9E DD     	JSR	LAB_GVAR		; get (var) address
03209    DC32  85 AE        	STA	FAC1_2		; save address low byte in FAC1 mantissa2
03210    DC34  84 AF        	STY	FAC1_3		; save address high byte in FAC1 mantissa3
03211    DC36  A6 5F        	LDX	Dtypef		; get data type flag, $FF=string, $00=numeric
03212    DC38  30 03        	BMI	LAB_1C25		; if string then return (does RTS)
03213    
03214    LAB_1C24
03215    DC3A  4C 71 E8     	JMP	LAB_UFAC		; unpack memory (AY) into FAC1
03216    
03217    LAB_1C25
03218    DC3D  60           	RTS
03219    
03220    ; get value from line .. continued
03221    ; only functions left so ..
03222    
03223    ; set up function references
03224    
03225    ; new for V2.0+ this replaces a lot of IF .. THEN .. ELSEIF .. THEN .. that was needed
03226    ; to process function calls. now the function vector is computed and pushed on the stack
03227    ; and the preprocess offset is read. if the preprocess offset is non zero then the vector
03228    ; is calculated and the routine called, if not this routine just does RTS. whichever
03229    ; happens the RTS at the end of this routine, or the end of the preprocess routine, calls
03230    ; the function code
03231    
03232    ; this also removes some less than elegant code that was used to bypass type checking
03233    ; for functions that returned strings
03234    
03235    LAB_1C27
03236    DC3E  0A           	ASL				; *2 (2 bytes per function address)
03237    DC3F  A8           	TAY				; copy to index
03238    
03239    DC40  B9 B1 F2     	LDA	LAB_FTBM,Y		; get function jump vector high byte
03240    DC43  48           	PHA				; push functions jump vector high byte
03241    DC44  B9 B0 F2     	LDA	LAB_FTBL,Y		; get function jump vector low byte
03242    DC47  48           	PHA				; push functions jump vector low byte
03243    
03244    DC48  B9 6B F2     	LDA	LAB_FTPM,Y		; get function pre process vector high byte
03245    DC4B  F0 05        	BEQ	LAB_1C56		; skip pre process if null vector
03246    
03247    DC4D  48           	PHA				; push functions pre process vector high byte
03248    DC4E  B9 6A F2     	LDA	LAB_FTPL,Y		; get function pre process vector low byte
03249    DC51  48           	PHA				; push functions pre process vector low byte
03250    
03251    LAB_1C56
03252    DC52  60           	RTS				; do function, or pre process, call
03253    
03254    ; process string expression in parenthesis
03255    
03256    LAB_PPFS
03257    DC53  20 E0 DB     	JSR	LAB_1BF7		; process expression in parenthesis
03258    DC56  4C C6 DA     	JMP	LAB_CTST		; check if source is string then do function,
03259    					; else do type mismatch
03260    
03261    ; process numeric expression in parenthesis
03262    
03263    LAB_PPFN
03264    DC59  20 E0 DB     	JSR	LAB_1BF7		; process expression in parenthesis
03265    DC5C  4C C4 DA     	JMP	LAB_CTNM		; check if source is numeric then do function,
03266    					; else do type mismatch
03267    
03268    ; set numeric data type and increment BASIC execute pointer
03269    
03270    LAB_PPBI
03271    DC5F  46 5F        	LSR	Dtypef		; clear data type flag, $FF=string, $00=numeric
03272    DC61  4C BC 00     	JMP	LAB_IGBY		; increment and scan memory then do function
03273    
03274    ; process string for LEFT$, RIGHT$ or MID$
03275    
03276    LAB_LRMS
03277    DC64  20 DD DA     	JSR	LAB_EVEZ		; evaluate (should be string) expression
03278    DC67  20 F2 DB     	JSR	LAB_1C01		; scan for ",", else do syntax error then warm start
03279    DC6A  20 C6 DA     	JSR	LAB_CTST		; check if source is string, else do type mismatch
03280    
03281    DC6D  68           	PLA				; get function jump vector low byte
03282    DC6E  AA           	TAX				; save functions jump vector low byte
03283    DC6F  68           	PLA				; get function jump vector high byte
03284    DC70  A8           	TAY				; save functions jump vector high byte
03285    DC71  A5 AF        	LDA	des_ph		; get descriptor pointer high byte
03286    DC73  48           	PHA				; push string pointer high byte
03287    DC74  A5 AE        	LDA	des_pl		; get descriptor pointer low byte
03288    DC76  48           	PHA				; push string pointer low byte
03289    DC77  98           	TYA				; get function jump vector high byte back
03290    DC78  48           	PHA				; save functions jump vector high byte
03291    DC79  8A           	TXA				; get function jump vector low byte back
03292    DC7A  48           	PHA				; save functions jump vector low byte
03293    DC7B  20 80 E4     	JSR	LAB_GTBY		; get byte parameter
03294    DC7E  8A           	TXA				; copy byte parameter to A
03295    DC7F  60           	RTS				; go do function
03296    
03297    ; process numeric expression(s) for BIN$ or HEX$
03298    
03299    LAB_BHSS
03300    DC80  20 DD DA     	JSR	LAB_EVEZ		; process expression
03301    DC83  20 C4 DA     	JSR	LAB_CTNM		; check if source is numeric, else do type mismatch
03302    DC86  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
03303    DC88  C9 98        	CMP	#$98			; compare with exponent = 2^24
03304    DC8A  B0 20        	BCS	LAB_BHER		; branch if n>=2^24 (is too big)
03305    
03306    DC8C  20 44 E9     	JSR	LAB_2831		; convert FAC1 floating-to-fixed
03307    DC8F  A2 02        	LDX	#$02			; 3 bytes to do
03308    LAB_CFAC
03309    DC91  B5 AD        	LDA	FAC1_1,X		; get byte from FAC1
03310    DC93  95 11        	STA	nums_1,X		; save byte to temp
03311    DC95  CA           	DEX				; decrement index
03312    DC96  10 F9        	BPL	LAB_CFAC		; copy FAC1 mantissa to temp
03313    
03314    DC98  20 C2 00     	JSR	LAB_GBYT		; get next BASIC byte
03315    DC9B  A2 00        	LDX	#$00			; set default to no leading "0"s
03316    DC9D  C9 29        	CMP	#')'			; compare with close bracket
03317    DC9F  F0 0A        	BEQ	LAB_1C54		; if ")" go do rest of function
03318    
03319    DCA1  20 D2 E4     	JSR	LAB_SCGB		; scan for "," and get byte
03320    DCA4  20 C2 00     	JSR	LAB_GBYT		; get last byte back
03321    DCA7  C9 29        	CMP	#')'			; is next character )
03322    DCA9  D0 01        	BNE	LAB_BHER		; if not ")" go do error
03323    
03324    LAB_1C54
03325    DCAB  60           	RTS				; else do function
03326    
03327    LAB_BHER
03328    DCAC  4C 1D DF     	JMP	LAB_FCER		; do function call error then warm start
03329    
03330    ; perform EOR
03331    
03332    ; added operator format is the same as AND or OR, precedence is the same as OR
03333    
03334    ; this bit worked first time but it took a while to sort out the operator table
03335    ; pointers and offsets afterwards!
03336    
03337    LAB_EOR
03338    DCAF  20 D6 DC     	JSR	GetFirst		; get first integer expression (no sign check)
03339    DCB2  45 5B        	EOR	XOAw_l		; EOR with expression 1 low byte
03340    DCB4  A8           	TAY				; save in Y
03341    DCB5  A5 AE        	LDA	FAC1_2		; get FAC1 mantissa2
03342    DCB7  45 5C        	EOR	XOAw_h		; EOR with expression 1 high byte
03343    DCB9  4C 4D E0     	JMP	LAB_AYFC		; save and convert integer AY to FAC1 and return
03344    
03345    ; perform OR
03346    
03347    LAB_OR
03348    DCBC  20 D6 DC     	JSR	GetFirst		; get first integer expression (no sign check)
03349    DCBF  05 5B        	ORA	XOAw_l		; OR with expression 1 low byte
03350    DCC1  A8           	TAY				; save in Y
03351    DCC2  A5 AE        	LDA	FAC1_2		; get FAC1 mantissa2
03352    DCC4  05 5C        	ORA	XOAw_h		; OR with expression 1 high byte
03353    DCC6  4C 4D E0     	JMP	LAB_AYFC		; save and convert integer AY to FAC1 and return
03354    
03355    ; perform AND
03356    
03357    LAB_AND
03358    DCC9  20 D6 DC     	JSR	GetFirst		; get first integer expression (no sign check)
03359    DCCC  25 5B        	AND	XOAw_l		; AND with expression 1 low byte
03360    DCCE  A8           	TAY				; save in Y
03361    DCCF  A5 AE        	LDA	FAC1_2		; get FAC1 mantissa2
03362    DCD1  25 5C        	AND	XOAw_h		; AND with expression 1 high byte
03363    DCD3  4C 4D E0     	JMP	LAB_AYFC		; save and convert integer AY to FAC1 and return
03364    
03365    ; get first value for OR, AND or EOR
03366    
03367    GetFirst
03368    DCD6  20 9A DE     	JSR	LAB_EVIR		; evaluate integer expression (no sign check)
03369    DCD9  A5 AE        	LDA	FAC1_2		; get FAC1 mantissa2
03370    DCDB  85 5C        	STA	XOAw_h		; save it
03371    DCDD  A5 AF        	LDA	FAC1_3		; get FAC1 mantissa3
03372    DCDF  85 5B        	STA	XOAw_l		; save it
03373    DCE1  20 B7 E5     	JSR	LAB_279B		; copy FAC2 to FAC1 (get 2nd value in expression)
03374    DCE4  20 9A DE     	JSR	LAB_EVIR		; evaluate integer expression (no sign check)
03375    DCE7  A5 AF        	LDA	FAC1_3		; get FAC1 mantissa3
03376    LAB_1C95
03377    DCE9  60           	RTS
03378    
03379    ; perform comparisons
03380    
03381    ; do < compare
03382    
03383    LAB_LTHAN
03384    DCEA  20 C7 DA     	JSR	LAB_CKTM		; type match check, set C for string
03385    DCED  B0 13        	BCS	LAB_1CAE		; branch if string
03386    
03387    					; do numeric < compare
03388    DCEF  A5 B7        	LDA	FAC2_s		; get FAC2 sign (b7)
03389    DCF1  09 7F        	ORA	#$7F			; set all non sign bits
03390    DCF3  25 B4        	AND	FAC2_1		; and FAC2 mantissa1 (AND in sign bit)
03391    DCF5  85 B4        	STA	FAC2_1		; save FAC2 mantissa1
03392    DCF7  A9 B3        	LDA	#<FAC2_e		; set pointer low byte to FAC2
03393    DCF9  A0 00        	LDY	#>FAC2_e		; set pointer high byte to FAC2
03394    DCFB  20 0B E9     	JSR	LAB_27F8		; compare FAC1 with FAC2 (AY)
03395    DCFE  AA           	TAX				; copy result
03396    DCFF  4C 33 DD     	JMP	LAB_1CE1		; go evaluate result
03397    
03398    					; do string < compare
03399    LAB_1CAE
03400    DD02  46 5F        	LSR	Dtypef		; clear data type flag, $FF=string, $00=numeric
03401    DD04  C6 9B        	DEC	comp_f		; clear < bit in compare function flag
03402    DD06  20 32 E3     	JSR	LAB_22B6		; pop string off descriptor stack, or from top of string
03403    					; space returns with A = length, X=pointer low byte,
03404    					; Y=pointer high byte
03405    DD09  85 AC        	STA	str_ln		; save length
03406    DD0B  86 AD        	STX	str_pl		; save string pointer low byte
03407    DD0D  84 AE        	STY	str_ph		; save string pointer high byte
03408    DD0F  A5 B5        	LDA	FAC2_2		; get descriptor pointer low byte
03409    DD11  A4 B6        	LDY	FAC2_3		; get descriptor pointer high byte
03410    DD13  20 36 E3     	JSR	LAB_22BA		; pop (YA) descriptor off stack or from top of string space
03411    					; returns with A = length, X=pointer low byte,
03412    					; Y=pointer high byte
03413    DD16  86 B5        	STX	FAC2_2		; save string pointer low byte
03414    DD18  84 B6        	STY	FAC2_3		; save string pointer high byte
03415    DD1A  AA           	TAX				; copy length
03416    DD1B  38           	SEC				; set carry for subtract
03417    DD1C  E5 AC        	SBC	str_ln		; subtract string 1 length
03418    DD1E  F0 08        	BEQ	LAB_1CD6		; branch if str 1 length = string 2 length
03419    
03420    DD20  A9 01        	LDA	#$01			; set str 1 length > string 2 length
03421    DD22  90 04        	BCC	LAB_1CD6		; branch if so
03422    
03423    DD24  A6 AC        	LDX	str_ln		; get string 1 length
03424    DD26  A9 FF        	LDA	#$FF			; set str 1 length < string 2 length
03425    LAB_1CD6
03426    DD28  85 B0        	STA	FAC1_s		; save length compare
03427    DD2A  A0 FF        	LDY	#$FF			; set index
03428    DD2C  E8           	INX				; adjust for loop
03429    LAB_1CDB
03430    DD2D  C8           	INY				; increment index
03431    DD2E  CA           	DEX				; decrement count
03432    DD2F  D0 07        	BNE	LAB_1CE6		; branch if still bytes to do
03433    
03434    DD31  A6 B0        	LDX	FAC1_s		; get length compare back
03435    LAB_1CE1
03436    DD33  30 0F        	BMI	LAB_1CF2		; branch if str 1 < str 2
03437    
03438    DD35  18           	CLC				; flag str 1 <= str 2
03439    DD36  90 0C        	BCC	LAB_1CF2		; go evaluate result
03440    
03441    LAB_1CE6
03442    DD38  B1 B5        	LDA	(FAC2_2),Y		; get string 2 byte
03443    DD3A  D1 AD        	CMP	(FAC1_1),Y		; compare with string 1 byte
03444    DD3C  F0 EF        	BEQ	LAB_1CDB		; loop if bytes =
03445    
03446    DD3E  A2 FF        	LDX	#$FF			; set str 1 < string 2
03447    DD40  B0 02        	BCS	LAB_1CF2		; branch if so
03448    
03449    DD42  A2 01        	LDX	#$01			;  set str 1 > string 2
03450    LAB_1CF2
03451    DD44  E8           	INX				; x = 0, 1 or 2
03452    DD45  8A           	TXA				; copy to A
03453    DD46  2A           	ROL				; *2 (1, 2 or 4)
03454    DD47  25 63        	AND	Cflag			; AND with comparison evaluation flag
03455    DD49  F0 02        	BEQ	LAB_1CFB		; branch if 0 (compare is false)
03456    
03457    DD4B  A9 FF        	LDA	#$FF			; else set result true
03458    LAB_1CFB
03459    DD4D  4C EE E8     	JMP	LAB_27DB		; save A as integer byte and return
03460    
03461    LAB_1CFE
03462    DD50  20 F2 DB     	JSR	LAB_1C01		; scan for ",", else do syntax error then warm start
03463    
03464    ; perform DIM
03465    
03466    LAB_DIM
03467    DD53  AA           	TAX				; copy "DIM" flag to X
03468    DD54  20 A3 DD     	JSR	LAB_1D10		; search for variable
03469    DD57  20 C2 00     	JSR	LAB_GBYT		; scan memory
03470    DD5A  D0 F4        	BNE	LAB_1CFE		; scan for "," and loop if not null
03471    
03472    DD5C  60           	RTS
03473    
03474    ; perform << (left shift)
03475    
03476    LAB_LSHIFT
03477    DD5D  20 93 DD     	JSR	GetPair		; get integer expression and byte (no sign check)
03478    DD60  A5 AE        	LDA	FAC1_2		; get expression high byte
03479    DD62  A6 78        	LDX	TempB			; get shift count
03480    DD64  F0 22        	BEQ	NoShift		; branch if zero
03481    
03482    DD66  E0 10        	CPX	#$10			; compare bit count with 16d
03483    DD68  B0 23        	BCS	TooBig		; branch if >=
03484    
03485    Ls_loop
03486    DD6A  06 AF        	ASL	FAC1_3		; shift low byte
03487    DD6C  2A           	ROL				; shift high byte
03488    DD6D  CA           	DEX				; decrement bit count
03489    DD6E  D0 FA        	BNE	Ls_loop		; loop if shift not complete
03490    
03491    DD70  A4 AF        	LDY	FAC1_3		; get expression low byte
03492    DD72  4C 4D E0     	JMP	LAB_AYFC		; save and convert integer AY to FAC1 and return
03493    
03494    ; perform >> (right shift)
03495    
03496    LAB_RSHIFT
03497    DD75  20 93 DD     	JSR	GetPair		; get integer expression and byte (no sign check)
03498    DD78  A5 AE        	LDA	FAC1_2		; get expression high byte
03499    DD7A  A6 78        	LDX	TempB			; get shift count
03500    DD7C  F0 0A        	BEQ	NoShift		; branch if zero
03501    
03502    DD7E  E0 10        	CPX	#$10			; compare bit count with 16d
03503    DD80  B0 0B        	BCS	TooBig		; branch if >=
03504    
03505    Rs_loop
03506    DD82  4A           	LSR				; shift high byte
03507    DD83  66 AF        	ROR	FAC1_3		; shift low byte
03508    DD85  CA           	DEX				; decrement bit count
03509    DD86  D0 FA        	BNE	Rs_loop		; loop if shift not complete
03510    
03511    NoShift
03512    DD88  A4 AF        	LDY	FAC1_3		; get expression low byte
03513    DD8A  4C 4D E0     	JMP	LAB_AYFC		; save and convert integer AY to FAC1 and return
03514    
03515    TooBig
03516    DD8D  A9 00        	LDA	#$00			; clear high byte
03517    DD8F  A8           	TAY				; copy to low byte
03518    DD90  4C 4D E0     	JMP	LAB_AYFC		; save and convert integer AY to FAC1 and return
03519    
03520    GetPair
03521    DD93  20 83 E4     	JSR	LAB_EVBY		; evaluate byte expression, result in X
03522    DD96  86 78        	STX	TempB			; save it
03523    DD98  20 B7 E5     	JSR	LAB_279B		; copy FAC2 to FAC1 (get 2nd value in expression)
03524    DD9B  4C 9A DE     	JMP	LAB_EVIR		; evaluate integer expression (no sign check)
03525    
03526    ; search for variable
03527    
03528    ; return pointer to variable in Cvaral/Cvarah
03529    
03530    LAB_GVAR
03531    DD9E  A2 00        	LDX	#$00			; set DIM flag = $00
03532    DDA0  20 C2 00     	JSR	LAB_GBYT		; scan memory (1st character)
03533    LAB_1D10
03534    DDA3  86 5E        	STX	Defdim		; save DIM flag
03535    LAB_1D12
03536    DDA5  85 93        	STA	Varnm1		; save 1st character
03537    DDA7  29 7F        	AND	#$7F			; clear FN flag bit
03538    DDA9  20 12 DE     	JSR	LAB_CASC		; check byte, return C=0 if<"A" or >"Z"
03539    DDAC  B0 03        	BCS	LAB_1D1F		; branch if ok
03540    
03541    DDAE  4C F6 DB     	JMP	LAB_SNER		; else syntax error then warm start
03542    
03543    					; was variable name so ..
03544    LAB_1D1F
03545    DDB1  A2 00        	LDX	#$00			; clear 2nd character temp
03546    DDB3  86 5F        	STX	Dtypef		; clear data type flag, $FF=string, $00=numeric
03547    DDB5  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory (2nd character)
03548    DDB8  90 05        	BCC	LAB_1D2D		; branch if character = "0"-"9" (ok)
03549    
03550    					; 2nd character wasn't "0" to "9" so ..
03551    DDBA  20 12 DE     	JSR	LAB_CASC		; check byte, return C=0 if<"A" or >"Z"
03552    DDBD  90 0B        	BCC	LAB_1D38		; branch if <"A" or >"Z" (go check if string)
03553    
03554    LAB_1D2D
03555    DDBF  AA           	TAX				; copy 2nd character
03556    
03557    					; ignore further (valid) characters in the variable name
03558    LAB_1D2E
03559    DDC0  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory (3rd character)
03560    DDC3  90 FB        	BCC	LAB_1D2E		; loop if character = "0"-"9" (ignore)
03561    
03562    DDC5  20 12 DE     	JSR	LAB_CASC		; check byte, return C=0 if<"A" or >"Z"
03563    DDC8  B0 F6        	BCS	LAB_1D2E		; loop if character = "A"-"Z" (ignore)
03564    
03565    					; check if string variable
03566    LAB_1D38
03567    DDCA  C9 24        	CMP	#'$'			; compare with "$"
03568    DDCC  D0 0B        	BNE	LAB_1D47		; branch if not string
03569    
03570    ; to introduce a new variable type (% suffix for integers say) then this branch
03571    ; will need to go to that check and then that branch, if it fails, go to LAB_1D47
03572    
03573    					; type is string
03574    DDCE  A9 FF        	LDA	#$FF			; set data type = string
03575    DDD0  85 5F        	STA	Dtypef		; set data type flag, $FF=string, $00=numeric
03576    DDD2  8A           	TXA				; get 2nd character back
03577    DDD3  09 80        	ORA	#$80			; set top bit (indicate string var)
03578    DDD5  AA           	TAX				; copy back to 2nd character temp
03579    DDD6  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory
03580    
03581    ; after we have determined the variable type we need to come back here to determine
03582    ; if it's an array of type. this would plug in a%(b[,c[,d]])) integer arrays nicely
03583    
03584    
03585    LAB_1D47				; gets here with character after var name in A
03586    DDD9  86 94        	STX	Varnm2		; save 2nd character
03587    DDDB  05 61        	ORA	Sufnxf		; or with subscript/FNX flag (or FN name)
03588    DDDD  C9 28        	CMP	#'('			; compare with "("
03589    DDDF  D0 03        	BNE	LAB_1D53		; branch if not "("
03590    
03591    DDE1  4C AC DE     	JMP	LAB_1E17		; go find, or make, array
03592    
03593    ; either find or create var
03594    ; var name (1st two characters only!) is in Varnm1,Varnm2
03595    
03596    					; variable name wasn't var(... so look for plain var
03597    LAB_1D53
03598    DDE4  A9 00        	LDA	#$00			; clear A
03599    DDE6  85 61        	STA	Sufnxf		; clear subscript/FNX flag
03600    DDE8  A5 7B        	LDA	Svarl			; get start of vars low byte
03601    DDEA  A6 7C        	LDX	Svarh			; get start of vars high byte
03602    DDEC  A0 00        	LDY	#$00			; clear index
03603    LAB_1D5D
03604    DDEE  86 AB        	STX	Vrschh		; save search address high byte
03605    LAB_1D5F
03606    DDF0  85 AA        	STA	Vrschl		; save search address low byte
03607    DDF2  E4 7E        	CPX	Sarryh		; compare high address with var space end
03608    DDF4  D0 04        	BNE	LAB_1D69		; skip next compare if <>
03609    
03610    					; high addresses were = so compare low addresses
03611    DDF6  C5 7D        	CMP	Sarryl		; compare low address with var space end
03612    DDF8  F0 2C        	BEQ	LAB_1D8B		; if not found go make new var
03613    
03614    LAB_1D69
03615    DDFA  A5 93        	LDA	Varnm1		; get 1st character of var to find
03616    DDFC  D1 AA        	CMP	(Vrschl),Y		; compare with variable name 1st character
03617    DDFE  D0 08        	BNE	LAB_1D77		; branch if no match
03618    
03619    					; 1st characters match so compare 2nd characters
03620    DE00  A5 94        	LDA	Varnm2		; get 2nd character of var to find
03621    DE02  C8           	INY				; index to point to variable name 2nd character
03622    DE03  D1 AA        	CMP	(Vrschl),Y		; compare with variable name 2nd character
03623    DE05  F0 69        	BEQ	LAB_1DD7		; branch if match (found var)
03624    
03625    DE07  88           	DEY				; else decrement index (now = $00)
03626    LAB_1D77
03627    DE08  18           	CLC				; clear carry for add
03628    DE09  A5 AA        	LDA	Vrschl		; get search address low byte
03629    DE0B  69 06        	ADC	#$06			; +6 (offset to next var name)
03630    DE0D  90 E1        	BCC	LAB_1D5F		; loop if no overflow to high byte
03631    
03632    DE0F  E8           	INX				; else increment high byte
03633    DE10  D0 DC        	BNE	LAB_1D5D		; loop always (RAM doesn't extend to $FFFF !)
03634    
03635    ; check byte, return C=0 if<"A" or >"Z" or "a" to "z"
03636    
03637    LAB_CASC
03638    DE12  C9 61        	CMP	#'a'			; compare with "a"
03639    DE14  B0 0A        	BCS	LAB_1D83		; go check <"z"+1
03640    
03641    ; check byte, return C=0 if<"A" or >"Z"
03642    
03643    LAB_1D82
03644    DE16  C9 41        	CMP	#'A'			; compare with "A"
03645    DE18  90 05        	BCC	LAB_1D8A		; exit if less
03646    
03647    					; carry is set
03648    DE1A  E9 5B        	SBC	#$5B			; subtract "Z"+1
03649    DE1C  38           	SEC				; set carry
03650    DE1D  E9 A5        	SBC	#$A5			; subtract $A5 (restore byte)
03651    					; carry clear if byte>$5A
03652    LAB_1D8A
03653    DE1F  60           	RTS
03654    
03655    LAB_1D83
03656    DE20  E9 7B        	SBC	#$7B			; subtract "z"+1
03657    DE22  38           	SEC				; set carry
03658    DE23  E9 85        	SBC	#$85			; subtract $85 (restore byte)
03659    					; carry clear if byte>$7A
03660    DE25  60           	RTS
03661    
03662    					; reached end of variable mem without match
03663    					; .. so create new variable
03664    LAB_1D8B
03665    DE26  68           	PLA				; pop return address low byte
03666    DE27  48           	PHA				; push return address low byte
03667      DC31             LAB_1C18p2	= LAB_1C18+2
03668    DE28  C9 31        	CMP	#<LAB_1C18p2	; compare with expected calling routine return low byte
03669    DE2A  D0 05        	BNE	LAB_1D98		; if not get (var) go create new var
03670    
03671    ; This will only drop through if the call was from LAB_1C18 and is only called
03672    ; from there if it is searching for a variable from the RHS of a LET a=b statement
03673    ; it prevents the creation of variables not assigned a value.
03674    
03675    ; value returned by this is either numeric zero (exponent byte is $00) or null string
03676    ; (descriptor length byte is $00). in fact a pointer to any $00 byte would have done.
03677    
03678    ; doing this saves 6 bytes of variable memory and 168 machine cycles of time
03679    
03680    ; this is where you would put the undefined variable error call e.g.
03681    
03682    ;					; variable doesn't exist so flag error
03683    ;	LDX	#$24			; error code $24 ("undefined variable" error)
03684    ;	JMP	LAB_XERR		; do error #X then warm start
03685    
03686    ; the above code has been tested and works a treat! (it replaces the three code lines
03687    ; below)
03688    
03689    					; else return dummy null value
03690    DE2C  A9 EE        	LDA	#<LAB_1D96		; low byte point to $00,$00
03691    					; (uses part of misc constants table)
03692    DE2E  A0 F1        	LDY	#>LAB_1D96		; high byte point to $00,$00
03693    DE30  60           	RTS
03694    
03695    					; create new numeric variable
03696    LAB_1D98
03697    DE31  A5 7D        	LDA	Sarryl		; get var mem end low byte
03698    DE33  A4 7E        	LDY	Sarryh		; get var mem end high byte
03699    DE35  85 AA        	STA	Ostrtl		; save old block start low byte
03700    DE37  84 AB        	STY	Ostrth		; save old block start high byte
03701    DE39  A5 7F        	LDA	Earryl		; get array mem end low byte
03702    DE3B  A4 80        	LDY	Earryh		; get array mem end high byte
03703    DE3D  85 A6        	STA	Obendl		; save old block end low byte
03704    DE3F  84 A7        	STY	Obendh		; save old block end high byte
03705    DE41  18           	CLC				; clear carry for add
03706    DE42  69 06        	ADC	#$06			; +6 (space for one var)
03707    DE44  90 01        	BCC	LAB_1DAE		; branch if no overflow to high byte
03708    
03709    DE46  C8           	INY				; else increment high byte
03710    LAB_1DAE
03711    DE47  85 A4        	STA	Nbendl		; set new block end low byte
03712    DE49  84 A5        	STY	Nbendh		; set new block end high byte
03713    DE4B  20 B3 D0     	JSR	LAB_11CF		; open up space in memory
03714    DE4E  A5 A4        	LDA	Nbendl		; get new start low byte
03715    DE50  A4 A5        	LDY	Nbendh		; get new start high byte (-$100)
03716    DE52  C8           	INY				; correct high byte
03717    DE53  85 7D        	STA	Sarryl		; save new var mem end low byte
03718    DE55  84 7E        	STY	Sarryh		; save new var mem end high byte
03719    DE57  A0 00        	LDY	#$00			; clear index
03720    DE59  A5 93        	LDA	Varnm1		; get var name 1st character
03721    DE5B  91 AA        	STA	(Vrschl),Y		; save var name 1st character
03722    DE5D  C8           	INY				; increment index
03723    DE5E  A5 94        	LDA	Varnm2		; get var name 2nd character
03724    DE60  91 AA        	STA	(Vrschl),Y		; save var name 2nd character
03725    DE62  A9 00        	LDA	#$00			; clear A
03726    DE64  C8           	INY				; increment index
03727    DE65  91 AA        	STA	(Vrschl),Y		; initialise var byte
03728    DE67  C8           	INY				; increment index
03729    DE68  91 AA        	STA	(Vrschl),Y		; initialise var byte
03730    DE6A  C8           	INY				; increment index
03731    DE6B  91 AA        	STA	(Vrschl),Y		; initialise var byte
03732    DE6D  C8           	INY				; increment index
03733    DE6E  91 AA        	STA	(Vrschl),Y		; initialise var byte
03734    
03735    					; found a match for var ((Vrschl) = ptr)
03736    LAB_1DD7
03737    DE70  A5 AA        	LDA	Vrschl		; get var address low byte
03738    DE72  18           	CLC				; clear carry for add
03739    DE73  69 02        	ADC	#$02			; +2 (offset past var name bytes)
03740    DE75  A4 AB        	LDY	Vrschh		; get var address high byte
03741    DE77  90 01        	BCC	LAB_1DE1		; branch if no overflow from add
03742    
03743    DE79  C8           	INY				; else increment high byte
03744    LAB_1DE1
03745    DE7A  85 95        	STA	Cvaral		; save current var address low byte
03746    DE7C  84 96        	STY	Cvarah		; save current var address high byte
03747    DE7E  60           	RTS
03748    
03749    ; set-up array pointer (Adatal/h) to first element in array
03750    ; set Adatal,Adatah to Astrtl,Astrth+2*Dimcnt+#$05
03751    
03752    LAB_1DE6
03753    DE7F  A5 5D        	LDA	Dimcnt		; get # of dimensions (1, 2 or 3)
03754    DE81  0A           	ASL				; *2 (also clears the carry !)
03755    DE82  69 05        	ADC	#$05			; +5 (result is 7, 9 or 11 here)
03756    DE84  65 AA        	ADC	Astrtl		; add array start pointer low byte
03757    DE86  A4 AB        	LDY	Astrth		; get array pointer high byte
03758    DE88  90 01        	BCC	LAB_1DF2		; branch if no overflow
03759    
03760    DE8A  C8           	INY				; else increment high byte
03761    LAB_1DF2
03762    DE8B  85 A4        	STA	Adatal		; save array data pointer low byte
03763    DE8D  84 A5        	STY	Adatah		; save array data pointer high byte
03764    DE8F  60           	RTS
03765    
03766    ; evaluate integer expression
03767    
03768    LAB_EVIN
03769    DE90  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory
03770    DE93  20 C1 DA     	JSR	LAB_EVNM		; evaluate expression and check is numeric,
03771    					; else do type mismatch
03772    
03773    ; evaluate integer expression (no check)
03774    
03775    LAB_EVPI
03776    DE96  A5 B0        	LDA	FAC1_s		; get FAC1 sign (b7)
03777    DE98  30 0D        	BMI	LAB_1E12		; do function call error if -ve
03778    
03779    ; evaluate integer expression (no sign check)
03780    
03781    LAB_EVIR
03782    DE9A  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
03783    DE9C  C9 90        	CMP	#$90			; compare with exponent = 2^16 (n>2^15)
03784    DE9E  90 09        	BCC	LAB_1E14		; branch if n<2^16 (is ok)
03785    
03786    DEA0  A9 F5        	LDA	#<LAB_1DF7		; set pointer low byte to -32768
03787    DEA2  A0 F1        	LDY	#>LAB_1DF7		; set pointer high byte to -32768
03788    DEA4  20 0B E9     	JSR	LAB_27F8		; compare FAC1 with (AY)
03789    LAB_1E12
03790    DEA7  D0 74        	BNE	LAB_FCER		; if <> do function call error then warm start
03791    
03792    LAB_1E14
03793    DEA9  4C 44 E9     	JMP	LAB_2831		; convert FAC1 floating-to-fixed and return
03794    
03795    ; find or make array
03796    
03797    LAB_1E17
03798    DEAC  A5 5E        	LDA	Defdim		; get DIM flag
03799    DEAE  48           	PHA				; push it
03800    DEAF  A5 5F        	LDA	Dtypef		; get data type flag, $FF=string, $00=numeric
03801    DEB1  48           	PHA				; push it
03802    DEB2  A0 00        	LDY	#$00			; clear dimensions count
03803    
03804    ; now get the array dimension(s) and stack it (them) before the data type and DIM flag
03805    
03806    LAB_1E1F
03807    DEB4  98           	TYA				; copy dimensions count
03808    DEB5  48           	PHA				; save it
03809    DEB6  A5 94        	LDA	Varnm2		; get array name 2nd byte
03810    DEB8  48           	PHA				; save it
03811    DEB9  A5 93        	LDA	Varnm1		; get array name 1st byte
03812    DEBB  48           	PHA				; save it
03813    DEBC  20 90 DE     	JSR	LAB_EVIN		; evaluate integer expression
03814    DEBF  68           	PLA				; pull array name 1st byte
03815    DEC0  85 93        	STA	Varnm1		; restore array name 1st byte
03816    DEC2  68           	PLA				; pull array name 2nd byte
03817    DEC3  85 94        	STA	Varnm2		; restore array name 2nd byte
03818    DEC5  68           	PLA				; pull dimensions count
03819    DEC6  A8           	TAY				; restore it
03820    DEC7  BA           	TSX				; copy stack pointer
03821    DEC8  BD 02 01     	LDA	LAB_STAK+2,X	; get DIM flag
03822    DECB  48           	PHA				; push it
03823    DECC  BD 01 01     	LDA	LAB_STAK+1,X	; get data type flag
03824    DECF  48           	PHA				; push it
03825    DED0  A5 AE        	LDA	FAC1_2		; get this dimension size high byte
03826    DED2  9D 02 01     	STA	LAB_STAK+2,X	; stack before flag bytes
03827    DED5  A5 AF        	LDA	FAC1_3		; get this dimension size low byte
03828    DED7  9D 01 01     	STA	LAB_STAK+1,X	; stack before flag bytes
03829    DEDA  C8           	INY				; increment dimensions count
03830    DEDB  20 C2 00     	JSR	LAB_GBYT		; scan memory
03831    DEDE  C9 2C        	CMP	#','			; compare with ","
03832    DEE0  F0 D2        	BEQ	LAB_1E1F		; if found go do next dimension
03833    
03834    DEE2  84 5D        	STY	Dimcnt		; store dimensions count
03835    DEE4  20 E3 DB     	JSR	LAB_1BFB		; scan for ")" , else do syntax error then warm start
03836    DEE7  68           	PLA				; pull data type flag
03837    DEE8  85 5F        	STA	Dtypef		; restore data type flag, $FF=string, $00=numeric
03838    DEEA  68           	PLA				; pull DIM flag
03839    DEEB  85 5E        	STA	Defdim		; restore DIM flag
03840    DEED  A6 7D        	LDX	Sarryl		; get array mem start low byte
03841    DEEF  A5 7E        	LDA	Sarryh		; get array mem start high byte
03842    
03843    ; now check to see if we are at the end of array memory (we would be if there were
03844    ; no arrays).
03845    
03846    LAB_1E5C
03847    DEF1  86 AA        	STX	Astrtl		; save as array start pointer low byte
03848    DEF3  85 AB        	STA	Astrth		; save as array start pointer high byte
03849    DEF5  C5 80        	CMP	Earryh		; compare with array mem end high byte
03850    DEF7  D0 04        	BNE	LAB_1E68		; branch if not reached array mem end
03851    
03852    DEF9  E4 7F        	CPX	Earryl		; else compare with array mem end low byte
03853    DEFB  F0 39        	BEQ	LAB_1EA1		; go build array if not found
03854    
03855    					; search for array
03856    LAB_1E68
03857    DEFD  A0 00        	LDY	#$00			; clear index
03858    DEFF  B1 AA        	LDA	(Astrtl),Y		; get array name first byte
03859    DF01  C8           	INY				; increment index to second name byte
03860    DF02  C5 93        	CMP	Varnm1		; compare with this array name first byte
03861    DF04  D0 06        	BNE	LAB_1E77		; branch if no match
03862    
03863    DF06  A5 94        	LDA	Varnm2		; else get this array name second byte
03864    DF08  D1 AA        	CMP	(Astrtl),Y		; compare with array name second byte
03865    DF0A  F0 16        	BEQ	LAB_1E8D		; array found so branch
03866    
03867    					; no match
03868    LAB_1E77
03869    DF0C  C8           	INY				; increment index
03870    DF0D  B1 AA        	LDA	(Astrtl),Y		; get array size low byte
03871    DF0F  18           	CLC				; clear carry for add
03872    DF10  65 AA        	ADC	Astrtl		; add array start pointer low byte
03873    DF12  AA           	TAX				; copy low byte to X
03874    DF13  C8           	INY				; increment index
03875    DF14  B1 AA        	LDA	(Astrtl),Y		; get array size high byte
03876    DF16  65 AB        	ADC	Astrth		; add array mem pointer high byte
03877    DF18  90 D7        	BCC	LAB_1E5C		; if no overflow go check next array
03878    
03879    ; do array bounds error
03880    
03881    LAB_1E85
03882    DF1A  A2 10        	LDX	#$10			; error code $10 ("Array bounds" error)
03883    	.byte	$2C			; makes next bit BIT LAB_08A2
03884    
03885    ; do function call error
03886    
03887    LAB_FCER
03888    DF1D  A2 08        	LDX	#$08			; error code $08 ("Function call" error)
03889    LAB_1E8A
03890    DF1F  4C 2E D1     	JMP	LAB_XERR		; do error #X, then warm start
03891    
03892    					; found array, are we trying to dimension it?
03893    LAB_1E8D
03894    DF22  A2 12        	LDX	#$12			; set error $12 ("Double dimension" error)
03895    DF24  A5 5E        	LDA	Defdim		; get DIM flag
03896    DF26  D0 F7        	BNE	LAB_1E8A		; if we are trying to dimension it do error #X, then warm
03897    					; start
03898    
03899    ; found the array and we're not dimensioning it so we must find an element in it
03900    
03901    DF28  20 7F DE     	JSR	LAB_1DE6		; set-up array pointer (Adatal/h) to first element in array
03902    					; (Astrtl,Astrth points to start of array)
03903    DF2B  A5 5D        	LDA	Dimcnt		; get dimensions count
03904    DF2D  A0 04        	LDY	#$04			; set index to array's # of dimensions
03905    DF2F  D1 AA        	CMP	(Astrtl),Y		; compare with no of dimensions
03906    DF31  D0 E7        	BNE	LAB_1E85		; if wrong do array bounds error, could do "Wrong
03907    					; dimensions" error here .. if we want a different
03908    					; error message
03909    
03910    DF33  4C B9 DF     	JMP	LAB_1F28		; found array so go get element
03911    					; (could jump to LAB_1F28 as all LAB_1F24 does is take
03912    					; Dimcnt and save it at (Astrtl),Y which is already the
03913    					; same or we would have taken the BNE)
03914    
03915    					; array not found, so build it
03916    LAB_1EA1
03917    DF36  20 7F DE     	JSR	LAB_1DE6		; set-up array pointer (Adatal/h) to first element in array
03918    					; (Astrtl,Astrth points to start of array)
03919    DF39  20 FD D0     	JSR	LAB_121F		; check available memory, "Out of memory" error if no room
03920    					; addr to check is in AY (low/high)
03921    DF3C  A0 00        	LDY	#$00			; clear Y (don't need to clear A)
03922    DF3E  84 BB        	STY	Aspth			; clear array data size high byte
03923    DF40  A5 93        	LDA	Varnm1		; get variable name 1st byte
03924    DF42  91 AA        	STA	(Astrtl),Y		; save array name 1st byte
03925    DF44  C8           	INY				; increment index
03926    DF45  A5 94        	LDA	Varnm2		; get variable name 2nd byte
03927    DF47  91 AA        	STA	(Astrtl),Y		; save array name 2nd byte
03928    DF49  A5 5D        	LDA	Dimcnt		; get dimensions count
03929    DF4B  A0 04        	LDY	#$04			; index to dimension count
03930    DF4D  84 BA        	STY	Asptl			; set array data size low byte (four bytes per element)
03931    DF4F  91 AA        	STA	(Astrtl),Y		; set array's dimensions count
03932    
03933    					; now calculate the size of the data space for the array
03934    DF51  18           	CLC				; clear carry for add (clear on subsequent loops)
03935    LAB_1EC0
03936    DF52  A2 0B        	LDX	#$0B			; set default dimension value low byte
03937    DF54  A9 00        	LDA	#$00			; set default dimension value high byte
03938    DF56  24 5E        	BIT	Defdim		; test default DIM flag
03939    DF58  50 07        	BVC	LAB_1ED0		; branch if b6 of Defdim is clear
03940    
03941    DF5A  68           	PLA				; else pull dimension value low byte
03942    DF5B  69 01        	ADC	#$01			; +1 (allow for zeroeth element)
03943    DF5D  AA           	TAX				; copy low byte to X
03944    DF5E  68           	PLA				; pull dimension value high byte
03945    DF5F  69 00        	ADC	#$00			; add carry from low byte
03946    
03947    LAB_1ED0
03948    DF61  C8           	INY				; index to dimension value high byte
03949    DF62  91 AA        	STA	(Astrtl),Y		; save dimension value high byte
03950    DF64  C8           	INY				; index to dimension value high byte
03951    DF65  8A           	TXA				; get dimension value low byte
03952    DF66  91 AA        	STA	(Astrtl),Y		; save dimension value low byte
03953    DF68  20 08 E0     	JSR	LAB_1F7C		; does XY = (Astrtl),Y * (Asptl)
03954    DF6B  86 BA        	STX	Asptl			; save array data size low byte
03955    DF6D  85 BB        	STA	Aspth			; save array data size high byte
03956    DF6F  A4 71        	LDY	ut1_pl		; restore index (saved by subroutine)
03957    DF71  C6 5D        	DEC	Dimcnt		; decrement dimensions count
03958    DF73  D0 DD        	BNE	LAB_1EC0		; loop while not = 0
03959    
03960    DF75  65 A5        	ADC	Adatah		; add size high byte to first element high byte
03961    					; (carry is always clear here)
03962    DF77  B0 5D        	BCS	LAB_1F45		; if overflow go do "Out of memory" error
03963    
03964    DF79  85 A5        	STA	Adatah		; save end of array high byte
03965    DF7B  A8           	TAY				; copy end high byte to Y
03966    DF7C  8A           	TXA				; get array size low byte
03967    DF7D  65 A4        	ADC	Adatal		; add array start low byte
03968    DF7F  90 03        	BCC	LAB_1EF3		; branch if no carry
03969    
03970    DF81  C8           	INY				; else increment end of array high byte
03971    DF82  F0 52        	BEQ	LAB_1F45		; if overflow go do "Out of memory" error
03972    
03973    					; set-up mostly complete, now zero the array
03974    LAB_1EF3
03975    DF84  20 FD D0     	JSR	LAB_121F		; check available memory, "Out of memory" error if no room
03976    					; addr to check is in AY (low/high)
03977    DF87  85 7F        	STA	Earryl		; save array mem end low byte
03978    DF89  84 80        	STY	Earryh		; save array mem end high byte
03979    DF8B  A9 00        	LDA	#$00			; clear byte for array clear
03980    DF8D  E6 BB        	INC	Aspth			; increment array size high byte (now block count)
03981    DF8F  A4 BA        	LDY	Asptl			; get array size low byte (now index to block)
03982    DF91  F0 05        	BEQ	LAB_1F07		; branch if low byte = $00
03983    
03984    LAB_1F02
03985    DF93  88           	DEY				; decrement index (do 0 to n-1)
03986    DF94  91 A4        	STA	(Adatal),Y		; zero byte
03987    DF96  D0 FB        	BNE	LAB_1F02		; loop until this block done
03988    
03989    LAB_1F07
03990    DF98  C6 A5        	DEC	Adatah		; decrement array pointer high byte
03991    DF9A  C6 BB        	DEC	Aspth			; decrement block count high byte
03992    DF9C  D0 F5        	BNE	LAB_1F02		; loop until all blocks done
03993    
03994    DF9E  E6 A5        	INC	Adatah		; correct for last loop
03995    DFA0  38           	SEC				; set carry for subtract
03996    DFA1  A0 02        	LDY	#$02			; index to array size low byte
03997    DFA3  A5 7F        	LDA	Earryl		; get array mem end low byte
03998    DFA5  E5 AA        	SBC	Astrtl		; subtract array start low byte
03999    DFA7  91 AA        	STA	(Astrtl),Y		; save array size low byte
04000    DFA9  C8           	INY				; index to array size high byte
04001    DFAA  A5 80        	LDA	Earryh		; get array mem end high byte
04002    DFAC  E5 AB        	SBC	Astrth		; subtract array start high byte
04003    DFAE  91 AA        	STA	(Astrtl),Y		; save array size high byte
04004    DFB0  A5 5E        	LDA	Defdim		; get default DIM flag
04005    DFB2  D0 53        	BNE	LAB_1F7B		; exit (RET) if this was a DIM command
04006    
04007    					; else, find element
04008    DFB4  C8           	INY				; index to # of dimensions
04009    
04010    LAB_1F24
04011    DFB5  B1 AA        	LDA	(Astrtl),Y		; get array's dimension count
04012    DFB7  85 5D        	STA	Dimcnt		; save it
04013    
04014    ; we have found, or built, the array. now we need to find the element
04015    
04016    LAB_1F28
04017    DFB9  A9 00        	LDA	#$00			; clear byte
04018    DFBB  85 BA        	STA	Asptl			; clear array data pointer low byte
04019    LAB_1F2C
04020    DFBD  85 BB        	STA	Aspth			; save array data pointer high byte
04021    DFBF  C8           	INY				; increment index (point to array bound high byte)
04022    DFC0  68           	PLA				; pull array index low byte
04023    DFC1  AA           	TAX				; copy to X
04024    DFC2  85 AE        	STA	FAC1_2		; save index low byte to FAC1 mantissa2
04025    DFC4  68           	PLA				; pull array index high byte
04026    DFC5  85 AF        	STA	FAC1_3		; save index high byte to FAC1 mantissa3
04027    DFC7  D1 AA        	CMP	(Astrtl),Y		; compare with array bound high byte
04028    DFC9  90 0E        	BCC	LAB_1F48		; branch if within bounds
04029    
04030    DFCB  D0 06        	BNE	LAB_1F42		; if outside bounds do array bounds error
04031    
04032    					; else high byte was = so test low bytes
04033    DFCD  C8           	INY				; index to array bound low byte
04034    DFCE  8A           	TXA				; get array index low byte
04035    DFCF  D1 AA        	CMP	(Astrtl),Y		; compare with array bound low byte
04036    DFD1  90 07        	BCC	LAB_1F49		; branch if within bounds
04037    
04038    LAB_1F42
04039    DFD3  4C 1A DF     	JMP	LAB_1E85		; else do array bounds error
04040    
04041    LAB_1F45
04042    DFD6  4C 2C D1     	JMP	LAB_OMER		; do "Out of memory" error then warm start
04043    
04044    LAB_1F48
04045    DFD9  C8           	INY				; index to array bound low byte
04046    LAB_1F49
04047    DFDA  A5 BB        	LDA	Aspth			; get array data pointer high byte
04048    DFDC  05 BA        	ORA	Asptl			; OR with array data pointer low byte
04049    DFDE  F0 0A        	BEQ	LAB_1F5A		; branch if array data pointer = null (skip multiply)
04050    
04051    DFE0  20 08 E0     	JSR	LAB_1F7C		; does XY = (Astrtl),Y * (Asptl)
04052    DFE3  8A           	TXA				; get result low byte
04053    DFE4  65 AE        	ADC	FAC1_2		; add index low byte from FAC1 mantissa2
04054    DFE6  AA           	TAX				; save result low byte
04055    DFE7  98           	TYA				; get result high byte
04056    DFE8  A4 71        	LDY	ut1_pl		; restore index
04057    LAB_1F5A
04058    DFEA  65 AF        	ADC	FAC1_3		; add index high byte from FAC1 mantissa3
04059    DFEC  86 BA        	STX	Asptl			; save array data pointer low byte
04060    DFEE  C6 5D        	DEC	Dimcnt		; decrement dimensions count
04061    DFF0  D0 CB        	BNE	LAB_1F2C		; loop if dimensions still to do
04062    
04063    DFF2  06 BA        	ASL	Asptl			; array data pointer low byte * 2
04064    DFF4  2A           	ROL				; array data pointer high byte * 2
04065    DFF5  06 BA        	ASL	Asptl			; array data pointer low byte * 4
04066    DFF7  2A           	ROL				; array data pointer high byte * 4
04067    DFF8  A8           	TAY				; copy high byte
04068    DFF9  A5 BA        	LDA	Asptl			; get low byte
04069    DFFB  65 A4        	ADC	Adatal		; add array data start pointer low byte
04070    DFFD  85 95        	STA	Cvaral		; save as current var address low byte
04071    DFFF  98           	TYA				; get high byte back
04072    E000  65 A5        	ADC	Adatah		; add array data start pointer high byte
04073    E002  85 96        	STA	Cvarah		; save as current var address high byte
04074    E004  A8           	TAY				; copy high byte to Y
04075    E005  A5 95        	LDA	Cvaral		; get current var address low byte
04076    LAB_1F7B
04077    E007  60           	RTS
04078    
04079    ; does XY = (Astrtl),Y * (Asptl)
04080    
04081    LAB_1F7C
04082    E008  84 71        	STY	ut1_pl		; save index
04083    E00A  B1 AA        	LDA	(Astrtl),Y		; get dimension size low byte
04084    E00C  85 76        	STA	dims_l		; save dimension size low byte
04085    E00E  88           	DEY				; decrement index
04086    E00F  B1 AA        	LDA	(Astrtl),Y		; get dimension size high byte
04087    E011  85 77        	STA	dims_h		; save dimension size high byte
04088    
04089    E013  A9 10        	LDA	#$10			; count = $10 (16 bit multiply)
04090    E015  85 A8        	STA	numbit		; save bit count
04091    E017  A2 00        	LDX	#$00			; clear result low byte
04092    E019  A0 00        	LDY	#$00			; clear result high byte
04093    LAB_1F8F
04094    E01B  8A           	TXA				; get result low byte
04095    E01C  0A           	ASL				; *2
04096    E01D  AA           	TAX				; save result low byte
04097    E01E  98           	TYA				; get result high byte
04098    E01F  2A           	ROL				; *2
04099    E020  A8           	TAY				; save result high byte
04100    E021  B0 B3        	BCS	LAB_1F45		; if overflow go do "Out of memory" error
04101    
04102    E023  06 BA        	ASL	Asptl			; shift multiplier low byte
04103    E025  26 BB        	ROL	Aspth			; shift multiplier high byte
04104    E027  90 0B        	BCC	LAB_1FA8		; skip add if no carry
04105    
04106    E029  18           	CLC				; else clear carry for add
04107    E02A  8A           	TXA				; get result low byte
04108    E02B  65 76        	ADC	dims_l		; add dimension size low byte
04109    E02D  AA           	TAX				; save result low byte
04110    E02E  98           	TYA				; get result high byte
04111    E02F  65 77        	ADC	dims_h		; add dimension size high byte
04112    E031  A8           	TAY				; save result high byte
04113    E032  B0 A2        	BCS	LAB_1F45		; if overflow go do "Out of memory" error
04114    
04115    LAB_1FA8
04116    E034  C6 A8        	DEC	numbit		; decrement bit count
04117    E036  D0 E3        	BNE	LAB_1F8F		; loop until all done
04118    
04119    E038  60           	RTS
04120    
04121    ; perform FRE()
04122    
04123    LAB_FRE
04124    E039  A5 5F        	LDA	Dtypef		; get data type flag, $FF=string, $00=numeric
04125    E03B  10 03        	BPL	LAB_1FB4		; branch if numeric
04126    
04127    E03D  20 32 E3     	JSR	LAB_22B6		; pop string off descriptor stack, or from top of string
04128    					; space returns with A = length, X=$71=pointer low byte,
04129    					; Y=$72=pointer high byte
04130    
04131    					; FRE(n) was numeric so do this
04132    LAB_1FB4
04133    E040  20 D3 E1     	JSR	LAB_GARB		; go do garbage collection
04134    E043  38           	SEC				; set carry for subtract
04135    E044  A5 81        	LDA	Sstorl		; get bottom of string space low byte
04136    E046  E5 7F        	SBC	Earryl		; subtract array mem end low byte
04137    E048  A8           	TAY				; copy result to Y
04138    E049  A5 82        	LDA	Sstorh		; get bottom of string space high byte
04139    E04B  E5 80        	SBC	Earryh		; subtract array mem end high byte
04140    
04141    ; save and convert integer AY to FAC1
04142    
04143    LAB_AYFC
04144    E04D  46 5F        	LSR	Dtypef		; clear data type flag, $FF=string, $00=numeric
04145    E04F  85 AD        	STA	FAC1_1		; save FAC1 mantissa1
04146    E051  84 AE        	STY	FAC1_2		; save FAC1 mantissa2
04147    E053  A2 90        	LDX	#$90			; set exponent=2^16 (integer)
04148    E055  4C F6 E8     	JMP	LAB_27E3		; set exp=X, clear FAC1_3, normalise and return
04149    
04150    ; perform POS()
04151    
04152    LAB_POS
04153    E058  A4 0E        	LDY	TPos			; get terminal position
04154    
04155    ; convert Y to byte in FAC1
04156    
04157    LAB_1FD0
04158    E05A  A9 00        	LDA	#$00			; clear high byte
04159    E05C  F0 EF        	BEQ	LAB_AYFC		; always save and convert integer AY to FAC1 and return
04160    
04161    ; check not Direct (used by DEF and INPUT)
04162    
04163    LAB_CKRN
04164    E05E  A6 88        	LDX	Clineh		; get current line high byte
04165    E060  E8           	INX				; increment it
04166    E061  D0 A4        	BNE	LAB_1F7B		; return if can continue not direct mode
04167    
04168    					; else do illegal direct error
04169    LAB_1FD9
04170    E063  A2 16        	LDX	#$16			; error code $16 ("Illegal direct" error)
04171    LAB_1FDB
04172    E065  4C 2E D1     	JMP	LAB_XERR		; go do error #X, then warm start
04173    
04174    ; perform DEF
04175    
04176    LAB_DEF
04177    E068  20 99 E0     	JSR	LAB_200B		; check FNx syntax
04178    E06B  85 9C        	STA	func_l		; save function pointer low byte
04179    E06D  84 9D        	STY	func_h		; save function pointer high byte
04180    E06F  20 5E E0     	JSR	LAB_CKRN		; check not Direct (back here if ok)
04181    E072  20 EE DB     	JSR	LAB_1BFE		; scan for "(" , else do syntax error then warm start
04182    E075  A9 80        	LDA	#$80			; set flag for FNx
04183    E077  85 61        	STA	Sufnxf		; save subscript/FNx flag
04184    E079  20 9E DD     	JSR	LAB_GVAR		; get (var) address
04185    E07C  20 C4 DA     	JSR	LAB_CTNM		; check if source is numeric, else do type mismatch
04186    E07F  20 E3 DB     	JSR	LAB_1BFB		; scan for ")" , else do syntax error then warm start
04187    E082  A9 C1        	LDA	#TK_EQUAL		; get = token
04188    E084  20 E5 DB     	JSR	LAB_SCCA		; scan for CHR$(A), else do syntax error then warm start
04189    E087  A5 96        	LDA	Cvarah		; get current var address high byte
04190    E089  48           	PHA				; push it
04191    E08A  A5 95        	LDA	Cvaral		; get current var address low byte
04192    E08C  48           	PHA				; push it
04193    E08D  A5 C4        	LDA	Bpntrh		; get BASIC execute pointer high byte
04194    E08F  48           	PHA				; push it
04195    E090  A5 C3        	LDA	Bpntrl		; get BASIC execute pointer low byte
04196    E092  48           	PHA				; push it
04197    E093  20 80 D6     	JSR	LAB_DATA		; go perform DATA
04198    E096  4C 08 E1     	JMP	LAB_207A		; put execute pointer and variable pointer into function
04199    					; and return
04200    
04201    ; check FNx syntax
04202    
04203    LAB_200B
04204    E099  A9 AE        	LDA	#TK_FN		; get FN" token
04205    E09B  20 E5 DB     	JSR	LAB_SCCA		; scan for CHR$(A) , else do syntax error then warm start
04206    					; return character after A
04207    E09E  09 80        	ORA	#$80			; set FN flag bit
04208    E0A0  85 61        	STA	Sufnxf		; save FN flag so array variable test fails
04209    E0A2  20 A5 DD     	JSR	LAB_1D12		; search for FN variable
04210    E0A5  4C C4 DA     	JMP	LAB_CTNM		; check if source is numeric and return, else do type
04211    					; mismatch
04212    
04213    					; Evaluate FNx
04214    LAB_201E
04215    E0A8  20 99 E0     	JSR	LAB_200B		; check FNx syntax
04216    E0AB  48           	PHA				; push function pointer low byte
04217    E0AC  98           	TYA				; copy function pointer high byte
04218    E0AD  48           	PHA				; push function pointer high byte
04219    E0AE  20 EE DB     	JSR	LAB_1BFE		; scan for "(", else do syntax error then warm start
04220    E0B1  20 D5 DA     	JSR	LAB_EVEX		; evaluate expression
04221    E0B4  20 E3 DB     	JSR	LAB_1BFB		; scan for ")", else do syntax error then warm start
04222    E0B7  20 C4 DA     	JSR	LAB_CTNM		; check if source is numeric, else do type mismatch
04223    E0BA  68           	PLA				; pop function pointer high byte
04224    E0BB  85 9D        	STA	func_h		; restore it
04225    E0BD  68           	PLA				; pop function pointer low byte
04226    E0BE  85 9C        	STA	func_l		; restore it
04227    E0C0  A2 20        	LDX	#$20			; error code $20 ("Undefined function" error)
04228    E0C2  A0 03        	LDY	#$03			; index to variable pointer high byte
04229    E0C4  B1 9C        	LDA	(func_l),Y		; get variable pointer high byte
04230    E0C6  F0 9D        	BEQ	LAB_1FDB		; if zero go do undefined function error
04231    
04232    E0C8  85 96        	STA	Cvarah		; save variable address high byte
04233    E0CA  88           	DEY				; index to variable address low byte
04234    E0CB  B1 9C        	LDA	(func_l),Y		; get variable address low byte
04235    E0CD  85 95        	STA	Cvaral		; save variable address low byte
04236    E0CF  AA           	TAX				; copy address low byte
04237    
04238    					; now stack the function variable value before use
04239    E0D0  C8           	INY				; index to mantissa_3
04240    LAB_2043
04241    E0D1  B1 95        	LDA	(Cvaral),Y		; get byte from variable
04242    E0D3  48           	PHA				; stack it
04243    E0D4  88           	DEY				; decrement index
04244    E0D5  10 FA        	BPL	LAB_2043		; loop until variable stacked
04245    
04246    E0D7  A4 96        	LDY	Cvarah		; get variable address high byte
04247    E0D9  20 9B E8     	JSR	LAB_2778		; pack FAC1 (function expression value) into (XY)
04248    					; (function variable), return Y=0, always
04249    E0DC  A5 C4        	LDA	Bpntrh		; get BASIC execute pointer high byte
04250    E0DE  48           	PHA				; push it
04251    E0DF  A5 C3        	LDA	Bpntrl		; get BASIC execute pointer low byte
04252    E0E1  48           	PHA				; push it
04253    E0E2  B1 9C        	LDA	(func_l),Y		; get function execute pointer low byte
04254    E0E4  85 C3        	STA	Bpntrl		; save as BASIC execute pointer low byte
04255    E0E6  C8           	INY				; index to high byte
04256    E0E7  B1 9C        	LDA	(func_l),Y		; get function execute pointer high byte
04257    E0E9  85 C4        	STA	Bpntrh		; save as BASIC execute pointer high byte
04258    E0EB  A5 96        	LDA	Cvarah		; get variable address high byte
04259    E0ED  48           	PHA				; push it
04260    E0EE  A5 95        	LDA	Cvaral		; get variable address low byte
04261    E0F0  48           	PHA				; push it
04262    E0F1  20 C1 DA     	JSR	LAB_EVNM		; evaluate expression and check is numeric,
04263    					; else do type mismatch
04264    E0F4  68           	PLA				; pull variable address low byte
04265    E0F5  85 9C        	STA	func_l		; save variable address low byte
04266    E0F7  68           	PLA				; pull variable address high byte
04267    E0F8  85 9D        	STA	func_h		; save variable address high byte
04268    E0FA  20 C2 00     	JSR	LAB_GBYT		; scan memory
04269    E0FD  F0 03        	BEQ	LAB_2074		; branch if null (should be [EOL] marker)
04270    
04271    E0FF  4C F6 DB     	JMP	LAB_SNER		; else syntax error then warm start
04272    
04273    ; restore Bpntrl,Bpntrh and function variable from stack
04274    
04275    LAB_2074
04276    E102  68           	PLA				; pull BASIC execute pointer low byte
04277    E103  85 C3        	STA	Bpntrl		; restore BASIC execute pointer low byte
04278    E105  68           	PLA				; pull BASIC execute pointer high byte
04279    E106  85 C4        	STA	Bpntrh		; restore BASIC execute pointer high byte
04280    
04281    ; put execute pointer and variable pointer into function
04282    
04283    LAB_207A
04284    E108  A0 00        	LDY	#$00			; clear index
04285    E10A  68           	PLA				; pull BASIC execute pointer low byte
04286    E10B  91 9C        	STA	(func_l),Y		; save to function
04287    E10D  C8           	INY				; increment index
04288    E10E  68           	PLA				; pull BASIC execute pointer high byte
04289    E10F  91 9C        	STA	(func_l),Y		; save to function
04290    E111  C8           	INY				; increment index
04291    E112  68           	PLA				; pull current var address low byte
04292    E113  91 9C        	STA	(func_l),Y		; save to function
04293    E115  C8           	INY				; increment index
04294    E116  68           	PLA				; pull current var address high byte
04295    E117  91 9C        	STA	(func_l),Y		; save to function
04296    E119  60           	RTS
04297    
04298    ; perform STR$()
04299    
04300    LAB_STRS
04301    E11A  20 C4 DA     	JSR	LAB_CTNM		; check if source is numeric, else do type mismatch
04302    E11D  20 89 EA     	JSR	LAB_296E		; convert FAC1 to string
04303    E120  A9 F0        	LDA	#<Decssp1		; set result string low pointer
04304    E122  A0 00        	LDY	#>Decssp1		; set result string high pointer
04305    E124  F0 12        	BEQ	LAB_20AE		; print null terminated string to Sutill/Sutilh
04306    
04307    ; Do string vector
04308    ; copy des_pl/h to des_2l/h and make string space A bytes long
04309    
04310    LAB_209C
04311    E126  A6 AE        	LDX	des_pl		; get descriptor pointer low byte
04312    E128  A4 AF        	LDY	des_ph		; get descriptor pointer high byte
04313    E12A  86 9E        	STX	des_2l		; save descriptor pointer low byte
04314    E12C  84 9F        	STY	des_2h		; save descriptor pointer high byte
04315    
04316    ; make string space A bytes long
04317    ; A=length, X=Sutill=ptr low byte, Y=Sutilh=ptr high byte
04318    
04319    LAB_MSSP
04320    E12E  20 A1 E1     	JSR	LAB_2115		; make space in string memory for string A long
04321    					; return X=Sutill=ptr low byte, Y=Sutilh=ptr high byte
04322    E131  86 AD        	STX	str_pl		; save string pointer low byte
04323    E133  84 AE        	STY	str_ph		; save string pointer high byte
04324    E135  85 AC        	STA	str_ln		; save length
04325    E137  60           	RTS
04326    
04327    ; Scan, set up string
04328    ; print " terminated string to Sutill/Sutilh
04329    
04330    LAB_20AE
04331    E138  A2 22        	LDX	#$22			; set terminator to "
04332    E13A  86 5B        	STX	Srchc			; set search character (terminator 1)
04333    E13C  86 5C        	STX	Asrch			; set terminator 2
04334    
04335    ; print [Srchc] or [Asrch] terminated string to Sutill/Sutilh
04336    ; source is AY
04337    
04338    LAB_20B4
04339    E13E  85 B8        	STA	ssptr_l		; store string start low byte
04340    E140  84 B9        	STY	ssptr_h		; store string start high byte
04341    E142  85 AD        	STA	str_pl		; save string pointer low byte
04342    E144  84 AE        	STY	str_ph		; save string pointer high byte
04343    E146  A0 FF        	LDY	#$FF			; set length to -1
04344    LAB_20BE
04345    E148  C8           	INY				; increment length
04346    E149  B1 B8        	LDA	(ssptr_l),Y		; get byte from string
04347    E14B  F0 0C        	BEQ	LAB_20CF		; exit loop if null byte [EOS]
04348    
04349    E14D  C5 5B        	CMP	Srchc			; compare with search character (terminator 1)
04350    E14F  F0 04        	BEQ	LAB_20CB		; branch if terminator
04351    
04352    E151  C5 5C        	CMP	Asrch			; compare with terminator 2
04353    E153  D0 F3        	BNE	LAB_20BE		; loop if not terminator 2
04354    
04355    LAB_20CB
04356    E155  C9 22        	CMP	#$22			; compare with "
04357    E157  F0 01        	BEQ	LAB_20D0		; branch if " (carry set if = !)
04358    
04359    LAB_20CF
04360    E159  18           	CLC				; clear carry for add (only if [EOL] terminated string)
04361    LAB_20D0
04362    E15A  84 AC        	STY	str_ln		; save length in FAC1 exponent
04363    E15C  98           	TYA				; copy length to A
04364    E15D  65 B8        	ADC	ssptr_l		; add string start low byte
04365    E15F  85 BA        	STA	Sendl			; save string end low byte
04366    E161  A6 B9        	LDX	ssptr_h		; get string start high byte
04367    E163  90 01        	BCC	LAB_20DC		; branch if no low byte overflow
04368    
04369    E165  E8           	INX				; else increment high byte
04370    LAB_20DC
04371    E166  86 BB        	STX	Sendh			; save string end high byte
04372    E168  A5 B9        	LDA	ssptr_h		; get string start high byte
04373    E16A  C9 03        	CMP	#>Ram_base		; compare with start of program memory
04374    E16C  B0 0B        	BCS	LAB_RTST		; branch if not in utility area
04375    
04376    					; string in utility area, move to string memory
04377    E16E  98           	TYA				; copy length to A
04378    E16F  20 26 E1     	JSR	LAB_209C		; copy des_pl/h to des_2l/h and make string space A bytes
04379    					; long
04380    E172  A6 B8        	LDX	ssptr_l		; get string start low byte
04381    E174  A4 B9        	LDY	ssptr_h		; get string start high byte
04382    E176  20 13 E3     	JSR	LAB_2298		; store string A bytes long from XY to (Sutill)
04383    
04384    ; check for space on descriptor stack then ..
04385    ; put string address and length on descriptor stack and update stack pointers
04386    
04387    LAB_RTST
04388    E179  A6 65        	LDX	next_s		; get string stack pointer
04389    E17B  E0 71        	CPX	#des_sk+$09		; compare with max+1
04390    E17D  D0 05        	BNE	LAB_20F8		; branch if space on string stack
04391    
04392    					; else do string too complex error
04393    E17F  A2 1C        	LDX	#$1C			; error code $1C ("String too complex" error)
04394    LAB_20F5
04395    E181  4C 2E D1     	JMP	LAB_XERR		; do error #X, then warm start
04396    
04397    ; put string address and length on descriptor stack and update stack pointers
04398    
04399    LAB_20F8
04400    E184  A5 AC        	LDA	str_ln		; get string length
04401    E186  95 00        	STA	PLUS_0,X		; put on string stack
04402    E188  A5 AD        	LDA	str_pl		; get string pointer low byte
04403    E18A  95 01        	STA	PLUS_1,X		; put on string stack
04404    E18C  A5 AE        	LDA	str_ph		; get string pointer high byte
04405    E18E  95 02        	STA	PLUS_2,X		; put on string stack
04406    E190  A0 00        	LDY	#$00			; clear Y
04407    E192  86 AE        	STX	des_pl		; save string descriptor pointer low byte
04408    E194  84 AF        	STY	des_ph		; save string descriptor pointer high byte (always $00)
04409    E196  88           	DEY				; Y = $FF
04410    E197  84 5F        	STY	Dtypef		; save data type flag, $FF=string
04411    E199  86 66        	STX	last_sl		; save old stack pointer (current top item)
04412    E19B  E8           	INX				; update stack pointer
04413    E19C  E8           	INX				; update stack pointer
04414    E19D  E8           	INX				; update stack pointer
04415    E19E  86 65        	STX	next_s		; save new top item value
04416    E1A0  60           	RTS
04417    
04418    ; Build descriptor
04419    ; make space in string memory for string A long
04420    ; return X=Sutill=ptr low byte, Y=Sutill=ptr high byte
04421    
04422    LAB_2115
04423    E1A1  46 60        	LSR	Gclctd		; clear garbage collected flag (b7)
04424    
04425    					; make space for string A long
04426    LAB_2117
04427    E1A3  48           	PHA				; save string length
04428    E1A4  49 FF        	EOR	#$FF			; complement it
04429    E1A6  38           	SEC				; set carry for subtract (twos comp add)
04430    E1A7  65 81        	ADC	Sstorl		; add bottom of string space low byte (subtract length)
04431    E1A9  A4 82        	LDY	Sstorh		; get bottom of string space high byte
04432    E1AB  B0 01        	BCS	LAB_2122		; skip decrement if no underflow
04433    
04434    E1AD  88           	DEY				; decrement bottom of string space high byte
04435    LAB_2122
04436    E1AE  C4 80        	CPY	Earryh		; compare with array mem end high byte
04437    E1B0  90 11        	BCC	LAB_2137		; do out of memory error if less
04438    
04439    E1B2  D0 04        	BNE	LAB_212C		; if not = skip next test
04440    
04441    E1B4  C5 7F        	CMP	Earryl		; compare with array mem end low byte
04442    E1B6  90 0B        	BCC	LAB_2137		; do out of memory error if less
04443    
04444    LAB_212C
04445    E1B8  85 81        	STA	Sstorl		; save bottom of string space low byte
04446    E1BA  84 82        	STY	Sstorh		; save bottom of string space high byte
04447    E1BC  85 83        	STA	Sutill		; save string utility ptr low byte
04448    E1BE  84 84        	STY	Sutilh		; save string utility ptr high byte
04449    E1C0  AA           	TAX				; copy low byte to X
04450    E1C1  68           	PLA				; get string length back
04451    E1C2  60           	RTS
04452    
04453    LAB_2137
04454    E1C3  A2 0C        	LDX	#$0C			; error code $0C ("Out of memory" error)
04455    E1C5  A5 60        	LDA	Gclctd		; get garbage collected flag
04456    E1C7  30 B8        	BMI	LAB_20F5		; if set then do error code X
04457    
04458    E1C9  20 D3 E1     	JSR	LAB_GARB		; else go do garbage collection
04459    E1CC  A9 80        	LDA	#$80			; flag for garbage collected
04460    E1CE  85 60        	STA	Gclctd		; set garbage collected flag
04461    E1D0  68           	PLA				; pull length
04462    E1D1  D0 D0        	BNE	LAB_2117		; go try again (loop always, length should never be = $00)
04463    
04464    ; garbage collection routine
04465    
04466    LAB_GARB
04467    E1D3  A6 85        	LDX	Ememl			; get end of mem low byte
04468    E1D5  A5 86        	LDA	Ememh			; get end of mem high byte
04469    
04470    ; re-run routine from last ending
04471    
04472    LAB_214B
04473    E1D7  86 81        	STX	Sstorl		; set string storage low byte
04474    E1D9  85 82        	STA	Sstorh		; set string storage high byte
04475    E1DB  A0 00        	LDY	#$00			; clear index
04476    E1DD  84 9D        	STY	garb_h		; clear working pointer high byte (flag no strings to move)
04477    E1DF  A5 7F        	LDA	Earryl		; get array mem end low byte
04478    E1E1  A6 80        	LDX	Earryh		; get array mem end high byte
04479    E1E3  85 AA        	STA	Histrl		; save as highest string low byte
04480    E1E5  86 AB        	STX	Histrh		; save as highest string high byte
04481    E1E7  A9 68        	LDA	#des_sk		; set descriptor stack pointer
04482    E1E9  85 71        	STA	ut1_pl		; save descriptor stack pointer low byte
04483    E1EB  84 72        	STY	ut1_ph		; save descriptor stack pointer high byte ($00)
04484    LAB_2161
04485    E1ED  C5 65        	CMP	next_s		; compare with descriptor stack pointer
04486    E1EF  F0 05        	BEQ	LAB_216A		; branch if =
04487    
04488    E1F1  20 57 E2     	JSR	LAB_21D7		; go garbage collect descriptor stack
04489    E1F4  F0 F7        	BEQ	LAB_2161		; loop always
04490    
04491    					; done stacked strings, now do string vars
04492    LAB_216A
04493    E1F6  06 A0        	ASL	g_step		; set step size = $06
04494    E1F8  A5 7B        	LDA	Svarl			; get start of vars low byte
04495    E1FA  A6 7C        	LDX	Svarh			; get start of vars high byte
04496    E1FC  85 71        	STA	ut1_pl		; save as pointer low byte
04497    E1FE  86 72        	STX	ut1_ph		; save as pointer high byte
04498    LAB_2176
04499    E200  E4 7E        	CPX	Sarryh		; compare start of arrays high byte
04500    E202  D0 04        	BNE	LAB_217E		; branch if no high byte match
04501    
04502    E204  C5 7D        	CMP	Sarryl		; else compare start of arrays low byte
04503    E206  F0 05        	BEQ	LAB_2183		; branch if = var mem end
04504    
04505    LAB_217E
04506    E208  20 51 E2     	JSR	LAB_21D1		; go garbage collect strings
04507    E20B  F0 F3        	BEQ	LAB_2176		; loop always
04508    
04509    					; done string vars, now do string arrays
04510    LAB_2183
04511    E20D  85 A4        	STA	Nbendl		; save start of arrays low byte as working pointer
04512    E20F  86 A5        	STX	Nbendh		; save start of arrays high byte as working pointer
04513    E211  A9 04        	LDA	#$04			; set step size
04514    E213  85 A0        	STA	g_step		; save step size
04515    LAB_218B
04516    E215  A5 A4        	LDA	Nbendl		; get pointer low byte
04517    E217  A6 A5        	LDX	Nbendh		; get pointer high byte
04518    LAB_218F
04519    E219  E4 80        	CPX	Earryh		; compare with array mem end high byte
04520    E21B  D0 04        	BNE	LAB_219A		; branch if not at end
04521    
04522    E21D  C5 7F        	CMP	Earryl		; else compare with array mem end low byte
04523    E21F  F0 75        	BEQ	LAB_2216		; tidy up and exit if at end
04524    
04525    LAB_219A
04526    E221  85 71        	STA	ut1_pl		; save pointer low byte
04527    E223  86 72        	STX	ut1_ph		; save pointer high byte
04528    E225  A0 02        	LDY	#$02			; set index
04529    E227  B1 71        	LDA	(ut1_pl),Y		; get array size low byte
04530    E229  65 A4        	ADC	Nbendl		; add start of this array low byte
04531    E22B  85 A4        	STA	Nbendl		; save start of next array low byte
04532    E22D  C8           	INY				; increment index
04533    E22E  B1 71        	LDA	(ut1_pl),Y		; get array size high byte
04534    E230  65 A5        	ADC	Nbendh		; add start of this array high byte
04535    E232  85 A5        	STA	Nbendh		; save start of next array high byte
04536    E234  A0 01        	LDY	#$01			; set index
04537    E236  B1 71        	LDA	(ut1_pl),Y		; get name second byte
04538    E238  10 DB        	BPL	LAB_218B		; skip if not string array
04539    
04540    ; was string array so ..
04541    
04542    E23A  A0 04        	LDY	#$04			; set index
04543    E23C  B1 71        	LDA	(ut1_pl),Y		; get # of dimensions
04544    E23E  0A           	ASL				; *2
04545    E23F  69 05        	ADC	#$05			; +5 (array header size)
04546    E241  20 89 E2     	JSR	LAB_2208		; go set up for first element
04547    LAB_21C4
04548    E244  E4 A5        	CPX	Nbendh		; compare with start of next array high byte
04549    E246  D0 04        	BNE	LAB_21CC		; branch if <> (go do this array)
04550    
04551    E248  C5 A4        	CMP	Nbendl		; else compare element pointer low byte with next array
04552    					; low byte
04553    E24A  F0 CD        	BEQ	LAB_218F		; if equal then go do next array
04554    
04555    LAB_21CC
04556    E24C  20 57 E2     	JSR	LAB_21D7		; go defrag array strings
04557    E24F  F0 F3        	BEQ	LAB_21C4		; go do next array string (loop always)
04558    
04559    ; defrag string variables
04560    ; enter with XA = variable pointer
04561    ; return with XA = next variable pointer
04562    
04563    LAB_21D1
04564    E251  C8           	INY				; increment index (Y was $00)
04565    E252  B1 71        	LDA	(ut1_pl),Y		; get var name byte 2
04566    E254  10 30        	BPL	LAB_2206		; if not string, step pointer to next var and return
04567    
04568    E256  C8           	INY				; else increment index
04569    LAB_21D7
04570    E257  B1 71        	LDA	(ut1_pl),Y		; get string length
04571    E259  F0 2B        	BEQ	LAB_2206		; if null, step pointer to next string and return
04572    
04573    E25B  C8           	INY				; else increment index
04574    E25C  B1 71        	LDA	(ut1_pl),Y		; get string pointer low byte
04575    E25E  AA           	TAX				; copy to X
04576    E25F  C8           	INY				; increment index
04577    E260  B1 71        	LDA	(ut1_pl),Y		; get string pointer high byte
04578    E262  C5 82        	CMP	Sstorh		; compare bottom of string space high byte
04579    E264  90 06        	BCC	LAB_21EC		; branch if less
04580    
04581    E266  D0 1E        	BNE	LAB_2206		; if greater, step pointer to next string and return
04582    
04583    					; high bytes were = so compare low bytes
04584    E268  E4 81        	CPX	Sstorl		; compare bottom of string space low byte
04585    E26A  B0 1A        	BCS	LAB_2206		; if >=, step pointer to next string and return
04586    
04587    					; string pointer is < string storage pointer (pos in mem)
04588    LAB_21EC
04589    E26C  C5 AB        	CMP	Histrh		; compare to highest string high byte
04590    E26E  90 17        	BCC	LAB_2207		; if <, step pointer to next string and return
04591    
04592    E270  D0 04        	BNE	LAB_21F6		; if > update pointers, step to next and return
04593    
04594    					; high bytes were = so compare low bytes
04595    E272  E4 AA        	CPX	Histrl		; compare to highest string low byte
04596    E274  90 11        	BCC	LAB_2207		; if <, step pointer to next string and return
04597    
04598    					; string is in string memory space
04599    LAB_21F6
04600    E276  86 AA        	STX	Histrl		; save as new highest string low byte
04601    E278  85 AB        	STA	Histrh		; save as new highest string high byte
04602    E27A  A5 71        	LDA	ut1_pl		; get start of vars(descriptors) low byte
04603    E27C  A6 72        	LDX	ut1_ph		; get start of vars(descriptors) high byte
04604    E27E  85 9C        	STA	garb_l		; save as working pointer low byte
04605    E280  86 9D        	STX	garb_h		; save as working pointer high byte
04606    E282  88           	DEY				; decrement index DIFFERS
04607    E283  88           	DEY				; decrement index (should point to descriptor start)
04608    E284  84 A2        	STY	g_indx		; save index pointer
04609    
04610    					; step pointer to next string
04611    LAB_2206
04612    E286  18           	CLC				; clear carry for add
04613    LAB_2207
04614    E287  A5 A0        	LDA	g_step		; get step size
04615    LAB_2208
04616    E289  65 71        	ADC	ut1_pl		; add pointer low byte
04617    E28B  85 71        	STA	ut1_pl		; save pointer low byte
04618    E28D  90 02        	BCC	LAB_2211		; branch if no overflow
04619    
04620    E28F  E6 72        	INC	ut1_ph		; else increment high byte
04621    LAB_2211
04622    E291  A6 72        	LDX	ut1_ph		; get pointer high byte
04623    E293  A0 00        	LDY	#$00			; clear Y
04624    E295  60           	RTS
04625    
04626    ; search complete, now either exit or set-up and move string
04627    
04628    LAB_2216
04629    E296  C6 A0        	DEC	g_step		; decrement step size (now $03 for descriptor stack)
04630    E298  A6 9D        	LDX	garb_h		; get string to move high byte
04631    E29A  F0 F5        	BEQ	LAB_2211		; exit if nothing to move
04632    
04633    E29C  A4 A2        	LDY	g_indx		; get index byte back (points to descriptor)
04634    E29E  18           	CLC				; clear carry for add
04635    E29F  B1 9C        	LDA	(garb_l),Y		; get string length
04636    E2A1  65 AA        	ADC	Histrl		; add highest string low byte
04637    E2A3  85 A6        	STA	Obendl		; save old block end low pointer
04638    E2A5  A5 AB        	LDA	Histrh		; get highest string high byte
04639    E2A7  69 00        	ADC	#$00			; add any carry
04640    E2A9  85 A7        	STA	Obendh		; save old block end high byte
04641    E2AB  A5 81        	LDA	Sstorl		; get bottom of string space low byte
04642    E2AD  A6 82        	LDX	Sstorh		; get bottom of string space high byte
04643    E2AF  85 A4        	STA	Nbendl		; save new block end low byte
04644    E2B1  86 A5        	STX	Nbendh		; save new block end high byte
04645    E2B3  20 BA D0     	JSR	LAB_11D6		; open up space in memory, don't set array end
04646    E2B6  A4 A2        	LDY	g_indx		; get index byte
04647    E2B8  C8           	INY				; point to descriptor low byte
04648    E2B9  A5 A4        	LDA	Nbendl		; get string pointer low byte
04649    E2BB  91 9C        	STA	(garb_l),Y		; save new string pointer low byte
04650    E2BD  AA           	TAX				; copy string pointer low byte
04651    E2BE  E6 A5        	INC	Nbendh		; correct high byte (move sets high byte -1)
04652    E2C0  A5 A5        	LDA	Nbendh		; get new string pointer high byte
04653    E2C2  C8           	INY				; point to descriptor high byte
04654    E2C3  91 9C        	STA	(garb_l),Y		; save new string pointer high byte
04655    E2C5  4C D7 E1     	JMP	LAB_214B		; re-run routine from last ending
04656    					; (but don't collect this string)
04657    
04658    ; concatenate
04659    ; add strings, string 1 is in descriptor des_pl, string 2 is in line
04660    
04661    LAB_224D
04662    E2C8  A5 AF        	LDA	des_ph		; get descriptor pointer high byte
04663    E2CA  48           	PHA				; put on stack
04664    E2CB  A5 AE        	LDA	des_pl		; get descriptor pointer low byte
04665    E2CD  48           	PHA				; put on stack
04666    E2CE  20 C1 DB     	JSR	LAB_GVAL		; get value from line
04667    E2D1  20 C6 DA     	JSR	LAB_CTST		; check if source is string, else do type mismatch
04668    E2D4  68           	PLA				; get descriptor pointer low byte back
04669    E2D5  85 B8        	STA	ssptr_l		; set pointer low byte
04670    E2D7  68           	PLA				; get descriptor pointer high byte back
04671    E2D8  85 B9        	STA	ssptr_h		; set pointer high byte
04672    E2DA  A0 00        	LDY	#$00			; clear index
04673    E2DC  B1 B8        	LDA	(ssptr_l),Y		; get length_1 from descriptor
04674    E2DE  18           	CLC				; clear carry for add
04675    E2DF  71 AE        	ADC	(des_pl),Y		; add length_2
04676    E2E1  90 05        	BCC	LAB_226D		; branch if no overflow
04677    
04678    E2E3  A2 1A        	LDX	#$1A			; else set error code $1A ("String too long" error)
04679    E2E5  4C 2E D1     	JMP	LAB_XERR		; do error #X, then warm start
04680    
04681    LAB_226D
04682    E2E8  20 26 E1     	JSR	LAB_209C		; copy des_pl/h to des_2l/h and make string space A bytes
04683    					; long
04684    E2EB  20 05 E3     	JSR	LAB_228A		; copy string from descriptor (sdescr) to (Sutill)
04685    E2EE  A5 9E        	LDA	des_2l		; get descriptor pointer low byte
04686    E2F0  A4 9F        	LDY	des_2h		; get descriptor pointer high byte
04687    E2F2  20 36 E3     	JSR	LAB_22BA		; pop (YA) descriptor off stack or from top of string space
04688    					; returns with A = length, ut1_pl = pointer low byte,
04689    					; ut1_ph = pointer high byte
04690    E2F5  20 17 E3     	JSR	LAB_229C		; store string A bytes long from (ut1_pl) to (Sutill)
04691    E2F8  A5 B8        	LDA	ssptr_l		;.set descriptor pointer low byte
04692    E2FA  A4 B9        	LDY	ssptr_h		;.set descriptor pointer high byte
04693    E2FC  20 36 E3     	JSR	LAB_22BA		; pop (YA) descriptor off stack or from top of string space
04694    					; returns with A = length, X=ut1_pl=pointer low byte,
04695    					; Y=ut1_ph=pointer high byte
04696    E2FF  20 79 E1     	JSR	LAB_RTST		; check for space on descriptor stack then put string
04697    					; address and length on descriptor stack and update stack
04698    					; pointers
04699    E302  4C EC DA     	JMP	LAB_1ADB		;.continue evaluation
04700    
04701    ; copy string from descriptor (sdescr) to (Sutill)
04702    
04703    LAB_228A
04704    E305  A0 00        	LDY	#$00			; clear index
04705    E307  B1 B8        	LDA	(sdescr),Y		; get string length
04706    E309  48           	PHA				; save on stack
04707    E30A  C8           	INY				; increment index
04708    E30B  B1 B8        	LDA	(sdescr),Y		; get source string pointer low byte
04709    E30D  AA           	TAX				; copy to X
04710    E30E  C8           	INY				; increment index
04711    E30F  B1 B8        	LDA	(sdescr),Y		; get source string pointer high byte
04712    E311  A8           	TAY				; copy to Y
04713    E312  68           	PLA				; get length back
04714    
04715    ; store string A bytes long from YX to (Sutill)
04716    
04717    LAB_2298
04718    E313  86 71        	STX	ut1_pl		; save source string pointer low byte
04719    E315  84 72        	STY	ut1_ph		; save source string pointer high byte
04720    
04721    ; store string A bytes long from (ut1_pl) to (Sutill)
04722    
04723    LAB_229C
04724    E317  AA           	TAX				; copy length to index (don't count with Y)
04725    E318  F0 14        	BEQ	LAB_22B2		; branch if = $0 (null string) no need to add zero length
04726    
04727    E31A  A0 00        	LDY	#$00			; zero pointer (copy forward)
04728    LAB_22A0
04729    E31C  B1 71        	LDA	(ut1_pl),Y		; get source byte
04730    E31E  91 83        	STA	(Sutill),Y		; save destination byte
04731    
04732    E320  C8           	INY				; increment index
04733    E321  CA           	DEX				; decrement counter
04734    E322  D0 F8        	BNE	LAB_22A0		; loop while <> 0
04735    
04736    E324  98           	TYA				; restore length from Y
04737    LAB_22A9
04738    E325  18           	CLC				; clear carry for add
04739    E326  65 83        	ADC	Sutill		; add string utility ptr low byte
04740    E328  85 83        	STA	Sutill		; save string utility ptr low byte
04741    E32A  90 02        	BCC	LAB_22B2		; branch if no carry
04742    
04743    E32C  E6 84        	INC	Sutilh		; else increment string utility ptr high byte
04744    LAB_22B2
04745    E32E  60           	RTS
04746    
04747    ; evaluate string
04748    
04749    LAB_EVST
04750    E32F  20 C6 DA     	JSR	LAB_CTST		; check if source is string, else do type mismatch
04751    
04752    ; pop string off descriptor stack, or from top of string space
04753    ; returns with A = length, X=pointer low byte, Y=pointer high byte
04754    
04755    LAB_22B6
04756    E332  A5 AE        	LDA	des_pl		; get descriptor pointer low byte
04757    E334  A4 AF        	LDY	des_ph		; get descriptor pointer high byte
04758    
04759    ; pop (YA) descriptor off stack or from top of string space
04760    ; returns with A = length, X=ut1_pl=pointer low byte, Y=ut1_ph=pointer high byte
04761    
04762    LAB_22BA
04763    E336  85 71        	STA	ut1_pl		; save descriptor pointer low byte
04764    E338  84 72        	STY	ut1_ph		; save descriptor pointer high byte
04765    E33A  20 67 E3     	JSR	LAB_22EB		; clean descriptor stack, YA = pointer
04766    E33D  08           	PHP				; save status flags
04767    E33E  A0 00        	LDY	#$00			; clear index
04768    E340  B1 71        	LDA	(ut1_pl),Y		; get length from string descriptor
04769    E342  48           	PHA				; put on stack
04770    E343  C8           	INY				; increment index
04771    E344  B1 71        	LDA	(ut1_pl),Y		; get string pointer low byte from descriptor
04772    E346  AA           	TAX				; copy to X
04773    E347  C8           	INY				; increment index
04774    E348  B1 71        	LDA	(ut1_pl),Y		; get string pointer high byte from descriptor
04775    E34A  A8           	TAY				; copy to Y
04776    E34B  68           	PLA				; get string length back
04777    E34C  28           	PLP				; restore status
04778    E34D  D0 13        	BNE	LAB_22E6		; branch if pointer <> last_sl,last_sh
04779    
04780    E34F  C4 82        	CPY	Sstorh		; compare bottom of string space high byte
04781    E351  D0 0F        	BNE	LAB_22E6		; branch if <>
04782    
04783    E353  E4 81        	CPX	Sstorl		; else compare bottom of string space low byte
04784    E355  D0 0B        	BNE	LAB_22E6		; branch if <>
04785    
04786    E357  48           	PHA				; save string length
04787    E358  18           	CLC				; clear carry for add
04788    E359  65 81        	ADC	Sstorl		; add bottom of string space low byte
04789    E35B  85 81        	STA	Sstorl		; save bottom of string space low byte
04790    E35D  90 02        	BCC	LAB_22E5		; skip increment if no overflow
04791    
04792    E35F  E6 82        	INC	Sstorh		; increment bottom of string space high byte
04793    LAB_22E5
04794    E361  68           	PLA				; restore string length
04795    LAB_22E6
04796    E362  86 71        	STX	ut1_pl		; save string pointer low byte
04797    E364  84 72        	STY	ut1_ph		; save string pointer high byte
04798    E366  60           	RTS
04799    
04800    ; clean descriptor stack, YA = pointer
04801    ; checks if AY is on the descriptor stack, if so does a stack discard
04802    
04803    LAB_22EB
04804    E367  C4 67        	CPY	last_sh		; compare pointer high byte
04805    E369  D0 0C        	BNE	LAB_22FB		; exit if <>
04806    
04807    E36B  C5 66        	CMP	last_sl		; compare pointer low byte
04808    E36D  D0 08        	BNE	LAB_22FB		; exit if <>
04809    
04810    E36F  85 65        	STA	next_s		; save descriptor stack pointer
04811    E371  E9 03        	SBC	#$03			; -3
04812    E373  85 66        	STA	last_sl		; save low byte -3
04813    E375  A0 00        	LDY	#$00			; clear high byte
04814    LAB_22FB
04815    E377  60           	RTS
04816    
04817    ; perform CHR$()
04818    
04819    LAB_CHRS
04820    E378  20 83 E4     	JSR	LAB_EVBY		; evaluate byte expression, result in X
04821    E37B  8A           	TXA				; copy to A
04822    E37C  48           	PHA				; save character
04823    E37D  A9 01        	LDA	#$01			; string is single byte
04824    E37F  20 2E E1     	JSR	LAB_MSSP		; make string space A bytes long A=$AC=length,
04825    					; X=$AD=Sutill=ptr low byte, Y=$AE=Sutilh=ptr high byte
04826    E382  68           	PLA				; get character back
04827    E383  A0 00        	LDY	#$00			; clear index
04828    E385  91 AD        	STA	(str_pl),Y		; save byte in string (byte IS string!)
04829    E387  4C 79 E1     	JMP	LAB_RTST		; check for space on descriptor stack then put string
04830    					; address and length on descriptor stack and update stack
04831    					; pointers
04832    
04833    ; perform LEFT$()
04834    
04835    LAB_LEFT
04836    E38A  48           	PHA				; push byte parameter
04837    E38B  20 EB E3     	JSR	LAB_236F		; pull string data and byte parameter from stack
04838    					; return pointer in des_2l/h, byte in A (and X), Y=0
04839    E38E  D1 9E        	CMP	(des_2l),Y		; compare byte parameter with string length
04840    E390  98           	TYA				; clear A
04841    E391  F0 09        	BEQ	LAB_2316		; go do string copy (branch always)
04842    
04843    ; perform RIGHT$()
04844    
04845    LAB_RIGHT
04846    E393  48           	PHA				; push byte parameter
04847    E394  20 EB E3     	JSR	LAB_236F		; pull string data and byte parameter from stack
04848    					; return pointer in des_2l/h, byte in A (and X), Y=0
04849    E397  18           	CLC				; clear carry for add-1
04850    E398  F1 9E        	SBC	(des_2l),Y		; subtract string length
04851    E39A  49 FF        	EOR	#$FF			; invert it (A=LEN(expression$)-l)
04852    
04853    LAB_2316
04854    E39C  90 04        	BCC	LAB_231C		; branch if string length > byte parameter
04855    
04856    E39E  B1 9E        	LDA	(des_2l),Y		; else make parameter = length
04857    E3A0  AA           	TAX				; copy to byte parameter copy
04858    E3A1  98           	TYA				; clear string start offset
04859    LAB_231C
04860    E3A2  48           	PHA				; save string start offset
04861    LAB_231D
04862    E3A3  8A           	TXA				; copy byte parameter (or string length if <)
04863    LAB_231E
04864    E3A4  48           	PHA				; save string length
04865    E3A5  20 2E E1     	JSR	LAB_MSSP		; make string space A bytes long A=$AC=length,
04866    					; X=$AD=Sutill=ptr low byte, Y=$AE=Sutilh=ptr high byte
04867    E3A8  A5 9E        	LDA	des_2l		; get descriptor pointer low byte
04868    E3AA  A4 9F        	LDY	des_2h		; get descriptor pointer high byte
04869    E3AC  20 36 E3     	JSR	LAB_22BA		; pop (YA) descriptor off stack or from top of string space
04870    					; returns with A = length, X=ut1_pl=pointer low byte,
04871    					; Y=ut1_ph=pointer high byte
04872    E3AF  68           	PLA				; get string length back
04873    E3B0  A8           	TAY				; copy length to Y
04874    E3B1  68           	PLA				; get string start offset back
04875    E3B2  18           	CLC				; clear carry for add
04876    E3B3  65 71        	ADC	ut1_pl		; add start offset to string start pointer low byte
04877    E3B5  85 71        	STA	ut1_pl		; save string start pointer low byte
04878    E3B7  90 02        	BCC	LAB_2335		; branch if no overflow
04879    
04880    E3B9  E6 72        	INC	ut1_ph		; else increment string start pointer high byte
04881    LAB_2335
04882    E3BB  98           	TYA				; copy length to A
04883    E3BC  20 17 E3     	JSR	LAB_229C		; store string A bytes long from (ut1_pl) to (Sutill)
04884    E3BF  4C 79 E1     	JMP	LAB_RTST		; check for space on descriptor stack then put string
04885    					; address and length on descriptor stack and update stack
04886    					; pointers
04887    
04888    ; perform MID$()
04889    
04890    LAB_MIDS
04891    E3C2  48           	PHA				; push byte parameter
04892    E3C3  A9 FF        	LDA	#$FF			; set default length = 255
04893    E3C5  85 AF        	STA	mids_l		; save default length
04894    E3C7  20 C2 00     	JSR	LAB_GBYT		; scan memory
04895    E3CA  C9 29        	CMP	#')'			; compare with ")"
04896    E3CC  F0 06        	BEQ	LAB_2358		; branch if = ")" (skip second byte get)
04897    
04898    E3CE  20 F2 DB     	JSR	LAB_1C01		; scan for "," , else do syntax error then warm start
04899    E3D1  20 80 E4     	JSR	LAB_GTBY		; get byte parameter (use copy in mids_l)
04900    LAB_2358
04901    E3D4  20 EB E3     	JSR	LAB_236F		; pull string data and byte parameter from stack
04902    					; return pointer in des_2l/h, byte in A (and X), Y=0
04903    E3D7  CA           	DEX				; decrement start index
04904    E3D8  8A           	TXA				; copy to A
04905    E3D9  48           	PHA				; save string start offset
04906    E3DA  18           	CLC				; clear carry for sub-1
04907    E3DB  A2 00        	LDX	#$00			; clear output string length
04908    E3DD  F1 9E        	SBC	(des_2l),Y		; subtract string length
04909    E3DF  B0 C2        	BCS	LAB_231D		; if start>string length go do null string
04910    
04911    E3E1  49 FF        	EOR	#$FF			; complement -length
04912    E3E3  C5 AF        	CMP	mids_l		; compare byte parameter
04913    E3E5  90 BD        	BCC	LAB_231E		; if length>remaining string go do RIGHT$
04914    
04915    E3E7  A5 AF        	LDA	mids_l		; get length byte
04916    E3E9  B0 B9        	BCS	LAB_231E		; go do string copy (branch always)
04917    
04918    ; pull string data and byte parameter from stack
04919    ; return pointer in des_2l/h, byte in A (and X), Y=0
04920    
04921    LAB_236F
04922    E3EB  20 E3 DB     	JSR	LAB_1BFB		; scan for ")" , else do syntax error then warm start
04923    E3EE  68           	PLA				; pull return address low byte (return address)
04924    E3EF  85 A2        	STA	Fnxjpl		; save functions jump vector low byte
04925    E3F1  68           	PLA				; pull return address high byte (return address)
04926    E3F2  85 A3        	STA	Fnxjph		; save functions jump vector high byte
04927    E3F4  68           	PLA				; pull byte parameter
04928    E3F5  AA           	TAX				; copy byte parameter to X
04929    E3F6  68           	PLA				; pull string pointer low byte
04930    E3F7  85 9E        	STA	des_2l		; save it
04931    E3F9  68           	PLA				; pull string pointer high byte
04932    E3FA  85 9F        	STA	des_2h		; save it
04933    E3FC  A0 00        	LDY	#$00			; clear index
04934    E3FE  8A           	TXA				; copy byte parameter
04935    E3FF  F0 79        	BEQ	LAB_23A8		; if null do function call error then warm start
04936    
04937    E401  E6 A2        	INC	Fnxjpl		; increment function jump vector low byte
04938    					; (JSR pushes return addr-1. this is all very nice
04939    					; but will go tits up if either call is on a page
04940    					; boundary!)
04941    E403  6C A2 00     	JMP	(Fnxjpl)		; in effect, RTS
04942    
04943    ; perform LCASE$()
04944    
04945    LAB_LCASE
04946    E406  20 2F E3     	JSR	LAB_EVST		; evaluate string
04947    E409  85 AC        	STA	str_ln		; set string length
04948    E40B  A8           	TAY				; copy length to Y
04949    E40C  F0 38        	BEQ	NoString		; branch if null string
04950    
04951    E40E  20 2E E1     	JSR	LAB_MSSP		; make string space A bytes long A=length,
04952    					; X=Sutill=ptr low byte, Y=Sutilh=ptr high byte
04953    E411  86 AD        	STX	str_pl		; save string pointer low byte
04954    E413  84 AE        	STY	str_ph		; save string pointer high byte
04955    E415  A8           	TAY				; get string length back
04956    
04957    LC_loop
04958    E416  88           	DEY				; decrement index
04959    E417  B1 71        	LDA	(ut1_pl),Y		; get byte from string
04960    E419  20 16 DE     	JSR	LAB_1D82		; is character "A" to "Z"
04961    E41C  90 02        	BCC	NoUcase		; branch if not upper case alpha
04962    
04963    E41E  09 20        	ORA	#$20			; convert upper to lower case
04964    NoUcase
04965    E420  91 83        	STA	(Sutill),Y		; save byte back to string
04966    E422  98           	TYA				; test index
04967    E423  D0 F1        	BNE	LC_loop		; loop if not all done
04968    
04969    E425  F0 1F        	BEQ	NoString		; tidy up and exit, branch always
04970    
04971    ; perform UCASE$()
04972    
04973    LAB_UCASE
04974    E427  20 2F E3     	JSR	LAB_EVST		; evaluate string
04975    E42A  85 AC        	STA	str_ln		; set string length
04976    E42C  A8           	TAY				; copy length to Y
04977    E42D  F0 17        	BEQ	NoString		; branch if null string
04978    
04979    E42F  20 2E E1     	JSR	LAB_MSSP		; make string space A bytes long A=length,
04980    					; X=Sutill=ptr low byte, Y=Sutilh=ptr high byte
04981    E432  86 AD        	STX	str_pl		; save string pointer low byte
04982    E434  84 AE        	STY	str_ph		; save string pointer high byte
04983    E436  A8           	TAY				; get string length back
04984    
04985    UC_loop
04986    E437  88           	DEY				; decrement index
04987    E438  B1 71        	LDA	(ut1_pl),Y		; get byte from string
04988    E43A  20 12 DE     	JSR	LAB_CASC		; is character "a" to "z" (or "A" to "Z")
04989    E43D  90 02        	BCC	NoLcase		; branch if not alpha
04990    
04991    E43F  29 DF        	AND	#$DF			; convert lower to upper case
04992    NoLcase
04993    E441  91 83        	STA	(Sutill),Y		; save byte back to string
04994    E443  98           	TYA				; test index
04995    E444  D0 F1        	BNE	UC_loop		; loop if not all done
04996    
04997    NoString
04998    E446  4C 79 E1     	JMP	LAB_RTST		; check for space on descriptor stack then put string
04999    					; address and length on descriptor stack and update stack
05000    					; pointers
05001    
05002    ; perform SADD()
05003    
05004    LAB_SADD
05005    E449  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory
05006    E44C  20 9E DD     	JSR	LAB_GVAR		; get var address
05007    
05008    E44F  20 E3 DB     	JSR	LAB_1BFB		; scan for ")", else do syntax error then warm start
05009    E452  20 C6 DA     	JSR	LAB_CTST		; check if source is string, else do type mismatch
05010    
05011    E455  A0 02        	LDY	#$02			; index to string pointer high byte
05012    E457  B1 95        	LDA	(Cvaral),Y		; get string pointer high byte
05013    E459  AA           	TAX				; copy string pointer high byte to X
05014    E45A  88           	DEY				; index to string pointer low byte
05015    E45B  B1 95        	LDA	(Cvaral),Y		; get string pointer low byte
05016    E45D  A8           	TAY				; copy string pointer low byte to Y
05017    E45E  8A           	TXA				; copy string pointer high byte to A
05018    E45F  4C 4D E0     	JMP	LAB_AYFC		; save and convert integer AY to FAC1 and return
05019    
05020    ; perform LEN()
05021    
05022    LAB_LENS
05023    E462  20 68 E4     	JSR	LAB_ESGL		; evaluate string, get length in A (and Y)
05024    E465  4C 5A E0     	JMP	LAB_1FD0		; convert Y to byte in FAC1 and return
05025    
05026    ; evaluate string, get length in Y
05027    
05028    LAB_ESGL
05029    E468  20 2F E3     	JSR	LAB_EVST		; evaluate string
05030    E46B  A8           	TAY				; copy length to Y
05031    E46C  60           	RTS
05032    
05033    ; perform ASC()
05034    
05035    LAB_ASC
05036    E46D  20 68 E4     	JSR	LAB_ESGL		; evaluate string, get length in A (and Y)
05037    E470  F0 08        	BEQ	LAB_23A8		; if null do function call error then warm start
05038    
05039    E472  A0 00        	LDY	#$00			; set index to first character
05040    E474  B1 71        	LDA	(ut1_pl),Y		; get byte
05041    E476  A8           	TAY				; copy to Y
05042    E477  4C 5A E0     	JMP	LAB_1FD0		; convert Y to byte in FAC1 and return
05043    
05044    ; do function call error then warm start
05045    
05046    LAB_23A8
05047    E47A  4C 1D DF     	JMP	LAB_FCER		; do function call error then warm start
05048    
05049    ; scan and get byte parameter
05050    
05051    LAB_SGBY
05052    E47D  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory
05053    
05054    ; get byte parameter
05055    
05056    LAB_GTBY
05057    E480  20 C1 DA     	JSR	LAB_EVNM		; evaluate expression and check is numeric,
05058    					; else do type mismatch
05059    
05060    ; evaluate byte expression, result in X
05061    
05062    LAB_EVBY
05063    E483  20 96 DE     	JSR	LAB_EVPI		; evaluate integer expression (no check)
05064    
05065    E486  A4 AE        	LDY	FAC1_2		; get FAC1 mantissa2
05066    E488  D0 F0        	BNE	LAB_23A8		; if top byte <> 0 do function call error then warm start
05067    
05068    E48A  A6 AF        	LDX	FAC1_3		; get FAC1 mantissa3
05069    E48C  4C C2 00     	JMP	LAB_GBYT		; scan memory and return
05070    
05071    ; perform VAL()
05072    
05073    LAB_VAL
05074    E48F  20 68 E4     	JSR	LAB_ESGL		; evaluate string, get length in A (and Y)
05075    E492  D0 03        	BNE	LAB_23C5		; branch if not null string
05076    
05077    					; string was null so set result = $00
05078    E494  4C 44 E6     	JMP	LAB_24F1		; clear FAC1 exponent and sign and return
05079    
05080    LAB_23C5
05081    E497  A6 C3        	LDX	Bpntrl		; get BASIC execute pointer low byte
05082    E499  A4 C4        	LDY	Bpntrh		; get BASIC execute pointer high byte
05083    E49B  86 BA        	STX	Btmpl			; save BASIC execute pointer low byte
05084    E49D  84 BB        	STY	Btmph			; save BASIC execute pointer high byte
05085    E49F  A6 71        	LDX	ut1_pl		; get string pointer low byte
05086    E4A1  86 C3        	STX	Bpntrl		; save as BASIC execute pointer low byte
05087    E4A3  18           	CLC				; clear carry
05088    E4A4  65 71        	ADC	ut1_pl		; add string length
05089    E4A6  85 73        	STA	ut2_pl		; save string end low byte
05090    E4A8  A5 72        	LDA	ut1_ph		; get string pointer high byte
05091    E4AA  85 C4        	STA	Bpntrh		; save as BASIC execute pointer high byte
05092    E4AC  69 00        	ADC	#$00			; add carry to high byte
05093    E4AE  85 74        	STA	ut2_ph		; save string end high byte
05094    E4B0  A0 00        	LDY	#$00			; set index to $00
05095    E4B2  B1 73        	LDA	(ut2_pl),Y		; get string end +1 byte
05096    E4B4  48           	PHA				; push it
05097    E4B5  98           	TYA				; clear A
05098    E4B6  91 73        	STA	(ut2_pl),Y		; terminate string with $00
05099    E4B8  20 C2 00     	JSR	LAB_GBYT		; scan memory
05100    E4BB  20 9A E9     	JSR	LAB_2887		; get FAC1 from string
05101    E4BE  68           	PLA				; restore string end +1 byte
05102    E4BF  A0 00        	LDY	#$00			; set index to zero
05103    E4C1  91 73        	STA	(ut2_pl),Y		; put string end byte back
05104    
05105    ; restore BASIC execute pointer from temp (Btmpl/Btmph)
05106    
05107    LAB_23F3
05108    E4C3  A6 BA        	LDX	Btmpl			; get BASIC execute pointer low byte back
05109    E4C5  A4 BB        	LDY	Btmph			; get BASIC execute pointer high byte back
05110    E4C7  86 C3        	STX	Bpntrl		; save BASIC execute pointer low byte
05111    E4C9  84 C4        	STY	Bpntrh		; save BASIC execute pointer high byte
05112    E4CB  60           	RTS
05113    
05114    ; get two parameters for POKE or WAIT
05115    
05116    LAB_GADB
05117    E4CC  20 C1 DA     	JSR	LAB_EVNM		; evaluate expression and check is numeric,
05118    					; else do type mismatch
05119    E4CF  20 E5 E4     	JSR	LAB_F2FX		; save integer part of FAC1 in temporary integer
05120    
05121    ; scan for "," and get byte, else do Syntax error then warm start
05122    
05123    LAB_SCGB
05124    E4D2  20 F2 DB     	JSR	LAB_1C01		; scan for "," , else do syntax error then warm start
05125    E4D5  A5 12        	LDA	Itemph		; save temporary integer high byte
05126    E4D7  48           	PHA				; on stack
05127    E4D8  A5 11        	LDA	Itempl		; save temporary integer low byte
05128    E4DA  48           	PHA				; on stack
05129    E4DB  20 80 E4     	JSR	LAB_GTBY		; get byte parameter
05130    E4DE  68           	PLA				; pull low byte
05131    E4DF  85 11        	STA	Itempl		; restore temporary integer low byte
05132    E4E1  68           	PLA				; pull high byte
05133    E4E2  85 12        	STA	Itemph		; restore temporary integer high byte
05134    E4E4  60           	RTS
05135    
05136    ; convert float to fixed routine. accepts any value that fits in 24 bits, +ve or
05137    ; -ve and converts it into a right truncated integer in Itempl and Itemph
05138    
05139    ; save unsigned 16 bit integer part of FAC1 in temporary integer
05140    
05141    LAB_F2FX
05142    E4E5  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
05143    E4E7  C9 98        	CMP	#$98			; compare with exponent = 2^24
05144    E4E9  B0 8F        	BCS	LAB_23A8		; if >= do function call error then warm start
05145    
05146    LAB_F2FU
05147    E4EB  20 44 E9     	JSR	LAB_2831		; convert FAC1 floating-to-fixed
05148    E4EE  A5 AE        	LDA	FAC1_2		; get FAC1 mantissa2
05149    E4F0  A4 AF        	LDY	FAC1_3		; get FAC1 mantissa3
05150    E4F2  84 11        	STY	Itempl		; save temporary integer low byte
05151    E4F4  85 12        	STA	Itemph		; save temporary integer high byte
05152    E4F6  60           	RTS
05153    
05154    ; perform PEEK()
05155    
05156    LAB_PEEK
05157    E4F7  20 E5 E4     	JSR	LAB_F2FX		; save integer part of FAC1 in temporary integer
05158    E4FA  A2 00        	LDX	#$00			; clear index
05159    E4FC  A1 11        	LDA	(Itempl,X)		; get byte via temporary integer (addr)
05160    E4FE  A8           	TAY				; copy byte to Y
05161    E4FF  4C 5A E0     	JMP	LAB_1FD0		; convert Y to byte in FAC1 and return
05162    
05163    ; perform POKE
05164    
05165    LAB_POKE
05166    E502  20 CC E4     	JSR	LAB_GADB		; get two parameters for POKE or WAIT
05167    E505  8A           	TXA				; copy byte argument to A
05168    E506  A2 00        	LDX	#$00			; clear index
05169    E508  81 11        	STA	(Itempl,X)		; save byte via temporary integer (addr)
05170    E50A  60           	RTS
05171    
05172    ; perform DEEK()
05173    
05174    LAB_DEEK
05175    E50B  20 E5 E4     	JSR	LAB_F2FX		; save integer part of FAC1 in temporary integer
05176    E50E  A2 00        	LDX	#$00			; clear index
05177    E510  A1 11        	LDA	(Itempl,X)		; PEEK low byte
05178    E512  A8           	TAY				; copy to Y
05179    E513  E6 11        	INC	Itempl		; increment pointer low byte
05180    E515  D0 02        	BNE	Deekh			; skip high increment if no rollover
05181    
05182    E517  E6 12        	INC	Itemph		; increment pointer high byte
05183    Deekh
05184    E519  A1 11        	LDA	(Itempl,X)		; PEEK high byte
05185    E51B  4C 4D E0     	JMP	LAB_AYFC		; save and convert integer AY to FAC1 and return
05186    
05187    ; perform DOKE
05188    
05189    LAB_DOKE
05190    E51E  20 C1 DA     	JSR	LAB_EVNM		; evaluate expression and check is numeric,
05191    					; else do type mismatch
05192    E521  20 E5 E4     	JSR	LAB_F2FX		; convert floating-to-fixed
05193    
05194    E524  84 97        	STY	Frnxtl		; save pointer low byte (float to fixed returns word in AY)
05195    E526  85 98        	STA	Frnxth		; save pointer high byte
05196    
05197    E528  20 F2 DB     	JSR	LAB_1C01		; scan for "," , else do syntax error then warm start
05198    E52B  20 C1 DA     	JSR	LAB_EVNM		; evaluate expression and check is numeric,
05199    					; else do type mismatch
05200    E52E  20 E5 E4     	JSR	LAB_F2FX		; convert floating-to-fixed
05201    
05202    E531  98           	TYA				; copy value low byte (float to fixed returns word in AY)
05203    E532  A2 00        	LDX	#$00			; clear index
05204    E534  81 97        	STA	(Frnxtl,X)		; POKE low byte
05205    E536  E6 97        	INC	Frnxtl		; increment pointer low byte
05206    E538  D0 02        	BNE	Dokeh			; skip high increment if no rollover
05207    
05208    E53A  E6 98        	INC	Frnxth		; increment pointer high byte
05209    Dokeh
05210    E53C  A5 12        	LDA	Itemph		; get value high byte
05211    E53E  81 97        	STA	(Frnxtl,X)		; POKE high byte
05212    E540  4C C2 00     	JMP	LAB_GBYT		; scan memory and return
05213    
05214    ; perform SWAP
05215    
05216    LAB_SWAP
05217    E543  20 9E DD     	JSR	LAB_GVAR		; get var1 address
05218    E546  85 97        	STA	Lvarpl		; save var1 address low byte
05219    E548  84 98        	STY	Lvarph		; save var1 address high byte
05220    E54A  A5 5F        	LDA	Dtypef		; get data type flag, $FF=string, $00=numeric
05221    E54C  48           	PHA				; save data type flag
05222    
05223    E54D  20 F2 DB     	JSR	LAB_1C01		; scan for "," , else do syntax error then warm start
05224    E550  20 9E DD     	JSR	LAB_GVAR		; get var2 address (pointer in Cvaral/h)
05225    E553  68           	PLA				; pull var1 data type flag
05226    E554  45 5F        	EOR	Dtypef		; compare with var2 data type
05227    E556  10 10        	BPL	SwapErr		; exit if not both the same type
05228    
05229    E558  A0 03        	LDY	#$03			; four bytes to swap (either value or descriptor+1)
05230    SwapLp
05231    E55A  B1 97        	LDA	(Lvarpl),Y		; get byte from var1
05232    E55C  AA           	TAX				; save var1 byte
05233    E55D  B1 95        	LDA	(Cvaral),Y		; get byte from var2
05234    E55F  91 97        	STA	(Lvarpl),Y		; save byte to var1
05235    E561  8A           	TXA				; restore var1 byte
05236    E562  91 95        	STA	(Cvaral),Y		; save byte to var2
05237    E564  88           	DEY				; decrement index
05238    E565  10 F3        	BPL	SwapLp		; loop until done
05239    
05240    E567  60           	RTS
05241    
05242    SwapErr
05243    E568  4C D0 DA     	JMP	LAB_1ABC		; do "Type mismatch" error then warm start
05244    
05245    ; perform CALL
05246    
05247    LAB_CALL
05248    E56B  20 C1 DA     	JSR	LAB_EVNM		; evaluate expression and check is numeric,
05249    					; else do type mismatch
05250    E56E  20 E5 E4     	JSR	LAB_F2FX		; convert floating-to-fixed
05251    E571  A9 E5        	LDA	#>CallExit		; set return address high byte
05252    E573  48           	PHA				; put on stack
05253    E574  A9 79        	LDA	#<CallExit-1	; set return address low byte
05254    E576  48           	PHA				; put on stack
05255    E577  6C 11 00     	JMP	(Itempl)		; do indirect jump to user routine
05256    
05257    ; if the called routine exits correctly then it will return to here. this will then get
05258    ; the next byte for the interpreter and return
05259    
05260    CallExit
05261    E57A  4C C2 00     	JMP	LAB_GBYT		; scan memory and return
05262    
05263    ; perform WAIT
05264    
05265    LAB_WAIT
05266    E57D  20 CC E4     	JSR	LAB_GADB		; get two parameters for POKE or WAIT
05267    E580  86 97        	STX	Frnxtl		; save byte
05268    E582  A2 00        	LDX	#$00			; clear mask
05269    E584  20 C2 00     	JSR	LAB_GBYT		; scan memory
05270    E587  F0 03        	BEQ	LAB_2441		; skip if no third argument
05271    
05272    E589  20 D2 E4     	JSR	LAB_SCGB		; scan for "," and get byte, else SN error then warm start
05273    LAB_2441
05274    E58C  86 98        	STX	Frnxth		; save EOR argument
05275    LAB_2445
05276    E58E  B1 11        	LDA	(Itempl),Y		; get byte via temporary integer (addr)
05277    E590  45 98        	EOR	Frnxth		; EOR with second argument (mask)
05278    E592  25 97        	AND	Frnxtl		; AND with first argument (byte)
05279    E594  F0 F8        	BEQ	LAB_2445		; loop if result is zero
05280    
05281    LAB_244D
05282    E596  60           	RTS
05283    
05284    ; perform subtraction, FAC1 from (AY)
05285    
05286    LAB_2455
05287    E597  20 7F E7     	JSR	LAB_264D		; unpack memory (AY) into FAC2
05288    
05289    ; perform subtraction, FAC1 from FAC2
05290    
05291    LAB_SUBTRACT
05292    E59A  A5 B0        	LDA	FAC1_s		; get FAC1 sign (b7)
05293    E59C  49 FF        	EOR	#$FF			; complement it
05294    E59E  85 B0        	STA	FAC1_s		; save FAC1 sign (b7)
05295    E5A0  45 B7        	EOR	FAC2_s		; EOR with FAC2 sign (b7)
05296    E5A2  85 B8        	STA	FAC_sc		; save sign compare (FAC1 EOR FAC2)
05297    E5A4  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
05298    E5A6  4C B5 E5     	JMP	LAB_ADD		; go add FAC2 to FAC1
05299    
05300    ; perform addition
05301    
05302    LAB_2467
05303    E5A9  20 CE E6     	JSR	LAB_257B		; shift FACX A times right (>8 shifts)
05304    E5AC  90 4D        	BCC	LAB_24A8		;.go subtract mantissas
05305    
05306    ; add 0.5 to FAC1
05307    
05308    LAB_244E
05309    E5AE  A9 F6        	LDA	#<LAB_2A96		; set 0.5 pointer low byte
05310    E5B0  A0 F1        	LDY	#>LAB_2A96		; set 0.5 pointer high byte
05311    
05312    ; add (AY) to FAC1
05313    
05314    LAB_246C
05315    E5B2  20 7F E7     	JSR	LAB_264D		; unpack memory (AY) into FAC2
05316    
05317    ; add FAC2 to FAC1
05318    
05319    LAB_ADD
05320    E5B5  D0 10        	BNE	LAB_2474		; branch if FAC1 was not zero
05321    
05322    ; copy FAC2 to FAC1
05323    
05324    LAB_279B
05325    E5B7  A5 B7        	LDA	FAC2_s		; get FAC2 sign (b7)
05326    
05327    ; save FAC1 sign and copy ABS(FAC2) to FAC1
05328    
05329    LAB_279D
05330    E5B9  85 B0        	STA	FAC1_s		; save FAC1 sign (b7)
05331    E5BB  A2 04        	LDX	#$04			; 4 bytes to copy
05332    LAB_27A1
05333    E5BD  B5 B2        	LDA	FAC1_o,X		; get byte from FAC2,X
05334    E5BF  95 AB        	STA	FAC1_e-1,X		; save byte at FAC1,X
05335    E5C1  CA           	DEX				; decrement count
05336    E5C2  D0 F9        	BNE	LAB_27A1		; loop if not all done
05337    
05338    E5C4  86 B9        	STX	FAC1_r		; clear FAC1 rounding byte
05339    E5C6  60           	RTS
05340    
05341    					; FAC1 is non zero
05342    LAB_2474
05343    E5C7  A6 B9        	LDX	FAC1_r		; get FAC1 rounding byte
05344    E5C9  86 A3        	STX	FAC2_r		; save as FAC2 rounding byte
05345    E5CB  A2 B3        	LDX	#FAC2_e		; set index to FAC2 exponent addr
05346    E5CD  A5 B3        	LDA	FAC2_e		; get FAC2 exponent
05347    LAB_247C
05348    E5CF  A8           	TAY				; copy exponent
05349    E5D0  F0 C4        	BEQ	LAB_244D		; exit if zero
05350    
05351    E5D2  38           	SEC				; set carry for subtract
05352    E5D3  E5 AC        	SBC	FAC1_e		; subtract FAC1 exponent
05353    E5D5  F0 24        	BEQ	LAB_24A8		; branch if = (go add mantissa)
05354    
05355    E5D7  90 12        	BCC	LAB_2498		; branch if <
05356    
05357    					; FAC2>FAC1
05358    E5D9  84 AC        	STY	FAC1_e		; save FAC1 exponent
05359    E5DB  A4 B7        	LDY	FAC2_s		; get FAC2 sign (b7)
05360    E5DD  84 B0        	STY	FAC1_s		; save FAC1 sign (b7)
05361    E5DF  49 FF        	EOR	#$FF			; complement A
05362    E5E1  69 00        	ADC	#$00			; +1 (twos complement, carry is set)
05363    E5E3  A0 00        	LDY	#$00			; clear Y
05364    E5E5  84 A3        	STY	FAC2_r		; clear FAC2 rounding byte
05365    E5E7  A2 AC        	LDX	#FAC1_e		; set index to FAC1 exponent addr
05366    E5E9  D0 04        	BNE	LAB_249C		; branch always
05367    
05368    LAB_2498
05369    E5EB  A0 00        	LDY	#$00			; clear Y
05370    E5ED  84 B9        	STY	FAC1_r		; clear FAC1 rounding byte
05371    LAB_249C
05372    E5EF  C9 F9        	CMP	#$F9			; compare exponent diff with $F9
05373    E5F1  30 B6        	BMI	LAB_2467		; branch if range $79-$F8
05374    
05375    E5F3  A8           	TAY				; copy exponent difference to Y
05376    E5F4  A5 B9        	LDA	FAC1_r		; get FAC1 rounding byte
05377    E5F6  56 01        	LSR	PLUS_1,X		; shift FAC? mantissa1
05378    E5F8  20 E5 E6     	JSR	LAB_2592		; shift FACX Y times right
05379    
05380    					; exponents are equal now do mantissa subtract
05381    LAB_24A8
05382    E5FB  24 B8        	BIT	FAC_sc		; test sign compare (FAC1 EOR FAC2)
05383    E5FD  10 4C        	BPL	LAB_24F8		; if = add FAC2 mantissa to FAC1 mantissa and return
05384    
05385    E5FF  A0 AC        	LDY	#FAC1_e		; set index to FAC1 exponent addr
05386    E601  E0 B3        	CPX	#FAC2_e		; compare X to FAC2 exponent addr
05387    E603  F0 02        	BEQ	LAB_24B4		; branch if =
05388    
05389    E605  A0 B3        	LDY	#FAC2_e		; else set index to FAC2 exponent addr
05390    
05391    					; subtract smaller from bigger (take sign of bigger)
05392    LAB_24B4
05393    E607  38           	SEC				; set carry for subtract
05394    E608  49 FF        	EOR	#$FF			; ones complement A
05395    E60A  65 A3        	ADC	FAC2_r		; add FAC2 rounding byte
05396    E60C  85 B9        	STA	FAC1_r		; save FAC1 rounding byte
05397    E60E  B9 03 00     	LDA	PLUS_3,Y		; get FACY mantissa3
05398    E611  F5 03        	SBC	PLUS_3,X		; subtract FACX mantissa3
05399    E613  85 AF        	STA	FAC1_3		; save FAC1 mantissa3
05400    E615  B9 02 00     	LDA	PLUS_2,Y		; get FACY mantissa2
05401    E618  F5 02        	SBC	PLUS_2,X		; subtract FACX mantissa2
05402    E61A  85 AE        	STA	FAC1_2		; save FAC1 mantissa2
05403    E61C  B9 01 00     	LDA	PLUS_1,Y		; get FACY mantissa1
05404    E61F  F5 01        	SBC	PLUS_1,X		; subtract FACX mantissa1
05405    E621  85 AD        	STA	FAC1_1		; save FAC1 mantissa1
05406    
05407    ; do ABS and normalise FAC1
05408    
05409    LAB_24D0
05410    E623  B0 03        	BCS	LAB_24D5		; branch if number is +ve
05411    
05412    E625  20 8A E6     	JSR	LAB_2537		; negate FAC1
05413    
05414    ; normalise FAC1
05415    
05416    LAB_24D5
05417    E628  A0 00        	LDY	#$00			; clear Y
05418    E62A  98           	TYA				; clear A
05419    E62B  18           	CLC				; clear carry for add
05420    LAB_24D9
05421    E62C  A6 AD        	LDX	FAC1_1		; get FAC1 mantissa1
05422    E62E  D0 3E        	BNE	LAB_251B		; if not zero normalise FAC1
05423    
05424    E630  A6 AE        	LDX	FAC1_2		; get FAC1 mantissa2
05425    E632  86 AD        	STX	FAC1_1		; save FAC1 mantissa1
05426    E634  A6 AF        	LDX	FAC1_3		; get FAC1 mantissa3
05427    E636  86 AE        	STX	FAC1_2		; save FAC1 mantissa2
05428    E638  A6 B9        	LDX	FAC1_r		; get FAC1 rounding byte
05429    E63A  86 AF        	STX	FAC1_3		; save FAC1 mantissa3
05430    E63C  84 B9        	STY	FAC1_r		; clear FAC1 rounding byte
05431    E63E  69 08        	ADC	#$08			; add x to exponent offset
05432    E640  C9 18        	CMP	#$18			; compare with $18 (max offset, all bits would be =0)
05433    E642  D0 E8        	BNE	LAB_24D9		; loop if not max
05434    
05435    ; clear FAC1 exponent and sign
05436    
05437    LAB_24F1
05438    E644  A9 00        	LDA	#$00			; clear A
05439    LAB_24F3
05440    E646  85 AC        	STA	FAC1_e		; set FAC1 exponent
05441    
05442    ; save FAC1 sign
05443    
05444    LAB_24F5
05445    E648  85 B0        	STA	FAC1_s		; save FAC1 sign (b7)
05446    E64A  60           	RTS
05447    
05448    ; add FAC2 mantissa to FAC1 mantissa
05449    
05450    LAB_24F8
05451    E64B  65 A3        	ADC	FAC2_r		; add FAC2 rounding byte
05452    E64D  85 B9        	STA	FAC1_r		; save FAC1 rounding byte
05453    E64F  A5 AF        	LDA	FAC1_3		; get FAC1 mantissa3
05454    E651  65 B6        	ADC	FAC2_3		; add FAC2 mantissa3
05455    E653  85 AF        	STA	FAC1_3		; save FAC1 mantissa3
05456    E655  A5 AE        	LDA	FAC1_2		; get FAC1 mantissa2
05457    E657  65 B5        	ADC	FAC2_2		; add FAC2 mantissa2
05458    E659  85 AE        	STA	FAC1_2		; save FAC1 mantissa2
05459    E65B  A5 AD        	LDA	FAC1_1		; get FAC1 mantissa1
05460    E65D  65 B4        	ADC	FAC2_1		; add FAC2 mantissa1
05461    E65F  85 AD        	STA	FAC1_1		; save FAC1 mantissa1
05462    E661  B0 1A        	BCS	LAB_252A		; if carry then normalise FAC1 for C=1
05463    
05464    E663  60           	RTS				; else just exit
05465    
05466    LAB_2511
05467    E664  69 01        	ADC	#$01			; add 1 to exponent offset
05468    E666  06 B9        	ASL	FAC1_r		; shift FAC1 rounding byte
05469    E668  26 AF        	ROL	FAC1_3		; shift FAC1 mantissa3
05470    E66A  26 AE        	ROL	FAC1_2		; shift FAC1 mantissa2
05471    E66C  26 AD        	ROL	FAC1_1		; shift FAC1 mantissa1
05472    
05473    ; normalise FAC1
05474    
05475    LAB_251B
05476    E66E  10 F4        	BPL	LAB_2511		; loop if not normalised
05477    
05478    E670  38           	SEC				; set carry for subtract
05479    E671  E5 AC        	SBC	FAC1_e		; subtract FAC1 exponent
05480    E673  B0 CF        	BCS	LAB_24F1		; branch if underflow (set result = $0)
05481    
05482    E675  49 FF        	EOR	#$FF			; complement exponent
05483    E677  69 01        	ADC	#$01			; +1 (twos complement)
05484    E679  85 AC        	STA	FAC1_e		; save FAC1 exponent
05485    
05486    ; test and normalise FAC1 for C=0/1
05487    
05488    LAB_2528
05489    E67B  90 0C        	BCC	LAB_2536		; exit if no overflow
05490    
05491    ; normalise FAC1 for C=1
05492    
05493    LAB_252A
05494    E67D  E6 AC        	INC	FAC1_e		; increment FAC1 exponent
05495    E67F  F0 36        	BEQ	LAB_2564		; if zero do overflow error and warm start
05496    
05497    E681  66 AD        	ROR	FAC1_1		; shift FAC1 mantissa1
05498    E683  66 AE        	ROR	FAC1_2		; shift FAC1 mantissa2
05499    E685  66 AF        	ROR	FAC1_3		; shift FAC1 mantissa3
05500    E687  66 B9        	ROR	FAC1_r		; shift FAC1 rounding byte
05501    LAB_2536
05502    E689  60           	RTS
05503    
05504    ; negate FAC1
05505    
05506    LAB_2537
05507    E68A  A5 B0        	LDA	FAC1_s		; get FAC1 sign (b7)
05508    E68C  49 FF        	EOR	#$FF			; complement it
05509    E68E  85 B0        	STA	FAC1_s		; save FAC1 sign (b7)
05510    
05511    ; twos complement FAC1 mantissa
05512    
05513    LAB_253D
05514    E690  A5 AD        	LDA	FAC1_1		; get FAC1 mantissa1
05515    E692  49 FF        	EOR	#$FF			; complement it
05516    E694  85 AD        	STA	FAC1_1		; save FAC1 mantissa1
05517    E696  A5 AE        	LDA	FAC1_2		; get FAC1 mantissa2
05518    E698  49 FF        	EOR	#$FF			; complement it
05519    E69A  85 AE        	STA	FAC1_2		; save FAC1 mantissa2
05520    E69C  A5 AF        	LDA	FAC1_3		; get FAC1 mantissa3
05521    E69E  49 FF        	EOR	#$FF			; complement it
05522    E6A0  85 AF        	STA	FAC1_3		; save FAC1 mantissa3
05523    E6A2  A5 B9        	LDA	FAC1_r		; get FAC1 rounding byte
05524    E6A4  49 FF        	EOR	#$FF			; complement it
05525    E6A6  85 B9        	STA	FAC1_r		; save FAC1 rounding byte
05526    E6A8  E6 B9        	INC	FAC1_r		; increment FAC1 rounding byte
05527    E6AA  D0 0A        	BNE	LAB_2563		; exit if no overflow
05528    
05529    ; increment FAC1 mantissa
05530    
05531    LAB_2559
05532    E6AC  E6 AF        	INC	FAC1_3		; increment FAC1 mantissa3
05533    E6AE  D0 06        	BNE	LAB_2563		; finished if no rollover
05534    
05535    E6B0  E6 AE        	INC	FAC1_2		; increment FAC1 mantissa2
05536    E6B2  D0 02        	BNE	LAB_2563		; finished if no rollover
05537    
05538    E6B4  E6 AD        	INC	FAC1_1		; increment FAC1 mantissa1
05539    LAB_2563
05540    E6B6  60           	RTS
05541    
05542    ; do overflow error (overflow exit)
05543    
05544    LAB_2564
05545    E6B7  A2 0A        	LDX	#$0A			; error code $0A ("Overflow" error)
05546    E6B9  4C 2E D1     	JMP	LAB_XERR		; do error #X, then warm start
05547    
05548    ; shift FCAtemp << A+8 times
05549    
05550    LAB_2569
05551    E6BC  A2 74        	LDX	#FACt_1-1		; set offset to FACtemp
05552    LAB_256B
05553    E6BE  B4 03        	LDY	PLUS_3,X		; get FACX mantissa3
05554    E6C0  84 B9        	STY	FAC1_r		; save as FAC1 rounding byte
05555    E6C2  B4 02        	LDY	PLUS_2,X		; get FACX mantissa2
05556    E6C4  94 03        	STY	PLUS_3,X		; save FACX mantissa3
05557    E6C6  B4 01        	LDY	PLUS_1,X		; get FACX mantissa1
05558    E6C8  94 02        	STY	PLUS_2,X		; save FACX mantissa2
05559    E6CA  A4 B2        	LDY	FAC1_o		; get FAC1 overflow byte
05560    E6CC  94 01        	STY	PLUS_1,X		; save FACX mantissa1
05561    
05562    ; shift FACX -A times right (> 8 shifts)
05563    
05564    LAB_257B
05565    E6CE  69 08        	ADC	#$08			; add 8 to shift count
05566    E6D0  30 EC        	BMI	LAB_256B		; go do 8 shift if still -ve
05567    
05568    E6D2  F0 EA        	BEQ	LAB_256B		; go do 8 shift if zero
05569    
05570    E6D4  E9 08        	SBC	#$08			; else subtract 8 again
05571    E6D6  A8           	TAY				; save count to Y
05572    E6D7  A5 B9        	LDA	FAC1_r		; get FAC1 rounding byte
05573    E6D9  B0 12        	BCS	LAB_259A		;.
05574    
05575    LAB_2588
05576    E6DB  16 01        	ASL	PLUS_1,X		; shift FACX mantissa1
05577    E6DD  90 02        	BCC	LAB_258E		; branch if +ve
05578    
05579    E6DF  F6 01        	INC	PLUS_1,X		; this sets b7 eventually
05580    LAB_258E
05581    E6E1  76 01        	ROR	PLUS_1,X		; shift FACX mantissa1 (correct for ASL)
05582    E6E3  76 01        	ROR	PLUS_1,X		; shift FACX mantissa1 (put carry in b7)
05583    
05584    ; shift FACX Y times right
05585    
05586    LAB_2592
05587    E6E5  76 02        	ROR	PLUS_2,X		; shift FACX mantissa2
05588    E6E7  76 03        	ROR	PLUS_3,X		; shift FACX mantissa3
05589    E6E9  6A           	ROR				; shift FACX rounding byte
05590    E6EA  C8           	INY				; increment exponent diff
05591    E6EB  D0 EE        	BNE	LAB_2588		; branch if range adjust not complete
05592    
05593    LAB_259A
05594    E6ED  18           	CLC				; just clear it
05595    E6EE  60           	RTS
05596    
05597    ; perform LOG()
05598    
05599    LAB_LOG
05600    E6EF  20 DD E8     	JSR	LAB_27CA		; test sign and zero
05601    E6F2  F0 02        	BEQ	LAB_25C4		; if zero do function call error then warm start
05602    
05603    E6F4  10 03        	BPL	LAB_25C7		; skip error if +ve
05604    
05605    LAB_25C4
05606    E6F6  4C 1D DF     	JMP	LAB_FCER		; do function call error then warm start (-ve)
05607    
05608    LAB_25C7
05609    E6F9  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
05610    E6FB  E9 7F        	SBC	#$7F			; normalise it
05611    E6FD  48           	PHA				; save it
05612    E6FE  A9 80        	LDA	#$80			; set exponent to zero
05613    E700  85 AC        	STA	FAC1_e		; save FAC1 exponent
05614    E702  A9 76        	LDA	#<LAB_25AD		; set 1/root2 pointer low byte
05615    E704  A0 F1        	LDY	#>LAB_25AD		; set 1/root2 pointer high byte
05616    E706  20 B2 E5     	JSR	LAB_246C		; add (AY) to FAC1 (1/root2)
05617    E709  A9 7A        	LDA	#<LAB_25B1		; set root2 pointer low byte
05618    E70B  A0 F1        	LDY	#>LAB_25B1		; set root2 pointer high byte
05619    E70D  20 F5 E7     	JSR	LAB_26CA		; convert AY and do (AY)/FAC1 (root2/(x+(1/root2)))
05620    E710  A9 ED        	LDA	#<LAB_259C		; set 1 pointer low byte
05621    E712  A0 F1        	LDY	#>LAB_259C		; set 1 pointer high byte
05622    E714  20 97 E5     	JSR	LAB_2455		; subtract (AY) from FAC1 ((root2/(x+(1/root2)))-1)
05623    E717  A9 69        	LDA	#<LAB_25A0		; set pointer low byte to counter
05624    E719  A0 F1        	LDY	#>LAB_25A0		; set pointer high byte to counter
05625    E71B  20 45 EC     	JSR	LAB_2B6E		; ^2 then series evaluation
05626    E71E  A9 7E        	LDA	#<LAB_25B5		; set -0.5 pointer low byte
05627    E720  A0 F1        	LDY	#>LAB_25B5		; set -0.5 pointer high byte
05628    E722  20 B2 E5     	JSR	LAB_246C		; add (AY) to FAC1
05629    E725  68           	PLA				; restore FAC1 exponent
05630    E726  20 39 EA     	JSR	LAB_2912		; evaluate new ASCII digit
05631    E729  A9 82        	LDA	#<LAB_25B9		; set LOG(2) pointer low byte
05632    E72B  A0 F1        	LDY	#>LAB_25B9		; set LOG(2) pointer high byte
05633    
05634    ; do convert AY, FCA1*(AY)
05635    
05636    LAB_25FB
05637    E72D  20 7F E7     	JSR	LAB_264D		; unpack memory (AY) into FAC2
05638    LAB_MULTIPLY
05639    E730  F0 4C        	BEQ	LAB_264C		; exit if zero
05640    
05641    E732  20 A5 E7     	JSR	LAB_2673		; test and adjust accumulators
05642    E735  A9 00        	LDA	#$00			; clear A
05643    E737  85 75        	STA	FACt_1		; clear temp mantissa1
05644    E739  85 76        	STA	FACt_2		; clear temp mantissa2
05645    E73B  85 77        	STA	FACt_3		; clear temp mantissa3
05646    E73D  A5 B9        	LDA	FAC1_r		; get FAC1 rounding byte
05647    E73F  20 54 E7     	JSR	LAB_2622		; go do shift/add FAC2
05648    E742  A5 AF        	LDA	FAC1_3		; get FAC1 mantissa3
05649    E744  20 54 E7     	JSR	LAB_2622		; go do shift/add FAC2
05650    E747  A5 AE        	LDA	FAC1_2		; get FAC1 mantissa2
05651    E749  20 54 E7     	JSR	LAB_2622		; go do shift/add FAC2
05652    E74C  A5 AD        	LDA	FAC1_1		; get FAC1 mantissa1
05653    E74E  20 59 E7     	JSR	LAB_2627		; go do shift/add FAC2
05654    E751  4C 62 E8     	JMP	LAB_273C		; copy temp to FAC1, normalise and return
05655    
05656    LAB_2622
05657    E754  D0 03        	BNE	LAB_2627		; branch if byte <> zero
05658    
05659    E756  4C BC E6     	JMP	LAB_2569		; shift FCAtemp << A+8 times
05660    
05661    					; else do shift and add
05662    LAB_2627
05663    E759  4A           	LSR				; shift byte
05664    E75A  09 80        	ORA	#$80			; set top bit (mark for 8 times)
05665    LAB_262A
05666    E75C  A8           	TAY				; copy result
05667    E75D  90 13        	BCC	LAB_2640		; skip next if bit was zero
05668    
05669    E75F  18           	CLC				; clear carry for add
05670    E760  A5 77        	LDA	FACt_3		; get temp mantissa3
05671    E762  65 B6        	ADC	FAC2_3		; add FAC2 mantissa3
05672    E764  85 77        	STA	FACt_3		; save temp mantissa3
05673    E766  A5 76        	LDA	FACt_2		; get temp mantissa2
05674    E768  65 B5        	ADC	FAC2_2		; add FAC2 mantissa2
05675    E76A  85 76        	STA	FACt_2		; save temp mantissa2
05676    E76C  A5 75        	LDA	FACt_1		; get temp mantissa1
05677    E76E  65 B4        	ADC	FAC2_1		; add FAC2 mantissa1
05678    E770  85 75        	STA	FACt_1		; save temp mantissa1
05679    LAB_2640
05680    E772  66 75        	ROR	FACt_1		; shift temp mantissa1
05681    E774  66 76        	ROR	FACt_2		; shift temp mantissa2
05682    E776  66 77        	ROR	FACt_3		; shift temp mantissa3
05683    E778  66 B9        	ROR	FAC1_r		; shift temp rounding byte
05684    E77A  98           	TYA				; get byte back
05685    E77B  4A           	LSR				; shift byte
05686    E77C  D0 DE        	BNE	LAB_262A		; loop if all bits not done
05687    
05688    LAB_264C
05689    E77E  60           	RTS
05690    
05691    ; unpack memory (AY) into FAC2
05692    
05693    LAB_264D
05694    E77F  85 71        	STA	ut1_pl		; save pointer low byte
05695    E781  84 72        	STY	ut1_ph		; save pointer high byte
05696    E783  A0 03        	LDY	#$03			; 4 bytes to get (0-3)
05697    E785  B1 71        	LDA	(ut1_pl),Y		; get mantissa3
05698    E787  85 B6        	STA	FAC2_3		; save FAC2 mantissa3
05699    E789  88           	DEY				; decrement index
05700    E78A  B1 71        	LDA	(ut1_pl),Y		; get mantissa2
05701    E78C  85 B5        	STA	FAC2_2		; save FAC2 mantissa2
05702    E78E  88           	DEY				; decrement index
05703    E78F  B1 71        	LDA	(ut1_pl),Y		; get mantissa1+sign
05704    E791  85 B7        	STA	FAC2_s		; save FAC2 sign (b7)
05705    E793  45 B0        	EOR	FAC1_s		; EOR with FAC1 sign (b7)
05706    E795  85 B8        	STA	FAC_sc		; save sign compare (FAC1 EOR FAC2)
05707    E797  A5 B7        	LDA	FAC2_s		; recover FAC2 sign (b7)
05708    E799  09 80        	ORA	#$80			; set 1xxx xxx (set normal bit)
05709    E79B  85 B4        	STA	FAC2_1		; save FAC2 mantissa1
05710    E79D  88           	DEY				; decrement index
05711    E79E  B1 71        	LDA	(ut1_pl),Y		; get exponent byte
05712    E7A0  85 B3        	STA	FAC2_e		; save FAC2 exponent
05713    E7A2  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
05714    E7A4  60           	RTS
05715    
05716    ; test and adjust accumulators
05717    
05718    LAB_2673
05719    E7A5  A5 B3        	LDA	FAC2_e		; get FAC2 exponent
05720    LAB_2675
05721    E7A7  F0 1D        	BEQ	LAB_2696		; branch if FAC2 = $00 (handle underflow)
05722    
05723    E7A9  18           	CLC				; clear carry for add
05724    E7AA  65 AC        	ADC	FAC1_e		; add FAC1 exponent
05725    E7AC  90 04        	BCC	LAB_2680		; branch if sum of exponents <$0100
05726    
05727    E7AE  30 31        	BMI	LAB_269B		; do overflow error
05728    
05729    E7B0  18           	CLC				; clear carry for the add
05730    	.byte	$2C			; makes next line BIT $1410
05731    LAB_2680
05732    E7B2  10 12        	BPL	LAB_2696		; if +ve go handle underflow
05733    
05734    E7B4  69 80        	ADC	#$80			; adjust exponent
05735    E7B6  85 AC        	STA	FAC1_e		; save FAC1 exponent
05736    E7B8  D0 03        	BNE	LAB_268B		; branch if not zero
05737    
05738    E7BA  4C 48 E6     	JMP	LAB_24F5		; save FAC1 sign and return
05739    
05740    LAB_268B
05741    E7BD  A5 B8        	LDA	FAC_sc		; get sign compare (FAC1 EOR FAC2)
05742    E7BF  85 B0        	STA	FAC1_s		; save FAC1 sign (b7)
05743    LAB_268F
05744    E7C1  60           	RTS
05745    
05746    ; handle overflow and underflow
05747    
05748    LAB_2690
05749    E7C2  A5 B0        	LDA	FAC1_s		; get FAC1 sign (b7)
05750    E7C4  10 1B        	BPL	LAB_269B		; do overflow error
05751    
05752    					; handle underflow
05753    LAB_2696
05754    E7C6  68           	PLA				; pop return address low byte
05755    E7C7  68           	PLA				; pop return address high byte
05756    E7C8  4C 44 E6     	JMP	LAB_24F1		; clear FAC1 exponent and sign and return
05757    
05758    ; multiply by 10
05759    
05760    LAB_269E
05761    E7CB  20 BE E8     	JSR	LAB_27AB		; round and copy FAC1 to FAC2
05762    E7CE  AA           	TAX				; copy exponent (set the flags)
05763    E7CF  F0 F0        	BEQ	LAB_268F		; exit if zero
05764    
05765    E7D1  18           	CLC				; clear carry for add
05766    E7D2  69 02        	ADC	#$02			; add two to exponent (*4)
05767    E7D4  B0 0B        	BCS	LAB_269B		; do overflow error if > $FF
05768    
05769    E7D6  A2 00        	LDX	#$00			; clear byte
05770    E7D8  86 B8        	STX	FAC_sc		; clear sign compare (FAC1 EOR FAC2)
05771    E7DA  20 CF E5     	JSR	LAB_247C		; add FAC2 to FAC1 (*5)
05772    E7DD  E6 AC        	INC	FAC1_e		; increment FAC1 exponent (*10)
05773    E7DF  D0 E0        	BNE	LAB_268F		; if non zero just do RTS
05774    
05775    LAB_269B
05776    E7E1  4C B7 E6     	JMP	LAB_2564		; do overflow error and warm start
05777    
05778    ; divide by 10
05779    
05780    LAB_26B9
05781    E7E4  20 BE E8     	JSR	LAB_27AB		; round and copy FAC1 to FAC2
05782    E7E7  A9 FE        	LDA	#<LAB_26B5		; set pointer to 10d low addr
05783    E7E9  A0 F1        	LDY	#>LAB_26B5		; set pointer to 10d high addr
05784    E7EB  A2 00        	LDX	#$00			; clear sign
05785    
05786    ; divide by (AY) (X=sign)
05787    
05788    LAB_26C2
05789    E7ED  86 B8        	STX	FAC_sc		; save sign compare (FAC1 EOR FAC2)
05790    E7EF  20 71 E8     	JSR	LAB_UFAC		; unpack memory (AY) into FAC1
05791    E7F2  4C F8 E7     	JMP	LAB_DIVIDE		; do FAC2/FAC1
05792    
05793    					; Perform divide-by
05794    ; convert AY and do (AY)/FAC1
05795    
05796    LAB_26CA
05797    E7F5  20 7F E7     	JSR	LAB_264D		; unpack memory (AY) into FAC2
05798    
05799    					; Perform divide-into
05800    LAB_DIVIDE
05801    E7F8  F0 63        	BEQ	LAB_2737		; if zero go do /0 error
05802    
05803    E7FA  20 CD E8     	JSR	LAB_27BA		; round FAC1
05804    E7FD  A9 00        	LDA	#$00			; clear A
05805    E7FF  38           	SEC				; set carry for subtract
05806    E800  E5 AC        	SBC	FAC1_e		; subtract FAC1 exponent (2s complement)
05807    E802  85 AC        	STA	FAC1_e		; save FAC1 exponent
05808    E804  20 A5 E7     	JSR	LAB_2673		; test and adjust accumulators
05809    E807  E6 AC        	INC	FAC1_e		; increment FAC1 exponent
05810    E809  F0 D6        	BEQ	LAB_269B		; if zero do overflow error
05811    
05812    E80B  A2 FF        	LDX	#$FF			; set index for pre increment
05813    E80D  A9 01        	LDA	#$01			; set bit to flag byte save
05814    LAB_26E4
05815    E80F  A4 B4        	LDY	FAC2_1		; get FAC2 mantissa1
05816    E811  C4 AD        	CPY	FAC1_1		; compare FAC1 mantissa1
05817    E813  D0 0A        	BNE	LAB_26F4		; branch if <>
05818    
05819    E815  A4 B5        	LDY	FAC2_2		; get FAC2 mantissa2
05820    E817  C4 AE        	CPY	FAC1_2		; compare FAC1 mantissa2
05821    E819  D0 04        	BNE	LAB_26F4		; branch if <>
05822    
05823    E81B  A4 B6        	LDY	FAC2_3		; get FAC2 mantissa3
05824    E81D  C4 AF        	CPY	FAC1_3		; compare FAC1 mantissa3
05825    LAB_26F4
05826    E81F  08           	PHP				; save FAC2-FAC1 compare status
05827    E820  2A           	ROL				; shift the result byte
05828    E821  90 0E        	BCC	LAB_2702		; if no carry skip the byte save
05829    
05830    E823  A0 01        	LDY	#$01			; set bit to flag byte save
05831    E825  E8           	INX				; else increment the index to FACt
05832    E826  E0 02        	CPX	#$02			; compare with the index to FACt_3
05833    E828  30 04        	BMI	LAB_2701		; if not last byte just go save it
05834    
05835    E82A  D0 28        	BNE	LAB_272B		; if all done go save FAC1 rounding byte, normalise and
05836    					; return
05837    
05838    E82C  A0 40        	LDY	#$40			; set bit to flag byte save for the rounding byte
05839    LAB_2701
05840    E82E  95 75        	STA	FACt_1,X		; write result byte to FACt_1 + index
05841    E830  98           	TYA				; copy the next save byte flag
05842    LAB_2702
05843    E831  28           	PLP				; restore FAC2-FAC1 compare status
05844    E832  90 14        	BCC	LAB_2704		; if FAC2 < FAC1 then skip the subtract
05845    
05846    E834  A8           	TAY				; save FAC2-FAC1 compare status
05847    E835  A5 B6        	LDA	FAC2_3		; get FAC2 mantissa3
05848    E837  E5 AF        	SBC	FAC1_3		; subtract FAC1 mantissa3
05849    E839  85 B6        	STA	FAC2_3		; save FAC2 mantissa3
05850    E83B  A5 B5        	LDA	FAC2_2		; get FAC2 mantissa2
05851    E83D  E5 AE        	SBC	FAC1_2		; subtract FAC1 mantissa2
05852    E83F  85 B5        	STA	FAC2_2		; save FAC2 mantissa2
05853    E841  A5 B4        	LDA	FAC2_1		; get FAC2 mantissa1
05854    E843  E5 AD        	SBC	FAC1_1		; subtract FAC1 mantissa1
05855    E845  85 B4        	STA	FAC2_1		; save FAC2 mantissa1
05856    E847  98           	TYA				; restore FAC2-FAC1 compare status
05857    
05858    					; FAC2 = FAC2*2
05859    LAB_2704
05860    E848  06 B6        	ASL	FAC2_3		; shift FAC2 mantissa3
05861    E84A  26 B5        	ROL	FAC2_2		; shift FAC2 mantissa2
05862    E84C  26 B4        	ROL	FAC2_1		; shift FAC2 mantissa1
05863    E84E  B0 CF        	BCS	LAB_26F4		; loop with no compare
05864    
05865    E850  30 BD        	BMI	LAB_26E4		; loop with compare
05866    
05867    E852  10 CB        	BPL	LAB_26F4		; loop always with no compare
05868    
05869    ; do A<<6, save as FAC1 rounding byte, normalise and return
05870    
05871    LAB_272B
05872    E854  4A           	LSR				; shift b1 - b0 ..
05873    E855  6A           	ROR				; ..
05874    E856  6A           	ROR				; .. to b7 - b6
05875    E857  85 B9        	STA	FAC1_r		; save FAC1 rounding byte
05876    E859  28           	PLP				; dump FAC2-FAC1 compare status
05877    E85A  4C 62 E8     	JMP	LAB_273C		; copy temp to FAC1, normalise and return
05878    
05879    ; do "Divide by zero" error
05880    
05881    LAB_2737
05882    E85D  A2 14        	LDX	#$14			; error code $14 ("Divide by zero" error)
05883    E85F  4C 2E D1     	JMP	LAB_XERR		; do error #X, then warm start
05884    
05885    ; copy temp to FAC1 and normalise
05886    
05887    LAB_273C
05888    E862  A5 75        	LDA	FACt_1		; get temp mantissa1
05889    E864  85 AD        	STA	FAC1_1		; save FAC1 mantissa1
05890    E866  A5 76        	LDA	FACt_2		; get temp mantissa2
05891    E868  85 AE        	STA	FAC1_2		; save FAC1 mantissa2
05892    E86A  A5 77        	LDA	FACt_3		; get temp mantissa3
05893    E86C  85 AF        	STA	FAC1_3		; save FAC1 mantissa3
05894    E86E  4C 28 E6     	JMP	LAB_24D5		; normalise FAC1 and return
05895    
05896    ; unpack memory (AY) into FAC1
05897    
05898    LAB_UFAC
05899    E871  85 71        	STA	ut1_pl		; save pointer low byte
05900    E873  84 72        	STY	ut1_ph		; save pointer high byte
05901    E875  A0 03        	LDY	#$03			; 4 bytes to do
05902    E877  B1 71        	LDA	(ut1_pl),Y		; get last byte
05903    E879  85 AF        	STA	FAC1_3		; save FAC1 mantissa3
05904    E87B  88           	DEY				; decrement index
05905    E87C  B1 71        	LDA	(ut1_pl),Y		; get last-1 byte
05906    E87E  85 AE        	STA	FAC1_2		; save FAC1 mantissa2
05907    E880  88           	DEY				; decrement index
05908    E881  B1 71        	LDA	(ut1_pl),Y		; get second byte
05909    E883  85 B0        	STA	FAC1_s		; save FAC1 sign (b7)
05910    E885  09 80        	ORA	#$80			; set 1xxx xxxx (add normal bit)
05911    E887  85 AD        	STA	FAC1_1		; save FAC1 mantissa1
05912    E889  88           	DEY				; decrement index
05913    E88A  B1 71        	LDA	(ut1_pl),Y		; get first byte (exponent)
05914    E88C  85 AC        	STA	FAC1_e		; save FAC1 exponent
05915    E88E  84 B9        	STY	FAC1_r		; clear FAC1 rounding byte
05916    E890  60           	RTS
05917    
05918    ; pack FAC1 into Adatal
05919    
05920    LAB_276E
05921    E891  A2 A4        	LDX	#<Adatal		; set pointer low byte
05922    LAB_2770
05923    E893  A0 00        	LDY	#>Adatal		; set pointer high byte
05924    E895  F0 04        	BEQ	LAB_2778		; pack FAC1 into (XY) and return
05925    
05926    ; pack FAC1 into (Lvarpl)
05927    
05928    LAB_PFAC
05929    E897  A6 97        	LDX	Lvarpl		; get destination pointer low byte
05930    E899  A4 98        	LDY	Lvarph		; get destination pointer high byte
05931    
05932    ; pack FAC1 into (XY)
05933    
05934    LAB_2778
05935    E89B  20 CD E8     	JSR	LAB_27BA		; round FAC1
05936    E89E  86 71        	STX	ut1_pl		; save pointer low byte
05937    E8A0  84 72        	STY	ut1_ph		; save pointer high byte
05938    E8A2  A0 03        	LDY	#$03			; set index
05939    E8A4  A5 AF        	LDA	FAC1_3		; get FAC1 mantissa3
05940    E8A6  91 71        	STA	(ut1_pl),Y		; store in destination
05941    E8A8  88           	DEY				; decrement index
05942    E8A9  A5 AE        	LDA	FAC1_2		; get FAC1 mantissa2
05943    E8AB  91 71        	STA	(ut1_pl),Y		; store in destination
05944    E8AD  88           	DEY				; decrement index
05945    E8AE  A5 B0        	LDA	FAC1_s		; get FAC1 sign (b7)
05946    E8B0  09 7F        	ORA	#$7F			; set bits x111 1111
05947    E8B2  25 AD        	AND	FAC1_1		; AND in FAC1 mantissa1
05948    E8B4  91 71        	STA	(ut1_pl),Y		; store in destination
05949    E8B6  88           	DEY				; decrement index
05950    E8B7  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
05951    E8B9  91 71        	STA	(ut1_pl),Y		; store in destination
05952    E8BB  84 B9        	STY	FAC1_r		; clear FAC1 rounding byte
05953    E8BD  60           	RTS
05954    
05955    ; round and copy FAC1 to FAC2
05956    
05957    LAB_27AB
05958    E8BE  20 CD E8     	JSR	LAB_27BA		; round FAC1
05959    
05960    ; copy FAC1 to FAC2
05961    
05962    LAB_27AE
05963    E8C1  A2 05        	LDX	#$05			; 5 bytes to copy
05964    LAB_27B0
05965    E8C3  B5 AB        	LDA	FAC1_e-1,X		; get byte from FAC1,X
05966    E8C5  95 B2        	STA	FAC1_o,X		; save byte at FAC2,X
05967    E8C7  CA           	DEX				; decrement count
05968    E8C8  D0 F9        	BNE	LAB_27B0		; loop if not all done
05969    
05970    E8CA  86 B9        	STX	FAC1_r		; clear FAC1 rounding byte
05971    LAB_27B9
05972    E8CC  60           	RTS
05973    
05974    ; round FAC1
05975    
05976    LAB_27BA
05977    E8CD  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
05978    E8CF  F0 FB        	BEQ	LAB_27B9		; exit if zero
05979    
05980    E8D1  06 B9        	ASL	FAC1_r		; shift FAC1 rounding byte
05981    E8D3  90 F7        	BCC	LAB_27B9		; exit if no overflow
05982    
05983    ; round FAC1 (no check)
05984    
05985    LAB_27C2
05986    E8D5  20 AC E6     	JSR	LAB_2559		; increment FAC1 mantissa
05987    E8D8  D0 F2        	BNE	LAB_27B9		; branch if no overflow
05988    
05989    E8DA  4C 7D E6     	JMP	LAB_252A		; normalise FAC1 for C=1 and return
05990    
05991    ; get FAC1 sign
05992    ; return A=FF,C=1/-ve A=01,C=0/+ve
05993    
05994    LAB_27CA
05995    E8DD  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
05996    E8DF  F0 09        	BEQ	LAB_27D7		; exit if zero (already correct SGN(0)=0)
05997    
05998    ; return A=FF,C=1/-ve A=01,C=0/+ve
05999    ; no = 0 check
06000    
06001    LAB_27CE
06002    E8E1  A5 B0        	LDA	FAC1_s		; else get FAC1 sign (b7)
06003    
06004    ; return A=FF,C=1/-ve A=01,C=0/+ve
06005    ; no = 0 check, sign in A
06006    
06007    LAB_27D0
06008    E8E3  2A           	ROL				; move sign bit to carry
06009    E8E4  A9 FF        	LDA	#$FF			; set byte for -ve result
06010    E8E6  B0 02        	BCS	LAB_27D7		; return if sign was set (-ve)
06011    
06012    E8E8  A9 01        	LDA	#$01			; else set byte for +ve result
06013    LAB_27D7
06014    E8EA  60           	RTS
06015    
06016    ; perform SGN()
06017    
06018    LAB_SGN
06019    E8EB  20 DD E8     	JSR	LAB_27CA		; get FAC1 sign
06020    					; return A=$FF/-ve A=$01/+ve
06021    ; save A as integer byte
06022    
06023    LAB_27DB
06024    E8EE  85 AD        	STA	FAC1_1		; save FAC1 mantissa1
06025    E8F0  A9 00        	LDA	#$00			; clear A
06026    E8F2  85 AE        	STA	FAC1_2		; clear FAC1 mantissa2
06027    E8F4  A2 88        	LDX	#$88			; set exponent
06028    
06029    ; set exp=X, clearFAC1 mantissa3 and normalise
06030    
06031    LAB_27E3
06032    E8F6  A5 AD        	LDA	FAC1_1		; get FAC1 mantissa1
06033    E8F8  49 FF        	EOR	#$FF			; complement it
06034    E8FA  2A           	ROL				; sign bit into carry
06035    
06036    ; set exp=X, clearFAC1 mantissa3 and normalise
06037    
06038    LAB_STFA
06039    E8FB  A9 00        	LDA	#$00			; clear A
06040    E8FD  85 AF        	STA	FAC1_3		; clear FAC1 mantissa3
06041    E8FF  86 AC        	STX	FAC1_e		; set FAC1 exponent
06042    E901  85 B9        	STA	FAC1_r		; clear FAC1 rounding byte
06043    E903  85 B0        	STA	FAC1_s		; clear FAC1 sign (b7)
06044    E905  4C 23 E6     	JMP	LAB_24D0		; do ABS and normalise FAC1
06045    
06046    ; perform ABS()
06047    
06048    LAB_ABS
06049    E908  46 B0        	LSR	FAC1_s		; clear FAC1 sign (put zero in b7)
06050    E90A  60           	RTS
06051    
06052    ; compare FAC1 with (AY)
06053    ; returns A=$00 if FAC1 = (AY)
06054    ; returns A=$01 if FAC1 > (AY)
06055    ; returns A=$FF if FAC1 < (AY)
06056    
06057    LAB_27F8
06058    E90B  85 73        	STA	ut2_pl		; save pointer low byte
06059    LAB_27FA
06060    E90D  84 74        	STY	ut2_ph		; save pointer high byte
06061    E90F  A0 00        	LDY	#$00			; clear index
06062    E911  B1 73        	LDA	(ut2_pl),Y		; get exponent
06063    E913  C8           	INY				; increment index
06064    E914  AA           	TAX				; copy (AY) exponent to X
06065    E915  F0 C6        	BEQ	LAB_27CA		; branch if (AY) exponent=0 and get FAC1 sign
06066    					; A=FF,C=1/-ve A=01,C=0/+ve
06067    
06068    E917  B1 73        	LDA	(ut2_pl),Y		; get (AY) mantissa1 (with sign)
06069    E919  45 B0        	EOR	FAC1_s		; EOR FAC1 sign (b7)
06070    E91B  30 C4        	BMI	LAB_27CE		; if signs <> do return A=FF,C=1/-ve
06071    					; A=01,C=0/+ve and return
06072    
06073    E91D  E4 AC        	CPX	FAC1_e		; compare (AY) exponent with FAC1 exponent
06074    E91F  D0 1A        	BNE	LAB_2828		; branch if different
06075    
06076    E921  B1 73        	LDA	(ut2_pl),Y		; get (AY) mantissa1 (with sign)
06077    E923  09 80        	ORA	#$80			; normalise top bit
06078    E925  C5 AD        	CMP	FAC1_1		; compare with FAC1 mantissa1
06079    E927  D0 12        	BNE	LAB_2828		; branch if different
06080    
06081    E929  C8           	INY				; increment index
06082    E92A  B1 73        	LDA	(ut2_pl),Y		; get mantissa2
06083    E92C  C5 AE        	CMP	FAC1_2		; compare with FAC1 mantissa2
06084    E92E  D0 0B        	BNE	LAB_2828		; branch if different
06085    
06086    E930  C8           	INY				; increment index
06087    E931  A9 7F        	LDA	#$7F			; set for 1/2 value rounding byte
06088    E933  C5 B9        	CMP	FAC1_r		; compare with FAC1 rounding byte (set carry)
06089    E935  B1 73        	LDA	(ut2_pl),Y		; get mantissa3
06090    E937  E5 AF        	SBC	FAC1_3		; subtract FAC1 mantissa3
06091    E939  F0 28        	BEQ	LAB_2850		; exit if mantissa3 equal
06092    
06093    ; gets here if number <> FAC1
06094    
06095    LAB_2828
06096    E93B  A5 B0        	LDA	FAC1_s		; get FAC1 sign (b7)
06097    E93D  90 02        	BCC	LAB_282E		; branch if FAC1 > (AY)
06098    
06099    E93F  49 FF        	EOR	#$FF			; else toggle FAC1 sign
06100    LAB_282E
06101    E941  4C E3 E8     	JMP	LAB_27D0		; return A=FF,C=1/-ve A=01,C=0/+ve
06102    
06103    ; convert FAC1 floating-to-fixed
06104    
06105    LAB_2831
06106    E944  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
06107    E946  F0 4A        	BEQ	LAB_287F		; if zero go clear FAC1 and return
06108    
06109    E948  38           	SEC				; set carry for subtract
06110    E949  E9 98        	SBC	#$98			; subtract maximum integer range exponent
06111    E94B  24 B0        	BIT	FAC1_s		; test FAC1 sign (b7)
06112    E94D  10 09        	BPL	LAB_2845		; branch if FAC1 +ve
06113    
06114    					; FAC1 was -ve
06115    E94F  AA           	TAX				; copy subtracted exponent
06116    E950  A9 FF        	LDA	#$FF			; overflow for -ve number
06117    E952  85 B2        	STA	FAC1_o		; set FAC1 overflow byte
06118    E954  20 90 E6     	JSR	LAB_253D		; twos complement FAC1 mantissa
06119    E957  8A           	TXA				; restore subtracted exponent
06120    LAB_2845
06121    E958  A2 AC        	LDX	#FAC1_e		; set index to FAC1
06122    E95A  C9 F9        	CMP	#$F9			; compare exponent result
06123    E95C  10 06        	BPL	LAB_2851		; if < 8 shifts shift FAC1 A times right and return
06124    
06125    E95E  20 CE E6     	JSR	LAB_257B		; shift FAC1 A times right (> 8 shifts)
06126    E961  84 B2        	STY	FAC1_o		; clear FAC1 overflow byte
06127    LAB_2850
06128    E963  60           	RTS
06129    
06130    ; shift FAC1 A times right
06131    
06132    LAB_2851
06133    E964  A8           	TAY				; copy shift count
06134    E965  A5 B0        	LDA	FAC1_s		; get FAC1 sign (b7)
06135    E967  29 80        	AND	#$80			; mask sign bit only (x000 0000)
06136    E969  46 AD        	LSR	FAC1_1		; shift FAC1 mantissa1
06137    E96B  05 AD        	ORA	FAC1_1		; OR sign in b7 FAC1 mantissa1
06138    E96D  85 AD        	STA	FAC1_1		; save FAC1 mantissa1
06139    E96F  20 E5 E6     	JSR	LAB_2592		; shift FAC1 Y times right
06140    E972  84 B2        	STY	FAC1_o		; clear FAC1 overflow byte
06141    E974  60           	RTS
06142    
06143    ; perform INT()
06144    
06145    LAB_INT
06146    E975  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
06147    E977  C9 98        	CMP	#$98			; compare with max int
06148    E979  B0 1E        	BCS	LAB_2886		; exit if >= (already int, too big for fractional part!)
06149    
06150    E97B  20 44 E9     	JSR	LAB_2831		; convert FAC1 floating-to-fixed
06151    E97E  84 B9        	STY	FAC1_r		; save FAC1 rounding byte
06152    E980  A5 B0        	LDA	FAC1_s		; get FAC1 sign (b7)
06153    E982  84 B0        	STY	FAC1_s		; save FAC1 sign (b7)
06154    E984  49 80        	EOR	#$80			; toggle FAC1 sign
06155    E986  2A           	ROL				; shift into carry
06156    E987  A9 98        	LDA	#$98			; set new exponent
06157    E989  85 AC        	STA	FAC1_e		; save FAC1 exponent
06158    E98B  A5 AF        	LDA	FAC1_3		; get FAC1 mantissa3
06159    E98D  85 5B        	STA	Temp3			; save for EXP() function
06160    E98F  4C 23 E6     	JMP	LAB_24D0		; do ABS and normalise FAC1
06161    
06162    ; clear FAC1 and return
06163    
06164    LAB_287F
06165    E992  85 AD        	STA	FAC1_1		; clear FAC1 mantissa1
06166    E994  85 AE        	STA	FAC1_2		; clear FAC1 mantissa2
06167    E996  85 AF        	STA	FAC1_3		; clear FAC1 mantissa3
06168    E998  A8           	TAY				; clear Y
06169    LAB_2886
06170    E999  60           	RTS
06171    
06172    ; get FAC1 from string
06173    ; this routine now handles hex and binary values from strings
06174    ; starting with "$" and "%" respectively
06175    
06176    LAB_2887
06177    E99A  A0 00        	LDY	#$00			; clear Y
06178    E99C  84 5F        	STY	Dtypef		; clear data type flag, $FF=string, $00=numeric
06179    E99E  A2 09        	LDX	#$09			; set index
06180    LAB_288B
06181    E9A0  94 A8        	STY	numexp,X		; clear byte
06182    E9A2  CA           	DEX				; decrement index
06183    E9A3  10 FB        	BPL	LAB_288B		; loop until numexp to negnum (and FAC1) = $00
06184    
06185    E9A5  90 7F        	BCC	LAB_28FE		; branch if 1st character numeric
06186    
06187    ; get FAC1 from string .. first character wasn't numeric
06188    
06189    E9A7  C9 2D        	CMP	#'-'			; else compare with "-"
06190    E9A9  D0 04        	BNE	LAB_289A		; branch if not "-"
06191    
06192    E9AB  86 B1        	STX	negnum		; set flag for -ve number (X = $FF)
06193    E9AD  F0 04        	BEQ	LAB_289C		; branch always (go scan and check for hex/bin)
06194    
06195    ; get FAC1 from string .. first character wasn't numeric or -
06196    
06197    LAB_289A
06198    E9AF  C9 2B        	CMP	#'+'			; else compare with "+"
06199    E9B1  D0 05        	BNE	LAB_289D		; branch if not "+" (go check for hex/bin)
06200    
06201    ; was "+" or "-" to start, so get next character
06202    
06203    LAB_289C
06204    E9B3  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory
06205    E9B6  90 6E        	BCC	LAB_28FE		; branch if numeric character
06206    
06207    ; code here for hex and binary numbers
06208    
06209    LAB_289D
06210    E9B8  C9 24        	CMP	#'$'			; else compare with "$"
06211    E9BA  D0 03        	BNE	LAB_NHEX		; branch if not "$"
06212    
06213    E9BC  4C 64 EE     	JMP	LAB_CHEX		; branch if "$"
06214    
06215    LAB_NHEX
06216    E9BF  C9 25        	CMP	#'%'			; else compare with "%"
06217    E9C1  D0 08        	BNE	LAB_28A3		; branch if not "%" (continue original code)
06218    
06219    E9C3  4C 92 EE     	JMP	LAB_CBIN		; branch if "%"
06220    
06221    LAB_289E
06222    E9C6  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory (ignore + or get next number)
06223    LAB_28A1
06224    E9C9  90 5B        	BCC	LAB_28FE		; branch if numeric character
06225    
06226    ; get FAC1 from string .. character wasn't numeric, -, +, hex or binary
06227    
06228    LAB_28A3
06229    E9CB  C9 2E        	CMP	#'.'			; else compare with "."
06230    E9CD  F0 2E        	BEQ	LAB_28D5		; branch if "."
06231    
06232    ; get FAC1 from string .. character wasn't numeric, -, + or .
06233    
06234    E9CF  C9 45        	CMP	#'E'			; else compare with "E"
06235    E9D1  D0 30        	BNE	LAB_28DB		; branch if not "E"
06236    
06237    					; was "E" so evaluate exponential part
06238    E9D3  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory
06239    E9D6  90 17        	BCC	LAB_28C7		; branch if numeric character
06240    
06241    E9D8  C9 B7        	CMP	#TK_MINUS		; else compare with token for -
06242    E9DA  F0 0E        	BEQ	LAB_28C2		; branch if token for -
06243    
06244    E9DC  C9 2D        	CMP	#'-'			; else compare with "-"
06245    E9DE  F0 0A        	BEQ	LAB_28C2		; branch if "-"
06246    
06247    E9E0  C9 B6        	CMP	#TK_PLUS		; else compare with token for +
06248    E9E2  F0 08        	BEQ	LAB_28C4		; branch if token for +
06249    
06250    E9E4  C9 2B        	CMP	#'+'			; else compare with "+"
06251    E9E6  F0 04        	BEQ	LAB_28C4		; branch if "+"
06252    
06253    E9E8  D0 07        	BNE	LAB_28C9		; branch always
06254    
06255    LAB_28C2
06256    E9EA  66 AB        	ROR	expneg		; set exponent -ve flag (C, which=1, into b7)
06257    LAB_28C4
06258    E9EC  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory
06259    LAB_28C7
06260    E9EF  90 5B        	BCC	LAB_2925		; branch if numeric character
06261    
06262    LAB_28C9
06263    E9F1  24 AB        	BIT	expneg		; test exponent -ve flag
06264    E9F3  10 0E        	BPL	LAB_28DB		; if +ve go evaluate exponent
06265    
06266    					; else do exponent = -exponent 
06267    E9F5  A9 00        	LDA	#$00			; clear result
06268    E9F7  38           	SEC				; set carry for subtract
06269    E9F8  E5 A9        	SBC	expcnt		; subtract exponent byte
06270    E9FA  4C 05 EA     	JMP	LAB_28DD		; go evaluate exponent
06271    
06272    LAB_28D5
06273    E9FD  66 AA        	ROR	numdpf		; set decimal point flag
06274    E9FF  24 AA        	BIT	numdpf		; test decimal point flag
06275    EA01  50 C3        	BVC	LAB_289E		; branch if only one decimal point so far
06276    
06277    					; evaluate exponent
06278    LAB_28DB
06279    EA03  A5 A9        	LDA	expcnt		; get exponent count byte
06280    LAB_28DD
06281    EA05  38           	SEC				; set carry for subtract
06282    EA06  E5 A8        	SBC	numexp		; subtract numerator exponent
06283    EA08  85 A9        	STA	expcnt		; save exponent count byte
06284    EA0A  F0 12        	BEQ	LAB_28F6		; branch if no adjustment
06285    
06286    EA0C  10 09        	BPL	LAB_28EF		; else if +ve go do FAC1*10^expcnt
06287    
06288    					; else go do FAC1/10^(0-expcnt)
06289    LAB_28E6
06290    EA0E  20 E4 E7     	JSR	LAB_26B9		; divide by 10
06291    EA11  E6 A9        	INC	expcnt		; increment exponent count byte
06292    EA13  D0 F9        	BNE	LAB_28E6		; loop until all done
06293    
06294    EA15  F0 07        	BEQ	LAB_28F6		; branch always
06295    
06296    LAB_28EF
06297    EA17  20 CB E7     	JSR	LAB_269E		; multiply by 10
06298    EA1A  C6 A9        	DEC	expcnt		; decrement exponent count byte
06299    EA1C  D0 F9        	BNE	LAB_28EF		; loop until all done
06300    
06301    LAB_28F6
06302    EA1E  A5 B1        	LDA	negnum		; get -ve flag
06303    EA20  30 01        	BMI	LAB_28FB		; if -ve do - FAC1 and return
06304    
06305    EA22  60           	RTS
06306    
06307    ; do - FAC1 and return
06308    
06309    LAB_28FB
06310    EA23  4C E8 EB     	JMP	LAB_GTHAN		; do - FAC1 and return
06311    
06312    ; do unsigned FAC1*10+number
06313    
06314    LAB_28FE
06315    EA26  48           	PHA				; save character
06316    EA27  24 AA        	BIT	numdpf		; test decimal point flag
06317    EA29  10 02        	BPL	LAB_2905		; skip exponent increment if not set
06318    
06319    EA2B  E6 A8        	INC	numexp		; else increment number exponent
06320    LAB_2905
06321    EA2D  20 CB E7     	JSR	LAB_269E		; multiply FAC1 by 10
06322    EA30  68           	PLA				; restore character
06323    EA31  29 0F        	AND	#$0F			; convert to binary
06324    EA33  20 39 EA     	JSR	LAB_2912		; evaluate new ASCII digit
06325    EA36  4C C6 E9     	JMP	LAB_289E		; go do next character
06326    
06327    ; evaluate new ASCII digit
06328    
06329    LAB_2912
06330    EA39  48           	PHA				; save digit
06331    EA3A  20 BE E8     	JSR	LAB_27AB		; round and copy FAC1 to FAC2
06332    EA3D  68           	PLA				; restore digit
06333    EA3E  20 EE E8     	JSR	LAB_27DB		; save A as integer byte
06334    EA41  A5 B7        	LDA	FAC2_s		; get FAC2 sign (b7)
06335    EA43  45 B0        	EOR	FAC1_s		; toggle with FAC1 sign (b7)
06336    EA45  85 B8        	STA	FAC_sc		; save sign compare (FAC1 EOR FAC2)
06337    EA47  A6 AC        	LDX	FAC1_e		; get FAC1 exponent
06338    EA49  4C B5 E5     	JMP	LAB_ADD		; add FAC2 to FAC1 and return
06339    
06340    ; evaluate next character of exponential part of number
06341    
06342    LAB_2925
06343    EA4C  A5 A9        	LDA	expcnt		; get exponent count byte
06344    EA4E  C9 0A        	CMP	#$0A			; compare with 10 decimal
06345    EA50  90 09        	BCC	LAB_2934		; branch if less
06346    
06347    EA52  A9 64        	LDA	#$64			; make all -ve exponents = -100 decimal (causes underflow)
06348    EA54  24 AB        	BIT	expneg		; test exponent -ve flag
06349    EA56  30 0E        	BMI	LAB_2942		; branch if -ve
06350    
06351    EA58  4C B7 E6     	JMP	LAB_2564		; else do overflow error
06352    
06353    LAB_2934
06354    EA5B  0A           	ASL				; * 2
06355    EA5C  0A           	ASL				; * 4
06356    EA5D  65 A9        	ADC	expcnt		; * 5
06357    EA5F  0A           	ASL				; * 10
06358    EA60  A0 00        	LDY	#$00			; set index
06359    EA62  71 C3        	ADC	(Bpntrl),Y		; add character (will be $30 too much!)
06360    EA64  E9 2F        	SBC	#'0'-1		; convert character to binary
06361    LAB_2942
06362    EA66  85 A9        	STA	expcnt		; save exponent count byte
06363    EA68  4C EC E9     	JMP	LAB_28C4		; go get next character
06364    
06365    ; print " in line [LINE #]"
06366    
06367    LAB_2953
06368    EA6B  A9 FA        	LDA	#<LAB_LMSG		; point to " in line " message low byte
06369    EA6D  A0 F7        	LDY	#>LAB_LMSG		; point to " in line " message high byte
06370    EA6F  20 C7 D8     	JSR	LAB_18C3		; print null terminated string from memory
06371    
06372    					; print Basic line #
06373    EA72  A5 88        	LDA	Clineh		; get current line high byte
06374    EA74  A6 87        	LDX	Clinel		; get current line low byte
06375    
06376    ; print XA as unsigned integer
06377    
06378    LAB_295E
06379    EA76  85 AD        	STA	FAC1_1		; save low byte as FAC1 mantissa1
06380    EA78  86 AE        	STX	FAC1_2		; save high byte as FAC1 mantissa2
06381    EA7A  A2 90        	LDX	#$90			; set exponent to 16d bits
06382    EA7C  38           	SEC				; set integer is +ve flag
06383    EA7D  20 FB E8     	JSR	LAB_STFA		; set exp=X, clearFAC1 mantissa3 and normalise
06384    EA80  A0 00        	LDY	#$00			; clear index
06385    EA82  98           	TYA				; clear A
06386    EA83  20 96 EA     	JSR	LAB_297B		; convert FAC1 to string, skip sign character save
06387    EA86  4C C7 D8     	JMP	LAB_18C3		; print null terminated string from memory and return
06388    
06389    ; convert FAC1 to ASCII string result in (AY)
06390    ; not any more, moved scratchpad to page 0
06391    
06392    LAB_296E
06393    EA89  A0 01        	LDY	#$01			; set index = 1
06394    EA8B  A9 20        	LDA	#$20			; character = " " (assume +ve)
06395    EA8D  24 B0        	BIT	FAC1_s		; test FAC1 sign (b7)
06396    EA8F  10 02        	BPL	LAB_2978		; branch if +ve
06397    
06398    EA91  A9 2D        	LDA	#$2D			; else character = "-"
06399    LAB_2978
06400    EA93  99 EF 00     	STA	Decss,Y		; save leading character (" " or "-")
06401    LAB_297B
06402    EA96  85 B0        	STA	FAC1_s		; clear FAC1 sign (b7)
06403    EA98  84 BA        	STY	Sendl			; save index
06404    EA9A  C8           	INY				; increment index
06405    EA9B  A6 AC        	LDX	FAC1_e		; get FAC1 exponent
06406    EA9D  D0 05        	BNE	LAB_2989		; branch if FAC1<>0
06407    
06408    					; exponent was $00 so FAC1 is 0
06409    EA9F  A9 30        	LDA	#'0'			; set character = "0"
06410    EAA1  4C A2 EB     	JMP	LAB_2A89		; save last character, [EOT] and exit
06411    
06412    					; FAC1 is some non zero value
06413    LAB_2989
06414    EAA4  A9 00        	LDA	#$00			; clear (number exponent count)
06415    EAA6  E0 81        	CPX	#$81			; compare FAC1 exponent with $81 (>1.00000)
06416    
06417    EAA8  B0 09        	BCS	LAB_299A		; branch if FAC1=>1
06418    
06419    					; FAC1<1
06420    EAAA  A9 8E        	LDA	#<LAB_294F		; set pointer low byte to 1,000,000
06421    EAAC  A0 F1        	LDY	#>LAB_294F		; set pointer high byte to 1,000,000
06422    EAAE  20 2D E7     	JSR	LAB_25FB		; do convert AY, FCA1*(AY)
06423    EAB1  A9 FA        	LDA	#$FA			; set number exponent count (-6)
06424    LAB_299A
06425    EAB3  85 A8        	STA	numexp		; save number exponent count
06426    LAB_299C
06427    EAB5  A9 8A        	LDA	#<LAB_294B		; set pointer low byte to 999999.4375 (max before sci note)
06428    EAB7  A0 F1        	LDY	#>LAB_294B		; set pointer high byte to 999999.4375
06429    EAB9  20 0B E9     	JSR	LAB_27F8		; compare FAC1 with (AY)
06430    EABC  F0 1E        	BEQ	LAB_29C3		; exit if FAC1 = (AY)
06431    
06432    EABE  10 12        	BPL	LAB_29B9		; go do /10 if FAC1 > (AY)
06433    
06434    					; FAC1 < (AY)
06435    LAB_29A7
06436    EAC0  A9 86        	LDA	#<LAB_2947		; set pointer low byte to 99999.9375
06437    EAC2  A0 F1        	LDY	#>LAB_2947		; set pointer high byte to 99999.9375
06438    EAC4  20 0B E9     	JSR	LAB_27F8		; compare FAC1 with (AY)
06439    EAC7  F0 02        	BEQ	LAB_29B2		; branch if FAC1 = (AY) (allow decimal places)
06440    
06441    EAC9  10 0E        	BPL	LAB_29C0		; branch if FAC1 > (AY) (no decimal places)
06442    
06443    					; FAC1 <= (AY)
06444    LAB_29B2
06445    EACB  20 CB E7     	JSR	LAB_269E		; multiply by 10
06446    EACE  C6 A8        	DEC	numexp		; decrement number exponent count
06447    EAD0  D0 EE        	BNE	LAB_29A7		; go test again (branch always)
06448    
06449    LAB_29B9
06450    EAD2  20 E4 E7     	JSR	LAB_26B9		; divide by 10
06451    EAD5  E6 A8        	INC	numexp		; increment number exponent count
06452    EAD7  D0 DC        	BNE	LAB_299C		; go test again (branch always)
06453    
06454    ; now we have just the digits to do
06455    
06456    LAB_29C0
06457    EAD9  20 AE E5     	JSR	LAB_244E		; add 0.5 to FAC1 (round FAC1)
06458    LAB_29C3
06459    EADC  20 44 E9     	JSR	LAB_2831		; convert FAC1 floating-to-fixed
06460    EADF  A2 01        	LDX	#$01			; set default digits before dp = 1
06461    EAE1  A5 A8        	LDA	numexp		; get number exponent count
06462    EAE3  18           	CLC				; clear carry for add
06463    EAE4  69 07        	ADC	#$07			; up to 6 digits before point
06464    EAE6  30 09        	BMI	LAB_29D8		; if -ve then 1 digit before dp
06465    
06466    EAE8  C9 08        	CMP	#$08			; A>=8 if n>=1E6
06467    EAEA  B0 06        	BCS	LAB_29D9		; branch if >= $08
06468    
06469    					; carry is clear
06470    EAEC  69 FF        	ADC	#$FF			; take 1 from digit count
06471    EAEE  AA           	TAX				; copy to A
06472    EAEF  A9 02        	LDA	#$02			;.set exponent adjust
06473    LAB_29D8
06474    EAF1  38           	SEC				; set carry for subtract
06475    LAB_29D9
06476    EAF2  E9 02        	SBC	#$02			; -2
06477    EAF4  85 A9        	STA	expcnt		;.save exponent adjust
06478    EAF6  86 A8        	STX	numexp		; save digits before dp count
06479    EAF8  8A           	TXA				; copy to A
06480    EAF9  F0 02        	BEQ	LAB_29E4		; branch if no digits before dp
06481    
06482    EAFB  10 13        	BPL	LAB_29F7		; branch if digits before dp
06483    
06484    LAB_29E4
06485    EAFD  A4 BA        	LDY	Sendl			; get output string index
06486    EAFF  A9 2E        	LDA	#$2E			; character "."
06487    EB01  C8           	INY				; increment index
06488    EB02  99 EF 00     	STA	Decss,Y		; save to output string
06489    EB05  8A           	TXA				;.
06490    EB06  F0 06        	BEQ	LAB_29F5		;.
06491    
06492    EB08  A9 30        	LDA	#'0'			; character "0"
06493    EB0A  C8           	INY				; increment index
06494    EB0B  99 EF 00     	STA	Decss,Y		; save to output string
06495    LAB_29F5
06496    EB0E  84 BA        	STY	Sendl			; save output string index
06497    LAB_29F7
06498    EB10  A0 00        	LDY	#$00			; clear index (point to 100,000)
06499    EB12  A2 80        	LDX	#$80			; 
06500    LAB_29FB
06501    EB14  A5 AF        	LDA	FAC1_3		; get FAC1 mantissa3
06502    EB16  18           	CLC				; clear carry for add
06503    EB17  79 04 F2     	ADC	LAB_2A9C,Y		; add -ve LSB
06504    EB1A  85 AF        	STA	FAC1_3		; save FAC1 mantissa3
06505    EB1C  A5 AE        	LDA	FAC1_2		; get FAC1 mantissa2
06506    EB1E  79 03 F2     	ADC	LAB_2A9B,Y		; add -ve NMSB
06507    EB21  85 AE        	STA	FAC1_2		; save FAC1 mantissa2
06508    EB23  A5 AD        	LDA	FAC1_1		; get FAC1 mantissa1
06509    EB25  79 02 F2     	ADC	LAB_2A9A,Y		; add -ve MSB
06510    EB28  85 AD        	STA	FAC1_1		; save FAC1 mantissa1
06511    EB2A  E8           	INX				; 
06512    EB2B  B0 04        	BCS	LAB_2A18		; 
06513    
06514    EB2D  10 E5        	BPL	LAB_29FB		; not -ve so try again
06515    
06516    EB2F  30 02        	BMI	LAB_2A1A		; 
06517    
06518    LAB_2A18
06519    EB31  30 E1        	BMI	LAB_29FB		; 
06520    
06521    LAB_2A1A
06522    EB33  8A           	TXA				; 
06523    EB34  90 04        	BCC	LAB_2A21		; 
06524    
06525    EB36  49 FF        	EOR	#$FF			; 
06526    EB38  69 0A        	ADC	#$0A			; 
06527    LAB_2A21
06528    EB3A  69 2F        	ADC	#'0'-1		; add "0"-1 to result
06529    EB3C  C8           	INY				; increment index ..
06530    EB3D  C8           	INY				; .. to next less ..
06531    EB3E  C8           	INY				; .. power of ten
06532    EB3F  84 95        	STY	Cvaral		; save as current var address low byte
06533    EB41  A4 BA        	LDY	Sendl			; get output string index
06534    EB43  C8           	INY				; increment output string index
06535    EB44  AA           	TAX				; copy character to X
06536    EB45  29 7F        	AND	#$7F			; mask out top bit
06537    EB47  99 EF 00     	STA	Decss,Y		; save to output string
06538    EB4A  C6 A8        	DEC	numexp		; decrement # of characters before the dp
06539    EB4C  D0 06        	BNE	LAB_2A3B		; branch if still characters to do
06540    
06541    					; else output the point
06542    EB4E  A9 2E        	LDA	#$2E			; character "."
06543    EB50  C8           	INY				; increment output string index
06544    EB51  99 EF 00     	STA	Decss,Y		; save to output string
06545    LAB_2A3B
06546    EB54  84 BA        	STY	Sendl			; save output string index
06547    EB56  A4 95        	LDY	Cvaral		; get current var address low byte
06548    EB58  8A           	TXA				; get character back
06549    EB59  49 FF        	EOR	#$FF			; 
06550    EB5B  29 80        	AND	#$80			; 
06551    EB5D  AA           	TAX				; 
06552    EB5E  C0 12        	CPY	#$12			; compare index with max
06553    EB60  D0 B2        	BNE	LAB_29FB		; loop if not max
06554    
06555    					; now remove trailing zeroes
06556    EB62  A4 BA        	LDY	Sendl			; get output string index
06557    LAB_2A4B
06558    EB64  B9 EF 00     	LDA	Decss,Y		; get character from output string
06559    EB67  88           	DEY				; decrement output string index
06560    EB68  C9 30        	CMP	#'0'			; compare with "0"
06561    EB6A  F0 F8        	BEQ	LAB_2A4B		; loop until non "0" character found
06562    
06563    EB6C  C9 2E        	CMP	#'.'			; compare with "."
06564    EB6E  F0 01        	BEQ	LAB_2A58		; branch if was dp
06565    
06566    					; restore last character
06567    EB70  C8           	INY				; increment output string index
06568    LAB_2A58
06569    EB71  A9 2B        	LDA	#$2B			; character "+"
06570    EB73  A6 A9        	LDX	expcnt		; get exponent count
06571    EB75  F0 2E        	BEQ	LAB_2A8C		; if zero go set null terminator and exit
06572    
06573    					; exponent isn't zero so write exponent
06574    EB77  10 08        	BPL	LAB_2A68		; branch if exponent count +ve
06575    
06576    EB79  A9 00        	LDA	#$00			; clear A
06577    EB7B  38           	SEC				; set carry for subtract
06578    EB7C  E5 A9        	SBC	expcnt		; subtract exponent count adjust (convert -ve to +ve)
06579    EB7E  AA           	TAX				; copy exponent count to X
06580    EB7F  A9 2D        	LDA	#'-'			; character "-"
06581    LAB_2A68
06582    EB81  99 F1 00     	STA	Decss+2,Y		; save to output string
06583    EB84  A9 45        	LDA	#$45			; character "E"
06584    EB86  99 F0 00     	STA	Decss+1,Y		; save exponent sign to output string
06585    EB89  8A           	TXA				; get exponent count back
06586    EB8A  A2 2F        	LDX	#'0'-1		; one less than "0" character
06587    EB8C  38           	SEC				; set carry for subtract
06588    LAB_2A74
06589    EB8D  E8           	INX				; increment 10's character
06590    EB8E  E9 0A        	SBC	#$0A			;.subtract 10 from exponent count
06591    EB90  B0 FB        	BCS	LAB_2A74		; loop while still >= 0
06592    
06593    EB92  69 3A        	ADC	#':'			; add character ":" ($30+$0A, result is 10 less that value)
06594    EB94  99 F3 00     	STA	Decss+4,Y		; save to output string
06595    EB97  8A           	TXA				; copy 10's character
06596    EB98  99 F2 00     	STA	Decss+3,Y		; save to output string
06597    EB9B  A9 00        	LDA	#$00			; set null terminator
06598    EB9D  99 F4 00     	STA	Decss+5,Y		; save to output string
06599    EBA0  F0 08        	BEQ	LAB_2A91		; go set string pointer (AY) and exit (branch always)
06600    
06601    					; save last character, [EOT] and exit
06602    LAB_2A89
06603    EBA2  99 EF 00     	STA	Decss,Y		; save last character to output string
06604    
06605    					; set null terminator and exit
06606    LAB_2A8C
06607    EBA5  A9 00        	LDA	#$00			; set null terminator
06608    EBA7  99 F0 00     	STA	Decss+1,Y		; save after last character
06609    
06610    					; set string pointer (AY) and exit
06611    LAB_2A91
06612    EBAA  A9 F0        	LDA	#<Decssp1		; set result string low pointer
06613    EBAC  A0 00        	LDY	#>Decssp1		; set result string high pointer
06614    EBAE  60           	RTS
06615    
06616    ; perform power function
06617    
06618    LAB_POWER
06619    EBAF  F0 42        	BEQ	LAB_EXP		; go do  EXP()
06620    
06621    EBB1  A5 B3        	LDA	FAC2_e		; get FAC2 exponent
06622    EBB3  D0 03        	BNE	LAB_2ABF		; branch if FAC2<>0
06623    
06624    EBB5  4C 46 E6     	JMP	LAB_24F3		; clear FAC1 exponent and sign and return
06625    
06626    LAB_2ABF
06627    EBB8  A2 9C        	LDX	#<func_l		; set destination pointer low byte
06628    EBBA  A0 00        	LDY	#>func_l		; set destination pointer high byte
06629    EBBC  20 9B E8     	JSR	LAB_2778		; pack FAC1 into (XY)
06630    EBBF  A5 B7        	LDA	FAC2_s		; get FAC2 sign (b7)
06631    EBC1  10 0F        	BPL	LAB_2AD9		; branch if FAC2>0
06632    
06633    					; else FAC2 is -ve and can only be raised to an
06634    					; integer power which gives an x +j0 result
06635    EBC3  20 75 E9     	JSR	LAB_INT		; perform INT
06636    EBC6  A9 9C        	LDA	#<func_l		; set source pointer low byte
06637    EBC8  A0 00        	LDY	#>func_l		; set source pointer high byte
06638    EBCA  20 0B E9     	JSR	LAB_27F8		; compare FAC1 with (AY)
06639    EBCD  D0 03        	BNE	LAB_2AD9		; branch if FAC1 <> (AY) to allow Function Call error
06640    					; this will leave FAC1 -ve and cause a Function Call
06641    					; error when LOG() is called
06642    
06643    EBCF  98           	TYA				; clear sign b7
06644    EBD0  A4 5B        	LDY	Temp3			; save mantissa 3 from INT() function as sign in Y
06645    					; for possible later negation, b0
06646    LAB_2AD9
06647    EBD2  20 B9 E5     	JSR	LAB_279D		; save FAC1 sign and copy ABS(FAC2) to FAC1
06648    EBD5  98           	TYA				; copy sign back ..
06649    EBD6  48           	PHA				; .. and save it
06650    EBD7  20 EF E6     	JSR	LAB_LOG		; do LOG(n)
06651    EBDA  A9 9C        	LDA	#<garb_l		; set pointer low byte
06652    EBDC  A0 00        	LDY	#>garb_l		; set pointer high byte
06653    EBDE  20 2D E7     	JSR	LAB_25FB		; do convert AY, FCA1*(AY) (square the value)
06654    EBE1  20 F3 EB     	JSR	LAB_EXP		; go do EXP(n)
06655    EBE4  68           	PLA				; pull sign from stack
06656    EBE5  4A           	LSR				; b0 is to be tested, shift to Cb
06657    EBE6  90 0A        	BCC	LAB_2AF9		; if no bit then exit
06658    
06659    					; Perform negation
06660    ; do - FAC1
06661    
06662    LAB_GTHAN
06663    EBE8  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
06664    EBEA  F0 06        	BEQ	LAB_2AF9		; exit if FAC1_e = $00
06665    
06666    EBEC  A5 B0        	LDA	FAC1_s		; get FAC1 sign (b7)
06667    EBEE  49 FF        	EOR	#$FF			; complement it
06668    EBF0  85 B0        	STA	FAC1_s		; save FAC1 sign (b7)
06669    LAB_2AF9
06670    EBF2  60           	RTS
06671    
06672    ; perform EXP()	(x^e)
06673    
06674    LAB_EXP
06675    EBF3  A9 92        	LDA	#<LAB_2AFA		; set 1.443 pointer low byte
06676    EBF5  A0 F1        	LDY	#>LAB_2AFA		; set 1.443 pointer high byte
06677    EBF7  20 2D E7     	JSR	LAB_25FB		; do convert AY, FCA1*(AY)
06678    EBFA  A5 B9        	LDA	FAC1_r		; get FAC1 rounding byte
06679    EBFC  69 50        	ADC	#$50			; +$50/$100
06680    EBFE  90 03        	BCC	LAB_2B2B		; skip rounding if no carry
06681    
06682    EC00  20 D5 E8     	JSR	LAB_27C2		; round FAC1 (no check)
06683    LAB_2B2B
06684    EC03  85 A3        	STA	FAC2_r		; save FAC2 rounding byte
06685    EC05  20 C1 E8     	JSR	LAB_27AE		; copy FAC1 to FAC2
06686    EC08  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
06687    EC0A  C9 88        	CMP	#$88			; compare with EXP limit (256d)
06688    EC0C  90 03        	BCC	LAB_2B39		; branch if less
06689    
06690    LAB_2B36
06691    EC0E  20 C2 E7     	JSR	LAB_2690		; handle overflow and underflow
06692    LAB_2B39
06693    EC11  20 75 E9     	JSR	LAB_INT		; perform INT
06694    EC14  A5 5B        	LDA	Temp3			; get mantissa 3 from INT() function
06695    EC16  18           	CLC				; clear carry for add
06696    EC17  69 81        	ADC	#$81			; normalise +1
06697    EC19  F0 F3        	BEQ	LAB_2B36		; if $00 go handle overflow
06698    
06699    EC1B  38           	SEC				; set carry for subtract
06700    EC1C  E9 01        	SBC	#$01			; now correct for exponent
06701    EC1E  48           	PHA				; save FAC2 exponent
06702    
06703    					; swap FAC1 and FAC2
06704    EC1F  A2 04        	LDX	#$04			; 4 bytes to do
06705    LAB_2B49
06706    EC21  B5 B3        	LDA	FAC2_e,X		; get FAC2,X
06707    EC23  B4 AC        	LDY	FAC1_e,X		; get FAC1,X
06708    EC25  95 AC        	STA	FAC1_e,X		; save FAC1,X
06709    EC27  94 B3        	STY	FAC2_e,X		; save FAC2,X
06710    EC29  CA           	DEX				; decrement count/index
06711    EC2A  10 F5        	BPL	LAB_2B49		; loop if not all done
06712    
06713    EC2C  A5 A3        	LDA	FAC2_r		; get FAC2 rounding byte
06714    EC2E  85 B9        	STA	FAC1_r		; save as FAC1 rounding byte
06715    EC30  20 9A E5     	JSR	LAB_SUBTRACT	; perform subtraction, FAC2 from FAC1
06716    EC33  20 E8 EB     	JSR	LAB_GTHAN		; do - FAC1
06717    EC36  A9 96        	LDA	#<LAB_2AFE		; set counter pointer low byte
06718    EC38  A0 F1        	LDY	#>LAB_2AFE		; set counter pointer high byte
06719    EC3A  20 5B EC     	JSR	LAB_2B84		; go do series evaluation
06720    EC3D  A9 00        	LDA	#$00			; clear A
06721    EC3F  85 B8        	STA	FAC_sc		; clear sign compare (FAC1 EOR FAC2)
06722    EC41  68           	PLA				;.get saved FAC2 exponent
06723    EC42  4C A7 E7     	JMP	LAB_2675		; test and adjust accumulators and return
06724    
06725    ; ^2 then series evaluation
06726    
06727    LAB_2B6E
06728    EC45  85 BA        	STA	Cptrl			; save count pointer low byte
06729    EC47  84 BB        	STY	Cptrh			; save count pointer high byte
06730    EC49  20 91 E8     	JSR	LAB_276E		; pack FAC1 into Adatal
06731    EC4C  A9 A4        	LDA	#<Adatal		; set pointer low byte (Y already $00)
06732    EC4E  20 2D E7     	JSR	LAB_25FB		; do convert AY, FCA1*(AY)
06733    EC51  20 5F EC     	JSR	LAB_2B88		; go do series evaluation
06734    EC54  A9 A4        	LDA	#<Adatal		; pointer to original # low byte
06735    EC56  A0 00        	LDY	#>Adatal		; pointer to original # high byte
06736    EC58  4C 2D E7     	JMP	LAB_25FB		; do convert AY, FCA1*(AY) and return
06737    
06738    ; series evaluation
06739    
06740    LAB_2B84
06741    EC5B  85 BA        	STA	Cptrl			; save count pointer low byte
06742    EC5D  84 BB        	STY	Cptrh			; save count pointer high byte
06743    LAB_2B88
06744    EC5F  A2 A8        	LDX	#<numexp		; set pointer low byte
06745    EC61  20 93 E8     	JSR	LAB_2770		; set pointer high byte and pack FAC1 into numexp
06746    EC64  B1 BA        	LDA	(Cptrl),Y		; get constants count
06747    EC66  85 B1        	STA	numcon		; save constants count
06748    EC68  A4 BA        	LDY	Cptrl			; get count pointer low byte
06749    EC6A  C8           	INY				; increment it (now constants pointer)
06750    EC6B  98           	TYA				; copy it
06751    EC6C  D0 02        	BNE	LAB_2B97		; skip next if no overflow
06752    
06753    EC6E  E6 BB        	INC	Cptrh			; else increment high byte
06754    LAB_2B97
06755    EC70  85 BA        	STA	Cptrl			; save low byte
06756    EC72  A4 BB        	LDY	Cptrh			; get high byte
06757    LAB_2B9B
06758    EC74  20 2D E7     	JSR	LAB_25FB		; do convert AY, FCA1*(AY)
06759    EC77  A5 BA        	LDA	Cptrl			; get constants pointer low byte
06760    EC79  A4 BB        	LDY	Cptrh			; get constants pointer high byte
06761    EC7B  18           	CLC				; clear carry for add
06762    EC7C  69 04        	ADC	#$04			; +4 to  low pointer (4 bytes per constant)
06763    EC7E  90 01        	BCC	LAB_2BA8		; skip next if no overflow
06764    
06765    EC80  C8           	INY				; increment high byte
06766    LAB_2BA8
06767    EC81  85 BA        	STA	Cptrl			; save pointer low byte
06768    EC83  84 BB        	STY	Cptrh			; save pointer high byte
06769    EC85  20 B2 E5     	JSR	LAB_246C		; add (AY) to FAC1
06770    EC88  A9 A8        	LDA	#<numexp		; set pointer low byte to partial @ numexp
06771    EC8A  A0 00        	LDY	#>numexp		; set pointer high byte to partial @ numexp
06772    EC8C  C6 B1        	DEC	numcon		; decrement constants count
06773    EC8E  D0 E4        	BNE	LAB_2B9B		; loop until all done
06774    
06775    EC90  60           	RTS
06776    
06777    ; RND(n), 32 bit Galoise version. make n=0 for 19th next number in sequence or n<>0
06778    ; to get 19th next number in sequence after seed n. This version of the PRNG uses
06779    ; the Galois method and a sample of 65536 bytes produced gives the following values.
06780    
06781    ; Entropy = 7.997442 bits per byte
06782    ; Optimum compression would reduce these 65536 bytes by 0 percent
06783    
06784    ; Chi square distribution for 65536 samples is 232.01, and
06785    ; randomly would exceed this value 75.00 percent of the time
06786    
06787    ; Arithmetic mean value of data bytes is 127.6724, 127.5 would be random
06788    ; Monte Carlo value for Pi is 3.122871269, error 0.60 percent
06789    ; Serial correlation coefficient is -0.000370, totally uncorrelated would be 0.0
06790    
06791    LAB_RND
06792    EC91  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
06793    EC93  F0 07        	BEQ	NextPRN		; do next random # if zero
06794    
06795    					; else get seed into random number store
06796    EC95  A2 D8        	LDX	#Rbyte4		; set PRNG pointer low byte
06797    EC97  A0 00        	LDY	#$00			; set PRNG pointer high byte
06798    EC99  20 9B E8     	JSR	LAB_2778		; pack FAC1 into (XY)
06799    NextPRN
06800    EC9C  A2 AF        	LDX	#$AF			; set EOR byte
06801    EC9E  A0 13        	LDY	#$13			; do this nineteen times
06802    LoopPRN
06803    ECA0  06 D9        	ASL	Rbyte1		; shift PRNG most significant byte
06804    ECA2  26 DA        	ROL	Rbyte2		; shift PRNG middle byte
06805    ECA4  26 DB        	ROL	Rbyte3		; shift PRNG least significant byte
06806    ECA6  26 D8        	ROL	Rbyte4		; shift PRNG extra byte
06807    ECA8  90 05        	BCC	Ninc1			; branch if bit 32 clear
06808    
06809    ECAA  8A           	TXA				; set EOR byte
06810    ECAB  45 D9        	EOR	Rbyte1		; EOR PRNG extra byte
06811    ECAD  85 D9        	STA	Rbyte1		; save new PRNG extra byte
06812    Ninc1
06813    ECAF  88           	DEY				; decrement loop count
06814    ECB0  D0 EE        	BNE	LoopPRN		; loop if not all done
06815    
06816    ECB2  A2 02        	LDX	#$02			; three bytes to copy
06817    CopyPRNG
06818    ECB4  B5 D9        	LDA	Rbyte1,X		; get PRNG byte
06819    ECB6  95 AD        	STA	FAC1_1,X		; save FAC1 byte
06820    ECB8  CA           	DEX
06821    ECB9  10 F9        	BPL	CopyPRNG		; loop if not complete
06822    
06823    ECBB  A9 80        	LDA	#$80			; set the exponent
06824    ECBD  85 AC        	STA	FAC1_e		; save FAC1 exponent
06825    
06826    ECBF  0A           	ASL				; clear A
06827    ECC0  85 B0        	STA	FAC1_s		; save FAC1 sign
06828    
06829    ECC2  4C 28 E6     	JMP	LAB_24D5		; normalise FAC1 and return
06830    
06831    ; perform COS()
06832    
06833    LAB_COS
06834    ECC5  A9 B3        	LDA	#<LAB_2C78		; set (pi/2) pointer low byte
06835    ECC7  A0 F1        	LDY	#>LAB_2C78		; set (pi/2) pointer high byte
06836    ECC9  20 B2 E5     	JSR	LAB_246C		; add (AY) to FAC1
06837    
06838    ; perform SIN()
06839    
06840    LAB_SIN
06841    ECCC  20 BE E8     	JSR	LAB_27AB		; round and copy FAC1 to FAC2
06842    ECCF  A9 C8        	LDA	#<LAB_2C7C		; set (2*pi) pointer low byte
06843    ECD1  A0 F1        	LDY	#>LAB_2C7C		; set (2*pi) pointer high byte
06844    ECD3  A6 B7        	LDX	FAC2_s		; get FAC2 sign (b7)
06845    ECD5  20 ED E7     	JSR	LAB_26C2		; divide by (AY) (X=sign)
06846    ECD8  20 BE E8     	JSR	LAB_27AB		; round and copy FAC1 to FAC2
06847    ECDB  20 75 E9     	JSR	LAB_INT		; perform INT
06848    ECDE  A9 00        	LDA	#$00			; clear byte
06849    ECE0  85 B8        	STA	FAC_sc		; clear sign compare (FAC1 EOR FAC2)
06850    ECE2  20 9A E5     	JSR	LAB_SUBTRACT	; perform subtraction, FAC2 from FAC1
06851    ECE5  A9 FA        	LDA	#<LAB_2C80		; set 0.25 pointer low byte
06852    ECE7  A0 F1        	LDY	#>LAB_2C80		; set 0.25 pointer high byte
06853    ECE9  20 97 E5     	JSR	LAB_2455		; perform subtraction, (AY) from FAC1
06854    ECEC  A5 B0        	LDA	FAC1_s		; get FAC1 sign (b7)
06855    ECEE  48           	PHA				; save FAC1 sign
06856    ECEF  10 0D        	BPL	LAB_2C35		; branch if +ve
06857    
06858    					; FAC1 sign was -ve
06859    ECF1  20 AE E5     	JSR	LAB_244E		; add 0.5 to FAC1
06860    ECF4  A5 B0        	LDA	FAC1_s		; get FAC1 sign (b7)
06861    ECF6  30 09        	BMI	LAB_2C38		; branch if -ve
06862    
06863    ECF8  A5 63        	LDA	Cflag			; get comparison evaluation flag
06864    ECFA  49 FF        	EOR	#$FF			; toggle flag
06865    ECFC  85 63        	STA	Cflag			; save comparison evaluation flag
06866    LAB_2C35
06867    ECFE  20 E8 EB     	JSR	LAB_GTHAN		; do - FAC1
06868    LAB_2C38
06869    ED01  A9 FA        	LDA	#<LAB_2C80		; set 0.25 pointer low byte
06870    ED03  A0 F1        	LDY	#>LAB_2C80		; set 0.25 pointer high byte
06871    ED05  20 B2 E5     	JSR	LAB_246C		; add (AY) to FAC1
06872    ED08  68           	PLA				; restore FAC1 sign
06873    ED09  10 03        	BPL	LAB_2C45		; branch if was +ve
06874    
06875    					; else correct FAC1
06876    ED0B  20 E8 EB     	JSR	LAB_GTHAN		; do - FAC1
06877    LAB_2C45
06878    ED0E  A9 B7        	LDA	#<LAB_2C84		; set pointer low byte to counter
06879    ED10  A0 F1        	LDY	#>LAB_2C84		; set pointer high byte to counter
06880    ED12  4C 45 EC     	JMP	LAB_2B6E		; ^2 then series evaluation and return
06881    
06882    ; perform TAN()
06883    
06884    LAB_TAN
06885    ED15  20 91 E8     	JSR	LAB_276E		; pack FAC1 into Adatal
06886    ED18  A9 00        	LDA	#$00			; clear byte
06887    ED1A  85 63        	STA	Cflag			; clear comparison evaluation flag
06888    ED1C  20 CC EC     	JSR	LAB_SIN		; go do SIN(n)
06889    ED1F  A2 9C        	LDX	#<func_l		; set sin(n) pointer low byte
06890    ED21  A0 00        	LDY	#>func_l		; set sin(n) pointer high byte
06891    ED23  20 9B E8     	JSR	LAB_2778		; pack FAC1 into (XY)
06892    ED26  A9 A4        	LDA	#<Adatal		; set n pointer low addr
06893    ED28  A0 00        	LDY	#>Adatal		; set n pointer high addr
06894    ED2A  20 71 E8     	JSR	LAB_UFAC		; unpack memory (AY) into FAC1
06895    ED2D  A9 00        	LDA	#$00			; clear byte
06896    ED2F  85 B0        	STA	FAC1_s		; clear FAC1 sign (b7)
06897    ED31  A5 63        	LDA	Cflag			; get comparison evaluation flag
06898    ED33  20 3D ED     	JSR	LAB_2C74		; save flag and go do series evaluation
06899    
06900    ED36  A9 9C        	LDA	#<func_l		; set sin(n) pointer low byte
06901    ED38  A0 00        	LDY	#>func_l		; set sin(n) pointer high byte
06902    ED3A  4C F5 E7     	JMP	LAB_26CA		; convert AY and do (AY)/FAC1
06903    
06904    LAB_2C74
06905    ED3D  48           	PHA				; save comparison evaluation flag
06906    ED3E  4C FE EC     	JMP	LAB_2C35		; go do series evaluation
06907    
06908    ; perform USR()
06909    
06910    LAB_USR
06911    ED41  20 0A 00     	JSR	Usrjmp		; call user code
06912    ED44  4C E3 DB     	JMP	LAB_1BFB		; scan for ")", else do syntax error then warm start
06913    
06914    ; perform ATN()
06915    
06916    LAB_ATN
06917    ED47  A5 B0        	LDA	FAC1_s		; get FAC1 sign (b7)
06918    ED49  48           	PHA				; save sign
06919    ED4A  10 03        	BPL	LAB_2CA1		; branch if +ve
06920    
06921    ED4C  20 E8 EB     	JSR	LAB_GTHAN		; else do - FAC1
06922    LAB_2CA1
06923    ED4F  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
06924    ED51  48           	PHA				; push exponent
06925    ED52  C9 81        	CMP	#$81			; compare with 1
06926    ED54  90 07        	BCC	LAB_2CAF		; branch if FAC1<1
06927    
06928    ED56  A9 ED        	LDA	#<LAB_259C		; set 1 pointer low byte
06929    ED58  A0 F1        	LDY	#>LAB_259C		; set 1 pointer high byte
06930    ED5A  20 F5 E7     	JSR	LAB_26CA		; convert AY and do (AY)/FAC1
06931    LAB_2CAF
06932    ED5D  A9 CC        	LDA	#<LAB_2CC9		; set pointer low byte to counter
06933    ED5F  A0 F1        	LDY	#>LAB_2CC9		; set pointer high byte to counter
06934    ED61  20 45 EC     	JSR	LAB_2B6E		; ^2 then series evaluation
06935    ED64  68           	PLA				; restore old FAC1 exponent
06936    ED65  C9 81        	CMP	#$81			; compare with 1
06937    ED67  90 07        	BCC	LAB_2CC2		; branch if FAC1<1
06938    
06939    ED69  A9 B3        	LDA	#<LAB_2C78		; set (pi/2) pointer low byte
06940    ED6B  A0 F1        	LDY	#>LAB_2C78		; set (pi/2) pointer high byte
06941    ED6D  20 97 E5     	JSR	LAB_2455		; perform subtraction, (AY) from FAC1
06942    LAB_2CC2
06943    ED70  68           	PLA				; restore FAC1 sign
06944    ED71  10 16        	BPL	LAB_2D04		; exit if was +ve
06945    
06946    ED73  4C E8 EB     	JMP	LAB_GTHAN		; else do - FAC1 and return
06947    
06948    ; perform BITSET
06949    
06950    LAB_BITSET
06951    ED76  20 CC E4     	JSR	LAB_GADB		; get two parameters for POKE or WAIT
06952    ED79  E0 08        	CPX	#$08			; only 0 to 7 are allowed
06953    ED7B  B0 20        	BCS	FCError		; branch if > 7
06954    
06955    ED7D  A9 00        	LDA	#$00			; clear A
06956    ED7F  38           	SEC				; set the carry
06957    S_Bits
06958    ED80  2A           	ROL				; shift bit
06959    ED81  CA           	DEX				; decrement bit number
06960    ED82  10 FC        	BPL	S_Bits		; loop if still +ve
06961    
06962    ED84  E8           	INX				; make X = $00
06963    ED85  01 11        	ORA	(Itempl,X)		; or with byte via temporary integer (addr)
06964    ED87  81 11        	STA	(Itempl,X)		; save byte via temporary integer (addr)
06965    LAB_2D04
06966    ED89  60           	RTS
06967    
06968    ; perform BITCLR
06969    
06970    LAB_BITCLR
06971    ED8A  20 CC E4     	JSR	LAB_GADB		; get two parameters for POKE or WAIT
06972    ED8D  E0 08        	CPX	#$08			; only 0 to 7 are allowed
06973    ED8F  B0 0C        	BCS	FCError		; branch if > 7
06974    
06975    ED91  A9 FF        	LDA	#$FF			; set A
06976    S_Bitc
06977    ED93  2A           	ROL				; shift bit
06978    ED94  CA           	DEX				; decrement bit number
06979    ED95  10 FC        	BPL	S_Bitc		; loop if still +ve
06980    
06981    ED97  E8           	INX				; make X = $00
06982    ED98  21 11        	AND	(Itempl,X)		; and with byte via temporary integer (addr)
06983    ED9A  81 11        	STA	(Itempl,X)		; save byte via temporary integer (addr)
06984    ED9C  60           	RTS
06985    
06986    FCError
06987    ED9D  4C 1D DF     	JMP	LAB_FCER		; do function call error then warm start
06988    
06989    ; perform BITTST()
06990    
06991    LAB_BTST
06992    EDA0  20 BC 00     	JSR	LAB_IGBY		; increment BASIC pointer
06993    EDA3  20 CC E4     	JSR	LAB_GADB		; get two parameters for POKE or WAIT
06994    EDA6  E0 08        	CPX	#$08			; only 0 to 7 are allowed
06995    EDA8  B0 F3        	BCS	FCError		; branch if > 7
06996    
06997    EDAA  20 C2 00     	JSR	LAB_GBYT		; get next BASIC byte
06998    EDAD  C9 29        	CMP	#')'			; is next character ")"
06999    EDAF  F0 03        	BEQ	TST_OK		; if ")" go do rest of function
07000    
07001    EDB1  4C F6 DB     	JMP	LAB_SNER		; do syntax error then warm start
07002    
07003    TST_OK
07004    EDB4  20 BC 00     	JSR	LAB_IGBY		; update BASIC execute pointer (to character past ")")
07005    EDB7  A9 00        	LDA	#$00			; clear A
07006    EDB9  38           	SEC				; set the carry
07007    T_Bits
07008    EDBA  2A           	ROL				; shift bit
07009    EDBB  CA           	DEX				; decrement bit number
07010    EDBC  10 FC        	BPL	T_Bits		; loop if still +ve
07011    
07012    EDBE  E8           	INX				; make X = $00
07013    EDBF  21 11        	AND	(Itempl,X)		; AND with byte via temporary integer (addr)
07014    EDC1  F0 02        	BEQ	LAB_NOTT		; branch if zero (already correct)
07015    
07016    EDC3  A9 FF        	LDA	#$FF			; set for -1 result
07017    LAB_NOTT
07018    EDC5  4C EE E8     	JMP	LAB_27DB		; go do SGN tail
07019    
07020    ; perform BIN$()
07021    
07022    LAB_BINS
07023    EDC8  E0 19        	CPX	#$19			; max + 1
07024    EDCA  B0 48        	BCS	BinFErr		; exit if too big ( > or = )
07025    
07026    EDCC  86 78        	STX	TempB			; save # of characters ($00 = leading zero remove)
07027    EDCE  A9 18        	LDA	#$18			; need A byte long space
07028    EDD0  20 2E E1     	JSR	LAB_MSSP		; make string space A bytes long
07029    EDD3  A0 17        	LDY	#$17			; set index
07030    EDD5  A2 18        	LDX	#$18			; character count
07031    NextB1
07032    EDD7  46 11        	LSR	nums_1		; shift highest byte
07033    EDD9  66 12        	ROR	nums_2		; shift middle byte
07034    EDDB  66 13        	ROR	nums_3		; shift lowest byte bit 0 to carry
07035    EDDD  8A           	TXA				; load with "0"/2
07036    EDDE  2A           	ROL				; shift in carry
07037    EDDF  91 AD        	STA	(str_pl),Y		; save to temp string + index
07038    EDE1  88           	DEY				; decrement index
07039    EDE2  10 F3        	BPL	NextB1		; loop if not done
07040    
07041    EDE4  A5 78        	LDA	TempB			; get # of characters
07042    EDE6  F0 0A        	BEQ	EndBHS		; branch if truncate
07043    
07044    EDE8  AA           	TAX				; copy length to X
07045    EDE9  38           	SEC				; set carry for add !
07046    EDEA  49 FF        	EOR	#$FF			; 1's complement
07047    EDEC  69 18        	ADC	#$18			; add 24d
07048    EDEE  F0 1C        	BEQ	GoPr2			; if zero print whole string
07049    
07050    EDF0  D0 0F        	BNE	GoPr1			; else go make output string
07051    	
07052    ; this is the exit code and is also used by HEX$()
07053    ; truncate string to remove leading "0"s
07054    
07055    EndBHS
07056    EDF2  A8           	TAY				; clear index (A=0, X=length here)
07057    NextB2
07058    EDF3  B1 AD        	LDA	(str_pl),Y		; get character from string
07059    EDF5  C9 30        	CMP	#'0'			; compare with "0"
07060    EDF7  D0 07        	BNE	GoPr			; if not "0" then go print string from here
07061    
07062    EDF9  CA           	DEX				; decrement character count
07063    EDFA  F0 03        	BEQ	GoPr3			; if zero then end of string so go print it
07064    
07065    EDFC  C8           	INY				; else increment index
07066    EDFD  10 F4        	BPL	NextB2		; loop always
07067    
07068    ; make fixed length output string - ignore overflows!
07069    
07070    GoPr3
07071    EDFF  E8           	INX				; need at least 1 character
07072    GoPr
07073    EE00  98           	TYA				; copy result
07074    GoPr1
07075    EE01  18           	CLC				; clear carry for add
07076    EE02  65 AD        	ADC	str_pl		; add low address
07077    EE04  85 AD        	STA	str_pl		; save low address
07078    EE06  A9 00        	LDA	#$00			; do high byte
07079    EE08  65 AE        	ADC	str_ph		; add high address
07080    EE0A  85 AE        	STA	str_ph		; save high address
07081    GoPr2
07082    EE0C  86 AC        	STX	str_ln		; X holds string length
07083    EE0E  20 BC 00     	JSR	LAB_IGBY		; update BASIC execute pointer (to character past ")")
07084    EE11  4C 79 E1     	JMP	LAB_RTST		; check for space on descriptor stack then put address
07085    					; and length on descriptor stack and update stack pointers
07086    
07087    BinFErr
07088    EE14  4C 1D DF     	JMP	LAB_FCER		; do function call error then warm start
07089    
07090    ; perform HEX$()
07091    
07092    LAB_HEXS
07093    EE17  E0 07        	CPX	#$07			; max + 1
07094    EE19  B0 F9        	BCS	BinFErr		; exit if too big ( > or = )
07095    
07096    EE1B  86 78        	STX	TempB			; save # of characters
07097    
07098    EE1D  A9 06        	LDA	#$06			; need 6 bytes for string
07099    EE1F  20 2E E1     	JSR	LAB_MSSP		; make string space A bytes long
07100    EE22  A0 05        	LDY	#$05			; set string index
07101    
07102    ;	SED				; need decimal mode for nibble convert - patched
07103    EE24  A5 13        	LDA	nums_3		; get lowest byte
07104    EE26  20 43 EE     	JSR	LAB_A2HX		; convert A to ASCII hex byte and output
07105    EE29  A5 12        	LDA	nums_2		; get middle byte
07106    EE2B  20 43 EE     	JSR	LAB_A2HX		; convert A to ASCII hex byte and output
07107    EE2E  A5 11        	LDA	nums_1		; get highest byte
07108    EE30  20 43 EE     	JSR	LAB_A2HX		; convert A to ASCII hex byte and output
07109    ;	CLD				; back to binary - patched
07110    
07111    EE33  A2 06        	LDX	#$06			; character count
07112    EE35  A5 78        	LDA	TempB			; get # of characters
07113    EE37  F0 B9        	BEQ	EndBHS		; branch if truncate
07114    
07115    EE39  AA           	TAX				; copy length to X
07116    EE3A  38           	SEC				; set carry for add !
07117    EE3B  49 FF        	EOR	#$FF			; 1's complement
07118    EE3D  69 06        	ADC	#$06			; add 6d
07119    EE3F  F0 CB        	BEQ	GoPr2			; if zero print whole string
07120    
07121    EE41  D0 BE        	BNE	GoPr1			; else go make output string (branch always)
07122    
07123    ; convert A to ASCII hex byte and output .. note set decimal mode before calling
07124    
07125    LAB_A2HX
07126    EE43  AA           	TAX				; save byte
07127    EE44  29 0F        	AND	#$0F			; mask off top bits
07128    EE46  20 4E EE     	JSR	LAB_AL2X		; convert low nibble to ASCII and output
07129    EE49  8A           	TXA				; get byte back
07130    EE4A  4A           	LSR				; /2	shift high nibble to low nibble
07131    EE4B  4A           	LSR				; /4
07132    EE4C  4A           	LSR				; /8
07133    EE4D  4A           	LSR				; /16
07134    LAB_AL2X
07135    EE4E  C9 0A        	CMP	#$0A			; set carry for +1 if >9
07136    ; added patch to circumvent using undocumented decimal ops
07137    EE50  90 02          BCC   LAB_AL20      ; skip adjust if <= 9
07138    EE52  69 06          ADC   #$06          ; adjust for A to F
07139    LAB_AL20
07140    ; end of patch
07141    EE54  69 30        	ADC	#'0'			; add ASCII "0"
07142    EE56  91 AD        	STA	(str_pl),Y		; save to temp string
07143    EE58  88           	DEY				; decrement counter
07144    EE59  60           	RTS
07145    
07146    LAB_NLTO
07147    EE5A  85 AC        	STA	FAC1_e		; save FAC1 exponent
07148    EE5C  A9 00        	LDA	#$00			; clear sign compare
07149    LAB_MLTE
07150    EE5E  85 B8        	STA	FAC_sc		; save sign compare (FAC1 EOR FAC2)
07151    EE60  8A           	TXA				; restore character
07152    EE61  20 39 EA     	JSR	LAB_2912		; evaluate new ASCII digit
07153    
07154    ; gets here if the first character was "$" for hex
07155    ; get hex number
07156    
07157    LAB_CHEX
07158    EE64  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory
07159    EE67  90 0A        	BCC	LAB_ISHN		; branch if numeric character
07160    
07161    EE69  09 20        	ORA	#$20			; case convert, allow "A" to "F" and "a" to "f"
07162    EE6B  E9 61        	SBC	#'a'			; subtract "a" (carry set here)
07163    EE6D  C9 06        	CMP	#$06			; compare normalised with $06 (max+1)
07164    EE6F  B0 2A        	BCS	LAB_EXCH		; exit if >"f" or <"0"
07165    
07166    EE71  69 0A        	ADC	#$0A			; convert to nibble
07167    LAB_ISHN
07168    EE73  29 0F        	AND	#$0F			; convert to binary
07169    EE75  AA           	TAX				; save nibble
07170    EE76  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
07171    EE78  F0 E4        	BEQ	LAB_MLTE		; skip multiply if zero
07172    
07173    EE7A  69 04        	ADC	#$04			; add four to exponent (*16 - carry clear here)
07174    EE7C  90 DC        	BCC	LAB_NLTO		; if no overflow do evaluate digit
07175    
07176    LAB_MLTO
07177    EE7E  4C B7 E6     	JMP	LAB_2564		; do overflow error and warm start
07178    
07179    LAB_NXCH
07180    EE81  AA           	TAX				; save bit
07181    EE82  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
07182    EE84  F0 06        	BEQ	LAB_MLBT		; skip multiply if zero
07183    
07184    EE86  E6 AC        	INC	FAC1_e		; increment FAC1 exponent (*2)
07185    EE88  F0 F4        	BEQ	LAB_MLTO		; do overflow error if = $00
07186    
07187    EE8A  A9 00        	LDA	#$00			; clear sign compare
07188    LAB_MLBT
07189    EE8C  85 B8        	STA	FAC_sc		; save sign compare (FAC1 EOR FAC2)
07190    EE8E  8A           	TXA				; restore bit
07191    EE8F  20 39 EA     	JSR	LAB_2912		; evaluate new ASCII digit
07192    
07193    ; gets here if the first character was  "%" for binary
07194    ; get binary number
07195    
07196    LAB_CBIN
07197    EE92  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory
07198    EE95  49 30        	EOR	#'0'			; convert "0" to 0 etc.
07199    EE97  C9 02        	CMP	#$02			; compare with max+1
07200    EE99  90 E6        	BCC	LAB_NXCH		; branch exit if < 2
07201    
07202    LAB_EXCH
07203    EE9B  4C 1E EA     	JMP	LAB_28F6		; evaluate -ve flag and return
07204    
07205    ; ctrl-c check routine. includes limited "life" byte save for INGET routine
07206    ; now also the code that checks to see if an interrupt has occurred
07207    
07208    CTRLC
07209    EE9E  AD 00 02     	LDA	ccflag		; get [CTRL-C] check flag
07210    EEA1  D0 18        	BNE	LAB_FBA2		; exit if inhibited
07211    
07212    EEA3  20 F7 F0     	JSR	V_INPT		; scan input device
07213    EEA6  90 0B        	BCC	LAB_FBA0		; exit if buffer empty
07214    
07215    EEA8  8D 01 02     	STA	ccbyte		; save received byte
07216    EEAB  A2 20        	LDX	#$20			; "life" timer for bytes
07217    EEAD  8E 02 02     	STX	ccnull		; set countdown
07218    EEB0  4C 0B D5     	JMP	LAB_1636		; return to BASIC
07219    
07220    LAB_FBA0
07221    EEB3  AE 02 02     	LDX	ccnull		; get countdown byte
07222    EEB6  F0 03        	BEQ	LAB_FBA2		; exit if finished
07223    
07224    EEB8  CE 02 02     	DEC	ccnull		; else decrement countdown
07225    
07226    ; check interrupts
07227    
07228    LAB_FBA2
07229    EEBB  A5 DC        	LDA	NmiBase		; test NMI
07230    EEBD  C9 E0        	CMP	#$E0			; 11100000 NMI setup, enabled & flagged?
07231    EEBF  F0 0D        	BEQ	take_NMI
07232    EEC1  A5 DF        	LDA	IrqBase		; test IRQ
07233    EEC3  30 02        	BMI	handle_IRQ		; BASIC is handling IRQ?
07234    EEC5  58           	CLI				; allow background interrupts
07235    skip_take_IRQ
07236    EEC6  60           	RTS
07237    handle_IRQ
07238    EEC7  C9 E0        	CMP	#$E0			; 11100000 IRQ setup, enabled & flagged?
07239    EEC9  D0 FB        	BNE	skip_take_IRQ
07240    EECB  A0 DF        	LDY	#IrqBase		; set pointer to IRQ values
07241    	.byte	$2C			; skip next instruction
07242    take_NMI
07243    EECE  A0 DC        	LDY	#NmiBase		; set pointer to NMI values
07244    
07245    ; we disable the interrupt here and make two new commands RETIRQ and RETNMI to
07246    ; automatically enable the interrupt when we exit
07247    
07248    EED0  29 80        	AND	#$80			; 10000000 keep setup bit
07249    EED2  99 00 00     	STA	PLUS_0,Y		; save interrupt flag byte
07250    
07251    EED5  A9 05        	LDA	#$05			; need 5 bytes for GOSUB
07252    EED7  20 F5 D0     	JSR	LAB_1212		; check room on stack for A bytes
07253    EEDA  A5 C4        	LDA	Bpntrh		; get BASIC execute pointer high byte
07254    EEDC  48           	PHA				; push on stack
07255    EEDD  A5 C3        	LDA	Bpntrl		; get BASIC execute pointer low byte
07256    EEDF  48           	PHA				; push on stack
07257    EEE0  A5 88        	LDA	Clineh		; get current line high byte
07258    EEE2  48           	PHA				; push on stack
07259    EEE3  A5 87        	LDA	Clinel		; get current line low byte
07260    EEE5  48           	PHA				; push on stack
07261    EEE6  A9 8D        	LDA	#TK_GOSUB		; token for GOSUB
07262    EEE8  48           	PHA				; push on stack
07263    
07264    EEE9  B9 01 00     	LDA	PLUS_1,Y		; get interrupt code pointer low byte
07265    EEEC  85 C3        	STA	Bpntrl		; save as BASIC execute pointer low byte
07266    EEEE  B9 02 00     	LDA	PLUS_2,Y		; get interrupt code pointer high byte
07267    EEF1  85 C4        	STA	Bpntrh		; save as BASIC execute pointer high byte
07268    
07269    ;	JMP	LAB_15C2		; go do interpreter inner loop
07270    EEF3  4C B3 D4     	JMP	on_interrupt	; avoid another CTRL-C check
07271    					; can't RTS, we used the stack! the RTS from the ctrl-c
07272    					; check will be taken when the RETIRQ/RETNMI/RETURN is
07273    					; executed at the end of the subroutine
07274    
07275    ; get byte from input device, no waiting
07276    ; returns with carry set if byte in A
07277    
07278    INGET
07279    EEF6  20 F7 F0     	JSR	V_INPT		; call scan input device
07280    EEF9  B0 09        	BCS	LAB_FB95		; if byte go reset timer
07281    
07282    EEFB  AD 02 02     	LDA	ccnull		; get countdown
07283    EEFE  F0 09        	BEQ	LAB_FB96		; exit if empty
07284    
07285    EF00  AD 01 02     	LDA	ccbyte		; get last received byte
07286    EF03  38           	SEC				; flag we got a byte
07287    LAB_FB95
07288    EF04  A2 00        	LDX	#$00			; clear X
07289    EF06  8E 02 02     	STX	ccnull		; clear timer because we got a byte
07290    LAB_FB96
07291    EF09  60           	RTS
07292    
07293    ; these routines only enable the interrupts if the set-up flag is set
07294    ; if not they have no effect
07295    
07296    ; perform IRQ {ON|OFF|CLEAR}
07297    
07298    LAB_IRQ
07299    EF0A  78           	SEI				; disable IRQ
07300    EF0B  A2 DF        	LDX	#IrqBase		; set pointer to IRQ values
07301    	.byte	$2C			; make next line BIT abs.
07302    
07303    ; perform NMI {ON|OFF|CLEAR}
07304    
07305    LAB_NMI
07306    EF0E  A2 DC        	LDX	#NmiBase		; set pointer to NMI values
07307    EF10  C9 93        	CMP	#TK_ON		; compare with token for ON
07308    EF12  F0 14        	BEQ	LAB_INON		; go turn on interrupt
07309    
07310    EF14  C9 B5        	CMP	#TK_OFF		; compare with token for OFF
07311    EF16  F0 07        	BEQ	LAB_IOFF		; go turn off interrupt
07312    
07313    EF18  49 A2        	EOR	#TK_CLEAR		; compare with token for CLEAR, A = $00 if = TK_CLEAR
07314    EF1A  F0 1C        	BEQ	LAB_INEX		; go clear interrupt flags and return
07315    
07316    EF1C  4C F6 DB     	JMP	LAB_SNER		; do syntax error then warm start
07317    
07318    LAB_IOFF
07319    EF1F  A9 A0        	LDA	#$A0			; 10100000 clear enable
07320    EF21  35 00        	AND	PLUS_0,X		; AND with interrupt setup flag
07321    EF23  95 00        	STA	PLUS_0,X		; save interrupt flag byte
07322    EF25  4C BC 00     	JMP	LAB_IGBY		; update BASIC execute pointer and return
07323    
07324    LAB_INON
07325    EF28  B5 00        	LDA	PLUS_0,X		; get interrupt setup flag
07326    EF2A  10 0C        	BPL	LAB_INEX		; cannot enable, no setup
07327    EF2C  09 40        	ORA   #$40			; 01000000 set enabled flag
07328    EF2E  E0 DF        	CPX	#IrqBase		; is IRQ?
07329    EF30  D0 06        	BNE	LAB_INEX		; no need to CLI
07330    EF32  95 00        	STA	PLUS_0,X		; save interrupt flags
07331    EF34  58           	CLI
07332    EF35  4C BC 00     	JMP	LAB_IGBY		; update BASIC execute pointer and return
07333    	
07334    LAB_INEX
07335    EF38  95 00        	STA	PLUS_0,X		; save interrupt flag byte
07336    EF3A  4C BC 00     	JMP	LAB_IGBY		; update BASIC execute pointer and return
07337    
07338    ; these routines set up the pointers and flags for the interrupt routines
07339    ; note that the interrupts are also enabled by these commands
07340    
07341    ; perform ON IRQ
07342    
07343    LAB_SIRQ
07344    EF3D  78           	SEI				; disable interrupts
07345    EF3E  A2 DF        	LDX	#IrqBase		; set pointer to IRQ values
07346    	.byte	$2C			; make next line BIT abs.
07347    
07348    ; perform ON NMI
07349    
07350    LAB_SNMI
07351    EF41  A2 DC        	LDX	#NmiBase		; set pointer to NMI values
07352    
07353    EF43  86 78        	STX	TempB			; save interrupt pointer
07354    EF45  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory (past token)
07355    EF48  20 49 D7     	JSR	LAB_GFPN		; get fixed-point number into temp integer
07356    EF4B  A5 79        	LDA	Smeml			; get start of mem low byte
07357    EF4D  A6 7A        	LDX	Smemh			; get start of mem high byte
07358    EF4F  20 1C D3     	JSR	LAB_SHLN		; search Basic for temp integer line number from AX
07359    EF52  B0 03        	BCS	LAB_LFND		; if carry set go set-up interrupt
07360    
07361    EF54  4C 66 D6     	JMP	LAB_16F7		; else go do "Undefined statement" error and warm start
07362    
07363    LAB_LFND
07364    EF57  A6 78        	LDX	TempB			; get interrupt pointer
07365    EF59  A5 AA        	LDA	Baslnl		; get pointer low byte
07366    EF5B  E9 01        	SBC	#$01			; -1 (carry already set for subtract)
07367    EF5D  95 01        	STA	PLUS_1,X		; save as interrupt pointer low byte
07368    EF5F  A5 AB        	LDA	Baslnh		; get pointer high byte
07369    EF61  E9 00        	SBC	#$00			; subtract carry
07370    EF63  95 02        	STA	PLUS_2,X		; save as interrupt pointer high byte
07371    
07372    EF65  A9 C0        	LDA	#$C0			; 11000000 set setup & enabled
07373    EF67  95 00        	STA	PLUS_0,X		; set interrupt flags
07374    EF69  E0 DF        	CPX	#IrqBase		; is IRQ?
07375    EF6B  D0 01        	BNE	LAB_IRTS		; no need to CLI
07376    EF6D  58           	CLI				; enable IRQ
07377    LAB_IRTS
07378    EF6E  60           	RTS
07379    
07380    ; return from IRQ service, restores the enabled flag.
07381    
07382    ; perform RETIRQ
07383    
07384    LAB_RETIRQ
07385    EF6F  D0 FD        	BNE	LAB_IRTS		; exit if following token (to allow syntax error)
07386    
07387    EF71  A5 DF        	LDA	IrqBase		; get interrupt flags
07388    EF73  10 05        	BPL	retirq_not_set	; cannot enable
07389    EF75  09 40        	ORA	#$40			; 01000000 enable
07390    EF77  85 DF        	STA	IrqBase		; save enabled flag
07391    EF79  58           	CLI
07392    retirq_not_set
07393    EF7A  4C 6D D6     	JMP	LAB_16E8		; go do rest of RETURN
07394    
07395    ; return from NMI service, restores the enabled flag.
07396    
07397    ; perform RETNMI
07398    
07399    LAB_RETNMI
07400    EF7D  D0 EF        	BNE	LAB_IRTS		; exit if following token (to allow syntax error)
07401    
07402    EF7F  A5 DC        	LDA	NmiBase		; get set-up flag
07403    EF81  10 04        	BPL	retnmi_not_set	; cannot enable
07404    EF83  09 40        	ORA	#$40			; 01000000 enable
07405    EF85  85 DC        	STA	NmiBase		; save enabled flag
07406    retnmi_not_set
07407    EF87  4C 6D D6     	JMP	LAB_16E8		; go do rest of RETURN
07408    
07409    ; MAX() MIN() pre process
07410    
07411    LAB_MMPP
07412    EF8A  20 DD DA     	JSR	LAB_EVEZ		; process expression
07413    EF8D  4C C4 DA     	JMP	LAB_CTNM		; check if source is numeric, else do type mismatch
07414    
07415    ; perform MAX()
07416    
07417    LAB_MAX
07418    EF90  20 BE EF     	JSR	LAB_PHFA		; push FAC1, evaluate expression,
07419    					; pull FAC2 and compare with FAC1
07420    EF93  10 FB        	BPL	LAB_MAX		; branch if no swap to do
07421    
07422    EF95  A5 B4        	LDA	FAC2_1		; get FAC2 mantissa1
07423    EF97  09 80        	ORA	#$80			; set top bit (clear sign from compare)
07424    EF99  85 B4        	STA	FAC2_1		; save FAC2 mantissa1
07425    EF9B  20 B7 E5     	JSR	LAB_279B		; copy FAC2 to FAC1
07426    EF9E  F0 F0        	BEQ	LAB_MAX		; go do next (branch always)
07427    
07428    ; perform MIN()
07429    
07430    LAB_MIN
07431    EFA0  20 BE EF     	JSR	LAB_PHFA		; push FAC1, evaluate expression,
07432    					; pull FAC2 and compare with FAC1
07433    EFA3  30 FB        	BMI	LAB_MIN		; branch if no swap to do
07434    
07435    EFA5  F0 F9        	BEQ	LAB_MIN		; branch if no swap to do
07436    
07437    EFA7  A5 B4        	LDA	FAC2_1		; get FAC2 mantissa1
07438    EFA9  09 80        	ORA	#$80			; set top bit (clear sign from compare)
07439    EFAB  85 B4        	STA	FAC2_1		; save FAC2 mantissa1
07440    EFAD  20 B7 E5     	JSR	LAB_279B		; copy FAC2 to FAC1
07441    EFB0  F0 EE        	BEQ	LAB_MIN		; go do next (branch always)
07442    
07443    ; exit routine. don't bother returning to the loop code
07444    ; check for correct exit, else so syntax error
07445    
07446    LAB_MMEC
07447    EFB2  C9 29        	CMP	#')'			; is it end of function?
07448    EFB4  D0 05        	BNE	LAB_MMSE		; if not do MAX MIN syntax error
07449    
07450    EFB6  68           	PLA				; dump return address low byte
07451    EFB7  68           	PLA				; dump return address high byte
07452    EFB8  4C BC 00     	JMP	LAB_IGBY		; update BASIC execute pointer (to chr past ")")
07453    
07454    LAB_MMSE
07455    EFBB  4C F6 DB     	JMP	LAB_SNER		; do syntax error then warm start
07456    
07457    ; check for next, evaluate and return or exit
07458    ; this is the routine that does most of the work
07459    
07460    LAB_PHFA
07461    EFBE  20 C2 00     	JSR	LAB_GBYT		; get next BASIC byte
07462    EFC1  C9 2C        	CMP	#','			; is there more ?
07463    EFC3  D0 ED        	BNE	LAB_MMEC		; if not go do end check
07464    
07465    					; push FAC1
07466    EFC5  20 CD E8     	JSR	LAB_27BA		; round FAC1
07467    EFC8  A5 B0        	LDA	FAC1_s		; get FAC1 sign
07468    EFCA  09 7F        	ORA	#$7F			; set all non sign bits
07469    EFCC  25 AD        	AND	FAC1_1		; AND FAC1 mantissa1 (AND in sign bit)
07470    EFCE  48           	PHA				; push on stack
07471    EFCF  A5 AE        	LDA	FAC1_2		; get FAC1 mantissa2
07472    EFD1  48           	PHA				; push on stack
07473    EFD2  A5 AF        	LDA	FAC1_3		; get FAC1 mantissa3
07474    EFD4  48           	PHA				; push on stack
07475    EFD5  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
07476    EFD7  48           	PHA				; push on stack
07477    
07478    EFD8  20 BC 00     	JSR	LAB_IGBY		; scan and get next BASIC byte (after ",")
07479    EFDB  20 C1 DA     	JSR	LAB_EVNM		; evaluate expression and check is numeric,
07480    					; else do type mismatch
07481    
07482    					; pop FAC2 (MAX/MIN expression so far)
07483    EFDE  68           	PLA				; pop exponent
07484    EFDF  85 B3        	STA	FAC2_e		; save FAC2 exponent
07485    EFE1  68           	PLA				; pop mantissa3
07486    EFE2  85 B6        	STA	FAC2_3		; save FAC2 mantissa3
07487    EFE4  68           	PLA				; pop mantissa1
07488    EFE5  85 B5        	STA	FAC2_2		; save FAC2 mantissa2
07489    EFE7  68           	PLA				; pop sign/mantissa1
07490    EFE8  85 B4        	STA	FAC2_1		; save FAC2 sign/mantissa1
07491    EFEA  85 B7        	STA	FAC2_s		; save FAC2 sign
07492    
07493    					; compare FAC1 with (packed) FAC2
07494    EFEC  A9 B3        	LDA	#<FAC2_e		; set pointer low byte to FAC2
07495    EFEE  A0 00        	LDY	#>FAC2_e		; set pointer high byte to FAC2
07496    EFF0  4C 0B E9     	JMP	LAB_27F8		; compare FAC1 with FAC2 (AY) and return
07497    					; returns A=$00 if FAC1 = (AY)
07498    					; returns A=$01 if FAC1 > (AY)
07499    					; returns A=$FF if FAC1 < (AY)
07500    
07501    ; perform WIDTH
07502    
07503    LAB_WDTH
07504    EFF3  C9 2C        	CMP	#','			; is next byte ","
07505    EFF5  F0 1B        	BEQ	LAB_TBSZ		; if so do tab size
07506    
07507    EFF7  20 80 E4     	JSR	LAB_GTBY		; get byte parameter
07508    EFFA  8A           	TXA				; copy width to A
07509    EFFB  F0 0A        	BEQ	LAB_NSTT		; branch if set for infinite line
07510    
07511    EFFD  E0 10        	CPX	#$10			; else make min width = 16d
07512    EFFF  90 45        	BCC	TabErr		; if less do function call error and exit
07513    
07514    ; this next compare ensures that we can't exit WIDTH via an error leaving the
07515    ; tab size greater than the line length.
07516    
07517    F001  E4 64        	CPX	TabSiz		; compare with tab size
07518    F003  B0 02        	BCS	LAB_NSTT		; branch if >= tab size
07519    
07520    F005  86 64        	STX	TabSiz		; else make tab size = terminal width
07521    LAB_NSTT
07522    F007  86 0F        	STX	TWidth		; set the terminal width
07523    F009  20 C2 00     	JSR	LAB_GBYT		; get BASIC byte back
07524    F00C  F0 1A        	BEQ	WExit			; exit if no following
07525    
07526    F00E  C9 2C        	CMP	#','			; else is it ","
07527    F010  D0 A9        	BNE	LAB_MMSE		; if not do syntax error
07528    
07529    LAB_TBSZ
07530    F012  20 7D E4     	JSR	LAB_SGBY		; scan and get byte parameter
07531    F015  8A           	TXA				; copy TAB size
07532    F016  30 2E        	BMI	TabErr		; if >127 do function call error and exit
07533    
07534    F018  E0 01        	CPX	#$01			; compare with min-1
07535    F01A  90 2A        	BCC	TabErr		; if <=1 do function call error and exit
07536    
07537    F01C  A5 0F        	LDA	TWidth		; set flags for width
07538    F01E  F0 06        	BEQ	LAB_SVTB		; skip check if infinite line
07539    
07540    F020  E4 0F        	CPX	TWidth		; compare TAB with width
07541    F022  F0 02        	BEQ	LAB_SVTB		; ok if =
07542    
07543    F024  B0 20        	BCS	TabErr		; branch if too big
07544    
07545    LAB_SVTB
07546    F026  86 64        	STX	TabSiz		; save TAB size
07547    
07548    ; calculate tab column limit from TAB size. The Iclim is set to the last tab
07549    ; position on a line that still has at least one whole tab width between it
07550    ; and the end of the line.
07551    
07552    WExit
07553    F028  A5 0F        	LDA	TWidth		; get width
07554    F02A  F0 06        	BEQ	LAB_SULP		; branch if infinite line
07555    
07556    F02C  C5 64        	CMP	TabSiz		; compare with tab size
07557    F02E  B0 03        	BCS	LAB_WDLP		; branch if >= tab size
07558    
07559    F030  85 64        	STA	TabSiz		; else make tab size = terminal width
07560    LAB_SULP
07561    F032  38           	SEC				; set carry for subtract
07562    LAB_WDLP
07563    F033  E5 64        	SBC	TabSiz		; subtract tab size
07564    F035  B0 FC        	BCS	LAB_WDLP		; loop while no borrow
07565    
07566    F037  65 64        	ADC	TabSiz		; add tab size back
07567    F039  18           	CLC				; clear carry for add
07568    F03A  65 64        	ADC	TabSiz		; add tab size back again
07569    F03C  85 10        	STA	Iclim			; save for now
07570    F03E  A5 0F        	LDA	TWidth		; get width back
07571    F040  38           	SEC				; set carry for subtract
07572    F041  E5 10        	SBC	Iclim			; subtract remainder
07573    F043  85 10        	STA	Iclim			; save tab column limit
07574    LAB_NOSQ
07575    F045  60           	RTS
07576    
07577    TabErr
07578    F046  4C 1D DF     	JMP	LAB_FCER		; do function call error then warm start
07579    
07580    ; perform SQR()
07581    
07582    LAB_SQR
07583    F049  A5 B0        	LDA	FAC1_s		; get FAC1 sign
07584    F04B  30 F9        	BMI	TabErr		; if -ve do function call error
07585    
07586    F04D  A5 AC        	LDA	FAC1_e		; get exponent
07587    F04F  F0 F4        	BEQ	LAB_NOSQ		; if zero just return
07588    
07589    					; else do root
07590    F051  20 BE E8     	JSR	LAB_27AB		; round and copy FAC1 to FAC2
07591    F054  A9 00        	LDA	#$00			; clear A
07592    
07593    F056  85 77        	STA	FACt_3		; clear remainder
07594    F058  85 76        	STA	FACt_2		; ..
07595    F05A  85 75        	STA	FACt_1		; ..
07596    F05C  85 78        	STA	TempB			; ..
07597    
07598    F05E  85 AF        	STA	FAC1_3		; clear root
07599    F060  85 AE        	STA	FAC1_2		; ..
07600    F062  85 AD        	STA	FAC1_1		; ..
07601    
07602    F064  A2 18        	LDX	#$18			; 24 pairs of bits to do
07603    F066  A5 B3        	LDA	FAC2_e		; get exponent
07604    F068  4A           	LSR				; check odd/even
07605    F069  B0 0E        	BCS	LAB_SQE2		; if odd only 1 shift first time
07606    
07607    LAB_SQE1
07608    F06B  06 B6        	ASL	FAC2_3		; shift highest bit of number ..
07609    F06D  26 B5        	ROL	FAC2_2		; ..
07610    F06F  26 B4        	ROL	FAC2_1		; ..
07611    F071  26 77        	ROL	FACt_3		; .. into remainder
07612    F073  26 76        	ROL	FACt_2		; ..
07613    F075  26 75        	ROL	FACt_1		; ..
07614    F077  26 78        	ROL	TempB			; .. never overflows
07615    LAB_SQE2
07616    F079  06 B6        	ASL	FAC2_3		; shift highest bit of number ..
07617    F07B  26 B5        	ROL	FAC2_2		; ..
07618    F07D  26 B4        	ROL	FAC2_1		; ..
07619    F07F  26 77        	ROL	FACt_3		; .. into remainder
07620    F081  26 76        	ROL	FACt_2		; ..
07621    F083  26 75        	ROL	FACt_1		; ..
07622    F085  26 78        	ROL	TempB			; .. never overflows
07623    
07624    F087  06 AF        	ASL	FAC1_3		; root = root * 2
07625    F089  26 AE        	ROL	FAC1_2		; ..
07626    F08B  26 AD        	ROL	FAC1_1		; .. never overflows
07627    
07628    F08D  A5 AF        	LDA	FAC1_3		; get root low byte
07629    F08F  2A           	ROL				; *2
07630    F090  85 5B        	STA	Temp3			; save partial low byte
07631    F092  A5 AE        	LDA	FAC1_2		; get root low mid byte
07632    F094  2A           	ROL				; *2
07633    F095  85 5C        	STA	Temp3+1		; save partial low mid byte
07634    F097  A5 AD        	LDA	FAC1_1		; get root high mid byte
07635    F099  2A           	ROL				; *2
07636    F09A  85 5D        	STA	Temp3+2		; save partial high mid byte
07637    F09C  A9 00        	LDA	#$00			; get root high byte (always $00)
07638    F09E  2A           	ROL				; *2
07639    F09F  85 5E        	STA	Temp3+3		; save partial high byte
07640    
07641    					; carry clear for subtract +1
07642    F0A1  A5 77        	LDA	FACt_3		; get remainder low byte
07643    F0A3  E5 5B        	SBC	Temp3			; subtract partial low byte
07644    F0A5  85 5B        	STA	Temp3			; save partial low byte
07645    
07646    F0A7  A5 76        	LDA	FACt_2		; get remainder low mid byte
07647    F0A9  E5 5C        	SBC	Temp3+1		; subtract partial low mid byte
07648    F0AB  85 5C        	STA	Temp3+1		; save partial low mid byte
07649    
07650    F0AD  A5 75        	LDA	FACt_1		; get remainder high mid byte
07651    F0AF  E5 5D        	SBC	Temp3+2		; subtract partial high mid byte
07652    F0B1  A8           	TAY				; copy partial high mid byte
07653    
07654    F0B2  A5 78        	LDA	TempB			; get remainder high byte
07655    F0B4  E5 5E        	SBC	Temp3+3		; subtract partial high byte
07656    F0B6  90 0E        	BCC	LAB_SQNS		; skip sub if remainder smaller
07657    
07658    F0B8  85 78        	STA	TempB			; save remainder high byte
07659    
07660    F0BA  84 75        	STY	FACt_1		; save remainder high mid byte
07661    
07662    F0BC  A5 5C        	LDA	Temp3+1		; get remainder low mid byte
07663    F0BE  85 76        	STA	FACt_2		; save remainder low mid byte
07664    
07665    F0C0  A5 5B        	LDA	Temp3			; get partial low byte
07666    F0C2  85 77        	STA	FACt_3		; save remainder low byte
07667    
07668    F0C4  E6 AF        	INC	FAC1_3		; increment root low byte (never any rollover)
07669    LAB_SQNS
07670    F0C6  CA           	DEX				; decrement bit pair count
07671    F0C7  D0 A2        	BNE	LAB_SQE1		; loop if not all done
07672    
07673    F0C9  38           	SEC				; set carry for subtract
07674    F0CA  A5 B3        	LDA	FAC2_e		; get exponent
07675    F0CC  E9 80        	SBC	#$80			; normalise
07676    F0CE  6A           	ROR				; /2 and re-bias to $80
07677    F0CF  69 00        	ADC	#$00			; add bit zero back in (allow for half shift)
07678    F0D1  85 AC        	STA	FAC1_e		; save it
07679    F0D3  4C 28 E6     	JMP	LAB_24D5		; normalise FAC1 and return
07680    
07681    ; perform VARPTR()
07682    
07683    LAB_VARPTR
07684    F0D6  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory
07685    F0D9  20 9E DD     	JSR	LAB_GVAR		; get var address
07686    F0DC  20 E3 DB     	JSR	LAB_1BFB		; scan for ")" , else do syntax error then warm start
07687    F0DF  A4 95        	LDY	Cvaral		; get var address low byte
07688    F0E1  A5 96        	LDA	Cvarah		; get var address high byte
07689    F0E3  4C 4D E0     	JMP	LAB_AYFC		; save and convert integer AY to FAC1 and return
07690    
07691    ; perform PI
07692    
07693    LAB_PI
07694    F0E6  A9 C8        	LDA	#<LAB_2C7C		; set (2*pi) pointer low byte
07695    F0E8  A0 F1        	LDY	#>LAB_2C7C		; set (2*pi) pointer high byte
07696    F0EA  20 71 E8     	JSR	LAB_UFAC		; unpack memory (AY) into FAC1
07697    F0ED  C6 AC        	DEC	FAC1_e		; make result = PI
07698    F0EF  60           	RTS
07699    
07700    ; perform TWOPI
07701    
07702    LAB_TWOPI
07703    F0F0  A9 C8        	LDA	#<LAB_2C7C		; set (2*pi) pointer low byte
07704    F0F2  A0 F1        	LDY	#>LAB_2C7C		; set (2*pi) pointer high byte
07705    F0F4  4C 71 E8     	JMP	LAB_UFAC		; unpack memory (AY) into FAC1 and return
07706    
07707    ; system dependant i/o vectors
07708    ; these are in RAM and are set by the monitor at start-up
07709    
07710    V_INPT
07711    F0F7  6C 05 02     	JMP	(VEC_IN)		; non halting scan input device
07712    V_OUTP
07713    F0FA  6C 07 02     	JMP	(VEC_OUT)		; send byte to output device
07714    V_LOAD
07715    F0FD  6C 09 02     	JMP	(VEC_LD)		; load BASIC program
07716    V_SAVE
07717    F100  6C 0B 02     	JMP	(VEC_SV)		; save BASIC program
07718    
07719    ; The rest are tables messages and code for RAM
07720    
07721    ; the rest of the code is tables and BASIC start-up code
07722    
07723    PG2_TABS
07724    	.byte	$00			; ctrl-c flag		-	$00 = enabled
07725    	.byte	$00			; ctrl-c byte		-	GET needs this
07726    	.byte	$00			; ctrl-c byte timeout	-	GET needs this
07727    	.word	CTRLC			; ctrl c check vector
07728    ;	.word	xxxx			; non halting key input	-	monitor to set this
07729    ;	.word	xxxx			; output vector		-	monitor to set this
07730    ;	.word	xxxx			; load vector		-	monitor to set this
07731    ;	.word	xxxx			; save vector		-	monitor to set this
07732    PG2_TABE
07733    
07734    ; character get subroutine for zero page
07735    
07736    ; For a 1.8432MHz 6502 including the JSR and RTS
07737    ; fastest (>=":")	=  29 cycles =  15.7uS
07738    ; slowest (<":")	=  40 cycles =  21.7uS
07739    ; space skip	= +21 cycles = +11.4uS
07740    ; inc across page	=  +4 cycles =  +2.2uS
07741    
07742    ; the target address for the LDA at LAB_2CF4 becomes the BASIC execute pointer once the
07743    ; block is copied to it's destination, any non zero page address will do at assembly
07744    ; time, to assemble a three byte instruction.
07745    
07746    ; page 0 initialisation table from $BC
07747    ; increment and scan memory
07748    
07749    LAB_2CEE
07750    F108  E6 C3        	INC	Bpntrl		; increment BASIC execute pointer low byte
07751    F10A  D0 02        	BNE	LAB_2CF4		; branch if no carry
07752    					; else
07753    F10C  E6 C4        	INC	Bpntrh		; increment BASIC execute pointer high byte
07754    
07755    ; page 0 initialisation table from $C2
07756    ; scan memory
07757    
07758    LAB_2CF4
07759    F10E  AD FF FF     	LDA	$FFFF			; get byte to scan (addr set by call routine)
07760    F111  C9 AC        	CMP	#TK_ELSE		; compare with the token for ELSE
07761    F113  F0 0E        	BEQ	LAB_2D05		; exit if ELSE, not numeric, carry set
07762    
07763    F115  C9 3A        	CMP	#':'			; compare with ":"
07764    F117  B0 0A        	BCS	LAB_2D05		; exit if >= ":", not numeric, carry set
07765    
07766    F119  C9 20        	CMP	#' '			; compare with " "
07767    F11B  F0 EB        	BEQ	LAB_2CEE		; if " " go do next
07768    
07769    F11D  38           	SEC				; set carry for SBC
07770    F11E  E9 30        	SBC	#'0'			; subtract "0"
07771    F120  38           	SEC				; set carry for SBC
07772    F121  E9 D0        	SBC	#$D0			; subtract -"0"
07773    					; clear carry if byte = "0"-"9"
07774    LAB_2D05
07775    F123  60           	RTS
07776    
07777    ; page zero initialisation table $00-$12 inclusive
07778    
07779    StrTab
07780    	.byte	$4C			; JMP opcode
07781    	.word LAB_COLD		; initial warm start vector (cold start)
07782    
07783    	.byte	$00			; these bytes are not used by BASIC
07784    	.word	$0000			; 
07785    	.word	$0000			; 
07786    	.word	$0000			; 
07787    
07788    	.byte	$4C			; JMP opcode
07789    	.word	LAB_FCER		; initial user function vector ("Function call" error)
07790    	.byte	$00			; default NULL count
07791    	.byte	$00			; clear terminal position
07792    	.byte	$00			; default terminal width byte
07793    	.byte	$F2			; default limit for TAB = 14
07794    	.word	Ram_base		; start of user RAM
07795    EndTab
07796    
07797    LAB_MSZM
07798    	.byte	$0D,$0A,"Memory size ",$00
07799    
07800    LAB_SMSG
07801    	.byte	" Bytes free",$0D,$0A,$0A
07802    	.byte	"Enhanced BASIC 2.22",$0A,$00
07803    
07804    ; numeric constants and series
07805    
07806    					; constants and series for LOG(n)
07807    LAB_25A0
07808    	.byte	$02			; counter
07809    	.byte	$80,$19,$56,$62	; 0.59898
07810    	.byte	$80,$76,$22,$F3	; 0.96147
07811    ;##	.byte	$80,$76,$22,$F1	; 0.96147
07812    	.byte	$82,$38,$AA,$40	; 2.88539
07813    ;##	.byte	$82,$38,$AA,$45	; 2.88539
07814    
07815    LAB_25AD
07816    	.byte	$80,$35,$04,$F3	; 0.70711	1/root 2
07817    LAB_25B1
07818    	.byte	$81,$35,$04,$F3	; 1.41421	root 2
07819    LAB_25B5
07820    	.byte	$80,$80,$00,$00	; -0.5
07821    LAB_25B9
07822    	.byte	$80,$31,$72,$18	; 0.69315	LOG(2)
07823    
07824    					; numeric PRINT constants
07825    LAB_2947
07826    	.byte	$91,$43,$4F,$F8	; 99999.9375 (max value with at least one decimal)
07827    LAB_294B
07828    	.byte	$94,$74,$23,$F7	; 999999.4375 (max value before scientific notation)
07829    LAB_294F
07830    	.byte	$94,$74,$24,$00	; 1000000
07831    
07832    					; EXP(n) constants and series
07833    LAB_2AFA
07834    	.byte	$81,$38,$AA,$3B	; 1.4427	(1/LOG base 2 e)
07835    LAB_2AFE
07836    	.byte	$06			; counter
07837    	.byte	$74,$63,$90,$8C	; 2.17023e-4
07838    	.byte	$77,$23,$0C,$AB	; 0.00124
07839    	.byte	$7A,$1E,$94,$00	; 0.00968
07840    	.byte	$7C,$63,$42,$80	; 0.05548
07841    	.byte	$7E,$75,$FE,$D0	; 0.24023
07842    	.byte	$80,$31,$72,$15	; 0.69315
07843    	.byte	$81,$00,$00,$00	; 1.00000
07844    
07845    ;##	.byte	$07			; counter
07846    ;##	.byte	$74,$94,$2E,$40	; -1/7! (-1/5040)
07847    ;##	.byte	$77,$2E,$4F,$70	;  1/6! ( 1/720)
07848    ;##	.byte	$7A,$88,$02,$6E	; -1/5! (-1/120)
07849    ;##	.byte	$7C,$2A,$A0,$E6	;  1/4! ( 1/24)
07850    ;##	.byte	$7E,$AA,$AA,$50	; -1/3! (-1/6)
07851    ;##	.byte	$7F,$7F,$FF,$FF	;  1/2! ( 1/2)
07852    ;##	.byte	$81,$80,$00,$00	; -1/1! (-1/1)
07853    ;##	.byte	$81,$00,$00,$00	;  1/0! ( 1/1)
07854    
07855    					; trigonometric constants and series
07856    LAB_2C78
07857    	.byte	$81,$49,$0F,$DB	; 1.570796371 (pi/2) as floating #
07858    LAB_2C84
07859    	.byte	$04			; counter
07860    	.byte	$86,$1E,$D7,$FB	; 39.7109
07861    ;##	.byte	$86,$1E,$D7,$BA	; 39.7109
07862    	.byte	$87,$99,$26,$65	;-76.575
07863    ;##	.byte	$87,$99,$26,$64	;-76.575
07864    	.byte	$87,$23,$34,$58	; 81.6022
07865    	.byte	$86,$A5,$5D,$E1	;-41.3417
07866    ;##	.byte	$86,$A5,$5D,$E0	;-41.3417
07867    LAB_2C7C
07868    	.byte	$83,$49,$0F,$DB	; 6.28319 (2*pi) as floating #
07869    ;##	.byte	$83,$49,$0F,$DA	; 6.28319 (2*pi) as floating #
07870    
07871    LAB_2CC9
07872    	.byte	$08			; counter
07873    	.byte	$78,$3A,$C5,$37	; 0.00285
07874    	.byte	$7B,$83,$A2,$5C	;-0.0160686
07875    	.byte	$7C,$2E,$DD,$4D	; 0.0426915
07876    	.byte	$7D,$99,$B0,$1E	;-0.0750429
07877    	.byte	$7D,$59,$ED,$24	; 0.106409
07878    	.byte	$7E,$91,$72,$00	;-0.142036
07879    	.byte	$7E,$4C,$B9,$73	; 0.199926
07880    	.byte	$7F,$AA,$AA,$53	;-0.333331
07881    
07882    ;##	.byte	$08			; counter
07883    ;##	.byte	$78,$3B,$D7,$4A	; 1/17
07884    ;##	.byte	$7B,$84,$6E,$02	;-1/15
07885    ;##	.byte	$7C,$2F,$C1,$FE	; 1/13
07886    ;##	.byte	$7D,$9A,$31,$74	;-1/11
07887    ;##	.byte	$7D,$5A,$3D,$84	; 1/9
07888    ;##	.byte	$7E,$91,$7F,$C8	;-1/7
07889    ;##	.byte	$7E,$4C,$BB,$E4	; 1/5
07890    ;##	.byte	$7F,$AA,$AA,$6C	;-1/3
07891    
07892      F1EE             LAB_1D96	= *+1			; $00,$00 used for undefined variables
07893    LAB_259C
07894    	.byte	$81,$00,$00,$00	; 1.000000, used for INC
07895    LAB_2AFD
07896    	.byte	$81,$80,$00,$00	; -1.00000, used for DEC. must be on the same page as +1.00
07897    
07898    					; misc constants
07899    LAB_1DF7
07900    	.byte	$90			;-32768 (uses first three bytes from 0.5)
07901    LAB_2A96
07902    	.byte	$80,$00,$00,$00	; 0.5
07903    LAB_2C80
07904    	.byte	$7F,$00,$00,$00	; 0.25
07905    LAB_26B5
07906    	.byte	$84,$20,$00,$00	; 10.0000 divide by 10 constant
07907    
07908    ; This table is used in converting numbers to ASCII.
07909    
07910    LAB_2A9A
07911      F203             LAB_2A9B = LAB_2A9A+1
07912      F204             LAB_2A9C = LAB_2A9B+1
07913    	.byte	$FE,$79,$60		; -100000
07914    	.byte	$00,$27,$10		; 10000
07915    	.byte	$FF,$FC,$18		; -1000
07916    	.byte	$00,$00,$64		; 100
07917    	.byte	$FF,$FF,$F6		; -10
07918    	.byte	$00,$00,$01		; 1
07919    
07920    LAB_CTBL
07921    	.word	LAB_END-1		; END
07922    	.word	LAB_FOR-1		; FOR
07923    	.word	LAB_NEXT-1		; NEXT
07924    	.word	LAB_DATA-1		; DATA
07925    	.word	LAB_INPUT-1		; INPUT
07926    	.word	LAB_DIM-1		; DIM
07927    	.word	LAB_READ-1		; READ
07928    	.word	LAB_LET-1		; LET
07929    	.word	LAB_DEC-1		; DEC			new command
07930    	.word	LAB_GOTO-1		; GOTO
07931    	.word	LAB_RUN-1		; RUN
07932    	.word	LAB_IF-1		; IF
07933    	.word	LAB_RESTORE-1	; RESTORE		modified command
07934    	.word	LAB_GOSUB-1		; GOSUB
07935    	.word	LAB_RETIRQ-1	; RETIRQ		new command
07936    	.word	LAB_RETNMI-1	; RETNMI		new command
07937    	.word	LAB_RETURN-1	; RETURN
07938    	.word	LAB_REM-1		; REM
07939    	.word	LAB_STOP-1		; STOP
07940    	.word	LAB_ON-1		; ON			modified command
07941    	.word	LAB_NULL-1		; NULL		modified command
07942    	.word	LAB_INC-1		; INC			new command
07943    	.word	LAB_WAIT-1		; WAIT
07944    	.word	V_LOAD-1		; LOAD
07945    	.word	V_SAVE-1		; SAVE
07946    	.word	LAB_DEF-1		; DEF
07947    	.word	LAB_POKE-1		; POKE
07948    	.word	LAB_DOKE-1		; DOKE		new command
07949    	.word	LAB_CALL-1		; CALL		new command
07950    	.word	LAB_DO-1		; DO			new command
07951    	.word	LAB_LOOP-1		; LOOP		new command
07952    	.word	LAB_PRINT-1		; PRINT
07953    	.word	LAB_CONT-1		; CONT
07954    	.word	LAB_LIST-1		; LIST
07955    	.word	LAB_CLEAR-1		; CLEAR
07956    	.word	LAB_NEW-1		; NEW
07957    	.word	LAB_WDTH-1		; WIDTH		new command
07958    	.word	LAB_GET-1		; GET			new command
07959    	.word	LAB_SWAP-1		; SWAP		new command
07960    	.word	LAB_BITSET-1	; BITSET		new command
07961    	.word	LAB_BITCLR-1	; BITCLR		new command
07962    	.word	LAB_IRQ-1		; IRQ			new command
07963    	.word	LAB_NMI-1		; NMI			new command
07964    
07965    ; function pre process routine table
07966    
07967    LAB_FTPL
07968      F26B             LAB_FTPM	= LAB_FTPL+$01
07969    	.word	LAB_PPFN-1		; SGN(n)	process numeric expression in ()
07970    	.word	LAB_PPFN-1		; INT(n)		"
07971    	.word	LAB_PPFN-1		; ABS(n)		"
07972    	.word	LAB_EVEZ-1		; USR(x)	process any expression
07973    	.word	LAB_1BF7-1		; FRE(x)		"
07974    	.word	LAB_1BF7-1		; POS(x)		"
07975    	.word	LAB_PPFN-1		; SQR(n)	process numeric expression in ()
07976    	.word	LAB_PPFN-1		; RND(n)		"
07977    	.word	LAB_PPFN-1		; LOG(n)		"
07978    	.word	LAB_PPFN-1		; EXP(n)		"
07979    	.word	LAB_PPFN-1		; COS(n)		"
07980    	.word	LAB_PPFN-1		; SIN(n)		"
07981    	.word	LAB_PPFN-1		; TAN(n)		"
07982    	.word	LAB_PPFN-1		; ATN(n)		"
07983    	.word	LAB_PPFN-1		; PEEK(n)		"
07984    	.word	LAB_PPFN-1		; DEEK(n)		"
07985    	.word	$0000			; SADD()	none
07986    	.word	LAB_PPFS-1		; LEN($)	process string expression in ()
07987    	.word	LAB_PPFN-1		; STR$(n)	process numeric expression in ()
07988    	.word	LAB_PPFS-1		; VAL($)	process string expression in ()
07989    	.word	LAB_PPFS-1		; ASC($)		"
07990    	.word	LAB_PPFS-1		; UCASE$($)		"
07991    	.word	LAB_PPFS-1		; LCASE$($)		"
07992    	.word	LAB_PPFN-1		; CHR$(n)	process numeric expression in ()
07993    	.word	LAB_BHSS-1		; HEX$(n)		"
07994    	.word	LAB_BHSS-1		; BIN$(n)		"
07995    	.word	$0000			; BITTST()	none
07996    	.word	LAB_MMPP-1		; MAX()	process numeric expression
07997    	.word	LAB_MMPP-1		; MIN()		"
07998    	.word	LAB_PPBI-1		; PI		advance pointer
07999    	.word	LAB_PPBI-1		; TWOPI		"
08000    	.word	$0000			; VARPTR()	none
08001    	.word	LAB_LRMS-1		; LEFT$()	process string expression
08002    	.word	LAB_LRMS-1		; RIGHT$()		"
08003    	.word	LAB_LRMS-1		; MID$()		"
08004    
08005    ; action addresses for functions
08006    
08007    LAB_FTBL
08008      F2B1             LAB_FTBM	= LAB_FTBL+$01
08009    	.word	LAB_SGN-1		; SGN()
08010    	.word	LAB_INT-1		; INT()
08011    	.word	LAB_ABS-1		; ABS()
08012    	.word	LAB_USR-1		; USR()
08013    	.word	LAB_FRE-1		; FRE()
08014    	.word	LAB_POS-1		; POS()
08015    	.word	LAB_SQR-1		; SQR()
08016    	.word	LAB_RND-1		; RND()		modified function
08017    	.word	LAB_LOG-1		; LOG()
08018    	.word	LAB_EXP-1		; EXP()
08019    	.word	LAB_COS-1		; COS()
08020    	.word	LAB_SIN-1		; SIN()
08021    	.word	LAB_TAN-1		; TAN()
08022    	.word	LAB_ATN-1		; ATN()
08023    	.word	LAB_PEEK-1		; PEEK()
08024    	.word	LAB_DEEK-1		; DEEK()		new function
08025    	.word	LAB_SADD-1		; SADD()		new function
08026    	.word	LAB_LENS-1		; LEN()
08027    	.word	LAB_STRS-1		; STR$()
08028    	.word	LAB_VAL-1		; VAL()
08029    	.word	LAB_ASC-1		; ASC()
08030    	.word	LAB_UCASE-1		; UCASE$()		new function
08031    	.word	LAB_LCASE-1		; LCASE$()		new function
08032    	.word	LAB_CHRS-1		; CHR$()
08033    	.word	LAB_HEXS-1		; HEX$()		new function
08034    	.word	LAB_BINS-1		; BIN$()		new function
08035    	.word	LAB_BTST-1		; BITTST()		new function
08036    	.word	LAB_MAX-1		; MAX()		new function
08037    	.word	LAB_MIN-1		; MIN()		new function
08038    	.word	LAB_PI-1		; PI			new function
08039    	.word	LAB_TWOPI-1		; TWOPI		new function
08040    	.word	LAB_VARPTR-1	; VARPTR()		new function
08041    	.word	LAB_LEFT-1		; LEFT$()
08042    	.word	LAB_RIGHT-1		; RIGHT$()
08043    	.word	LAB_MIDS-1		; MID$()
08044    
08045    ; hierarchy and action addresses for operator
08046    
08047    LAB_OPPT
08048    	.byte	$79			; +
08049    	.word	LAB_ADD-1
08050    	.byte	$79			; -
08051    	.word	LAB_SUBTRACT-1
08052    	.byte	$7B			; *
08053    	.word	LAB_MULTIPLY-1
08054    	.byte	$7B			; /
08055    	.word	LAB_DIVIDE-1
08056    	.byte	$7F			; ^
08057    	.word	LAB_POWER-1
08058    	.byte	$50			; AND
08059    	.word	LAB_AND-1
08060    	.byte	$46			; EOR			new operator
08061    	.word	LAB_EOR-1
08062    	.byte	$46			; OR
08063    	.word	LAB_OR-1
08064    	.byte	$56			; >>			new operator
08065    	.word	LAB_RSHIFT-1
08066    	.byte	$56			; <<			new operator
08067    	.word	LAB_LSHIFT-1
08068    	.byte	$7D			; >
08069    	.word	LAB_GTHAN-1
08070    	.byte	$5A			; =
08071    	.word	LAB_EQUAL-1
08072    	.byte	$64			; <
08073    	.word	LAB_LTHAN-1
08074    
08075    ; keywords start with ..
08076    ; this is the first character table and must be in alphabetic order
08077    
08078    TAB_1STC
08079    	.byte	"*"
08080    	.byte	"+"
08081    	.byte	"-"
08082    	.byte	"/"
08083    	.byte	"<"
08084    	.byte	"="
08085    	.byte	">"
08086    	.byte	"?"
08087    	.byte	"A"
08088    	.byte	"B"
08089    	.byte	"C"
08090    	.byte	"D"
08091    	.byte	"E"
08092    	.byte	"F"
08093    	.byte	"G"
08094    	.byte	"H"
08095    	.byte	"I"
08096    	.byte	"L"
08097    	.byte	"M"
08098    	.byte	"N"
08099    	.byte	"O"
08100    	.byte	"P"
08101    	.byte	"R"
08102    	.byte	"S"
08103    	.byte	"T"
08104    	.byte	"U"
08105    	.byte	"V"
08106    	.byte	"W"
08107    	.byte	"^"
08108    	.byte	$00			; table terminator
08109    
08110    ; pointers to keyword tables
08111    
08112    TAB_CHRT
08113    	.word	TAB_STAR		; table for "*"
08114    	.word	TAB_PLUS		; table for "+"
08115    	.word	TAB_MNUS		; table for "-"
08116    	.word	TAB_SLAS		; table for "/"
08117    	.word	TAB_LESS		; table for "<"
08118    	.word	TAB_EQUL		; table for "="
08119    	.word	TAB_MORE		; table for ">"
08120    	.word	TAB_QEST		; table for "?"
08121    	.word	TAB_ASCA		; table for "A"
08122    	.word	TAB_ASCB		; table for "B"
08123    	.word	TAB_ASCC		; table for "C"
08124    	.word	TAB_ASCD		; table for "D"
08125    	.word	TAB_ASCE		; table for "E"
08126    	.word	TAB_ASCF		; table for "F"
08127    	.word	TAB_ASCG		; table for "G"
08128    	.word	TAB_ASCH		; table for "H"
08129    	.word	TAB_ASCI		; table for "I"
08130    	.word	TAB_ASCL		; table for "L"
08131    	.word	TAB_ASCM		; table for "M"
08132    	.word	TAB_ASCN		; table for "N"
08133    	.word	TAB_ASCO		; table for "O"
08134    	.word	TAB_ASCP		; table for "P"
08135    	.word	TAB_ASCR		; table for "R"
08136    	.word	TAB_ASCS		; table for "S"
08137    	.word	TAB_ASCT		; table for "T"
08138    	.word	TAB_ASCU		; table for "U"
08139    	.word	TAB_ASCV		; table for "V"
08140    	.word	TAB_ASCW		; table for "W"
08141    	.word	TAB_POWR		; table for "^"
08142    
08143    ; tables for each start character, note if a longer keyword with the same start
08144    ; letters as a shorter one exists then it must come first, else the list is in
08145    ; alphabetical order as follows ..
08146    
08147    ; [keyword,token
08148    ; [keyword,token]]
08149    ; end marker (#$00)
08150    
08151    TAB_STAR
08152    	.byte TK_MUL,$00		; *
08153    TAB_PLUS
08154    	.byte TK_PLUS,$00		; +
08155    TAB_MNUS
08156    	.byte TK_MINUS,$00	; -
08157    TAB_SLAS
08158    	.byte TK_DIV,$00		; /
08159    TAB_LESS
08160    LBB_LSHIFT
08161    	.byte	"<",TK_LSHIFT	; <<	note - "<<" must come before "<"
08162    	.byte TK_LT			; <
08163    	.byte	$00
08164    TAB_EQUL
08165    	.byte TK_EQUAL,$00	; =
08166    TAB_MORE
08167    LBB_RSHIFT
08168    	.byte	">",TK_RSHIFT	; >>	note - ">>" must come before ">"
08169    	.byte TK_GT			; >
08170    	.byte	$00
08171    TAB_QEST
08172    	.byte TK_PRINT,$00	; ?
08173    TAB_ASCA
08174    LBB_ABS
08175    	.byte	"BS(",TK_ABS	; ABS(
08176    LBB_AND
08177    	.byte	"ND",TK_AND		; AND
08178    LBB_ASC
08179    	.byte	"SC(",TK_ASC	; ASC(
08180    LBB_ATN
08181    	.byte	"TN(",TK_ATN	; ATN(
08182    	.byte	$00
08183    TAB_ASCB
08184    LBB_BINS
08185    	.byte	"IN$(",TK_BINS	; BIN$(
08186    LBB_BITCLR
08187    	.byte	"ITCLR",TK_BITCLR	; BITCLR
08188    LBB_BITSET
08189    	.byte	"ITSET",TK_BITSET	; BITSET
08190    LBB_BITTST
08191    	.byte	"ITTST(",TK_BITTST
08192    					; BITTST(
08193    	.byte	$00
08194    TAB_ASCC
08195    LBB_CALL
08196    	.byte	"ALL",TK_CALL	; CALL
08197    LBB_CHRS
08198    	.byte	"HR$(",TK_CHRS	; CHR$(
08199    LBB_CLEAR
08200    	.byte	"LEAR",TK_CLEAR	; CLEAR
08201    LBB_CONT
08202    	.byte	"ONT",TK_CONT	; CONT
08203    LBB_COS
08204    	.byte	"OS(",TK_COS	; COS(
08205    	.byte	$00
08206    TAB_ASCD
08207    LBB_DATA
08208    	.byte	"ATA",TK_DATA	; DATA
08209    LBB_DEC
08210    	.byte	"EC",TK_DEC		; DEC
08211    LBB_DEEK
08212    	.byte	"EEK(",TK_DEEK	; DEEK(
08213    LBB_DEF
08214    	.byte	"EF",TK_DEF		; DEF
08215    LBB_DIM
08216    	.byte	"IM",TK_DIM		; DIM
08217    LBB_DOKE
08218    	.byte	"OKE",TK_DOKE	; DOKE note - "DOKE" must come before "DO"
08219    LBB_DO
08220    	.byte	"O",TK_DO		; DO
08221    	.byte	$00
08222    TAB_ASCE
08223    LBB_ELSE
08224    	.byte	"LSE",TK_ELSE	; ELSE
08225    LBB_END
08226    	.byte	"ND",TK_END		; END
08227    LBB_EOR
08228    	.byte	"OR",TK_EOR		; EOR
08229    LBB_EXP
08230    	.byte	"XP(",TK_EXP	; EXP(
08231    	.byte	$00
08232    TAB_ASCF
08233    LBB_FN
08234    	.byte	"N",TK_FN		; FN
08235    LBB_FOR
08236    	.byte	"OR",TK_FOR		; FOR
08237    LBB_FRE
08238    	.byte	"RE(",TK_FRE	; FRE(
08239    	.byte	$00
08240    TAB_ASCG
08241    LBB_GET
08242    	.byte	"ET",TK_GET		; GET
08243    LBB_GOSUB
08244    	.byte	"OSUB",TK_GOSUB	; GOSUB
08245    LBB_GOTO
08246    	.byte	"OTO",TK_GOTO	; GOTO
08247    	.byte	$00
08248    TAB_ASCH
08249    LBB_HEXS
08250    	.byte	"EX$(",TK_HEXS	; HEX$(
08251    	.byte	$00
08252    TAB_ASCI
08253    LBB_IF
08254    	.byte	"F",TK_IF		; IF
08255    LBB_INC
08256    	.byte	"NC",TK_INC		; INC
08257    LBB_INPUT
08258    	.byte	"NPUT",TK_INPUT	; INPUT
08259    LBB_INT
08260    	.byte	"NT(",TK_INT	; INT(
08261    LBB_IRQ
08262    	.byte	"RQ",TK_IRQ		; IRQ
08263    	.byte	$00
08264    TAB_ASCL
08265    LBB_LCASES
08266    	.byte	"CASE$(",TK_LCASES
08267    					; LCASE$(
08268    LBB_LEFTS
08269    	.byte	"EFT$(",TK_LEFTS	; LEFT$(
08270    LBB_LEN
08271    	.byte	"EN(",TK_LEN	; LEN(
08272    LBB_LET
08273    	.byte	"ET",TK_LET		; LET
08274    LBB_LIST
08275    	.byte	"IST",TK_LIST	; LIST
08276    LBB_LOAD
08277    	.byte	"OAD",TK_LOAD	; LOAD
08278    LBB_LOG
08279    	.byte	"OG(",TK_LOG	; LOG(
08280    LBB_LOOP
08281    	.byte	"OOP",TK_LOOP	; LOOP
08282    	.byte	$00
08283    TAB_ASCM
08284    LBB_MAX
08285    	.byte	"AX(",TK_MAX	; MAX(
08286    LBB_MIDS
08287    	.byte	"ID$(",TK_MIDS	; MID$(
08288    LBB_MIN
08289    	.byte	"IN(",TK_MIN	; MIN(
08290    	.byte	$00
08291    TAB_ASCN
08292    LBB_NEW
08293    	.byte	"EW",TK_NEW		; NEW
08294    LBB_NEXT
08295    	.byte	"EXT",TK_NEXT	; NEXT
08296    LBB_NMI
08297    	.byte	"MI",TK_NMI		; NMI
08298    LBB_NOT
08299    	.byte	"OT",TK_NOT		; NOT
08300    LBB_NULL
08301    	.byte	"ULL",TK_NULL	; NULL
08302    	.byte	$00
08303    TAB_ASCO
08304    LBB_OFF
08305    	.byte	"FF",TK_OFF		; OFF
08306    LBB_ON
08307    	.byte	"N",TK_ON		; ON
08308    LBB_OR
08309    	.byte	"R",TK_OR		; OR
08310    	.byte	$00
08311    TAB_ASCP
08312    LBB_PEEK
08313    	.byte	"EEK(",TK_PEEK	; PEEK(
08314    LBB_PI
08315    	.byte	"I",TK_PI		; PI
08316    LBB_POKE
08317    	.byte	"OKE",TK_POKE	; POKE
08318    LBB_POS
08319    	.byte	"OS(",TK_POS	; POS(
08320    LBB_PRINT
08321    	.byte	"RINT",TK_PRINT	; PRINT
08322    	.byte	$00
08323    TAB_ASCR
08324    LBB_READ
08325    	.byte	"EAD",TK_READ	; READ
08326    LBB_REM
08327    	.byte	"EM",TK_REM		; REM
08328    LBB_RESTORE
08329    	.byte	"ESTORE",TK_RESTORE
08330    					; RESTORE
08331    LBB_RETIRQ
08332    	.byte	"ETIRQ",TK_RETIRQ	; RETIRQ
08333    LBB_RETNMI
08334    	.byte	"ETNMI",TK_RETNMI	; RETNMI
08335    LBB_RETURN
08336    	.byte	"ETURN",TK_RETURN	; RETURN
08337    LBB_RIGHTS
08338    	.byte	"IGHT$(",TK_RIGHTS
08339    					; RIGHT$(
08340    LBB_RND
08341    	.byte	"ND(",TK_RND	; RND(
08342    LBB_RUN
08343    	.byte	"UN",TK_RUN		; RUN
08344    	.byte	$00
08345    TAB_ASCS
08346    LBB_SADD
08347    	.byte	"ADD(",TK_SADD	; SADD(
08348    LBB_SAVE
08349    	.byte	"AVE",TK_SAVE	; SAVE
08350    LBB_SGN
08351    	.byte	"GN(",TK_SGN	; SGN(
08352    LBB_SIN
08353    	.byte	"IN(",TK_SIN	; SIN(
08354    LBB_SPC
08355    	.byte	"PC(",TK_SPC	; SPC(
08356    LBB_SQR
08357    	.byte	"QR(",TK_SQR	; SQR(
08358    LBB_STEP
08359    	.byte	"TEP",TK_STEP	; STEP
08360    LBB_STOP
08361    	.byte	"TOP",TK_STOP	; STOP
08362    LBB_STRS
08363    	.byte	"TR$(",TK_STRS	; STR$(
08364    LBB_SWAP
08365    	.byte	"WAP",TK_SWAP	; SWAP
08366    	.byte	$00
08367    TAB_ASCT
08368    LBB_TAB
08369    	.byte	"AB(",TK_TAB	; TAB(
08370    LBB_TAN
08371    	.byte	"AN(",TK_TAN	; TAN(
08372    LBB_THEN
08373    	.byte	"HEN",TK_THEN	; THEN
08374    LBB_TO
08375    	.byte	"O",TK_TO		; TO
08376    LBB_TWOPI
08377    	.byte	"WOPI",TK_TWOPI	; TWOPI
08378    	.byte	$00
08379    TAB_ASCU
08380    LBB_UCASES
08381    	.byte	"CASE$(",TK_UCASES
08382    					; UCASE$(
08383    LBB_UNTIL
08384    	.byte	"NTIL",TK_UNTIL	; UNTIL
08385    LBB_USR
08386    	.byte	"SR(",TK_USR	; USR(
08387    	.byte	$00
08388    TAB_ASCV
08389    LBB_VAL
08390    	.byte	"AL(",TK_VAL	; VAL(
08391    LBB_VPTR
08392    	.byte	"ARPTR(",TK_VPTR	; VARPTR(
08393    	.byte	$00
08394    TAB_ASCW
08395    LBB_WAIT
08396    	.byte	"AIT",TK_WAIT	; WAIT
08397    LBB_WHILE
08398    	.byte	"HILE",TK_WHILE	; WHILE
08399    LBB_WIDTH
08400    	.byte	"IDTH",TK_WIDTH	; WIDTH
08401    	.byte	$00
08402    TAB_POWR
08403    	.byte	TK_POWER,$00	; ^
08404    
08405    ; new decode table for LIST
08406    ; Table is ..
08407    ; byte - keyword length, keyword first character
08408    ; word - pointer to rest of keyword from dictionary
08409    
08410    ; note if length is 1 then the pointer is ignored
08411    
08412    LAB_KEYT
08413    	.byte	3,'E'
08414    	.word	LBB_END		; END
08415    	.byte	3,'F'
08416    	.word	LBB_FOR		; FOR
08417    	.byte	4,'N'
08418    	.word	LBB_NEXT		; NEXT
08419    	.byte	4,'D'
08420    	.word	LBB_DATA		; DATA
08421    	.byte	5,'I'
08422    	.word	LBB_INPUT		; INPUT
08423    	.byte	3,'D'
08424    	.word	LBB_DIM		; DIM
08425    	.byte	4,'R'
08426    	.word	LBB_READ		; READ
08427    	.byte	3,'L'
08428    	.word	LBB_LET		; LET
08429    	.byte	3,'D'
08430    	.word	LBB_DEC		; DEC
08431    	.byte	4,'G'
08432    	.word	LBB_GOTO		; GOTO
08433    	.byte	3,'R'
08434    	.word	LBB_RUN		; RUN
08435    	.byte	2,'I'
08436    	.word	LBB_IF		; IF
08437    	.byte	7,'R'
08438    	.word	LBB_RESTORE		; RESTORE
08439    	.byte	5,'G'
08440    	.word	LBB_GOSUB		; GOSUB
08441    	.byte	6,'R'
08442    	.word	LBB_RETIRQ		; RETIRQ
08443    	.byte	6,'R'
08444    	.word	LBB_RETNMI		; RETNMI
08445    	.byte	6,'R'
08446    	.word	LBB_RETURN		; RETURN
08447    	.byte	3,'R'
08448    	.word	LBB_REM		; REM
08449    	.byte	4,'S'
08450    	.word	LBB_STOP		; STOP
08451    	.byte	2,'O'
08452    	.word	LBB_ON		; ON
08453    	.byte	4,'N'
08454    	.word	LBB_NULL		; NULL
08455    	.byte	3,'I'
08456    	.word	LBB_INC		; INC
08457    	.byte	4,'W'
08458    	.word	LBB_WAIT		; WAIT
08459    	.byte	4,'L'
08460    	.word	LBB_LOAD		; LOAD
08461    	.byte	4,'S'
08462    	.word	LBB_SAVE		; SAVE
08463    	.byte	3,'D'
08464    	.word	LBB_DEF		; DEF
08465    	.byte	4,'P'
08466    	.word	LBB_POKE		; POKE
08467    	.byte	4,'D'
08468    	.word	LBB_DOKE		; DOKE
08469    	.byte	4,'C'
08470    	.word	LBB_CALL		; CALL
08471    	.byte	2,'D'
08472    	.word	LBB_DO		; DO
08473    	.byte	4,'L'
08474    	.word	LBB_LOOP		; LOOP
08475    	.byte	5,'P'
08476    	.word	LBB_PRINT		; PRINT
08477    	.byte	4,'C'
08478    	.word	LBB_CONT		; CONT
08479    	.byte	4,'L'
08480    	.word	LBB_LIST		; LIST
08481    	.byte	5,'C'
08482    	.word	LBB_CLEAR		; CLEAR
08483    	.byte	3,'N'
08484    	.word	LBB_NEW		; NEW
08485    	.byte	5,'W'
08486    	.word	LBB_WIDTH		; WIDTH
08487    	.byte	3,'G'
08488    	.word	LBB_GET		; GET
08489    	.byte	4,'S'
08490    	.word	LBB_SWAP		; SWAP
08491    	.byte	6,'B'
08492    	.word	LBB_BITSET		; BITSET
08493    	.byte	6,'B'
08494    	.word	LBB_BITCLR		; BITCLR
08495    	.byte	3,'I'
08496    	.word	LBB_IRQ		; IRQ
08497    	.byte	3,'N'
08498    	.word	LBB_NMI		; NMI
08499    
08500    ; secondary commands (can't start a statement)
08501    
08502    	.byte	4,'T'
08503    	.word	LBB_TAB		; TAB
08504    	.byte	4,'E'
08505    	.word	LBB_ELSE		; ELSE
08506    	.byte	2,'T'
08507    	.word	LBB_TO		; TO
08508    	.byte	2,'F'
08509    	.word	LBB_FN		; FN
08510    	.byte	4,'S'
08511    	.word	LBB_SPC		; SPC
08512    	.byte	4,'T'
08513    	.word	LBB_THEN		; THEN
08514    	.byte	3,'N'
08515    	.word	LBB_NOT		; NOT
08516    	.byte	4,'S'
08517    	.word	LBB_STEP		; STEP
08518    	.byte	5,'U'
08519    	.word	LBB_UNTIL		; UNTIL
08520    	.byte	5,'W'
08521    	.word	LBB_WHILE		; WHILE
08522    	.byte	3,'O'
08523    	.word	LBB_OFF		; OFF
08524    
08525    ; opperators
08526    
08527    	.byte	1,'+'
08528    	.word	$0000			; +
08529    	.byte	1,'-'
08530    	.word	$0000			; -
08531    	.byte	1,'*'
08532    	.word	$0000			; *
08533    	.byte	1,'/'
08534    	.word	$0000			; /
08535    	.byte	1,'^'
08536    	.word	$0000			; ^
08537    	.byte	3,'A'
08538    	.word	LBB_AND		; AND
08539    	.byte	3,'E'
08540    	.word	LBB_EOR		; EOR
08541    	.byte	2,'O'
08542    	.word	LBB_OR		; OR
08543    	.byte	2,'>'
08544    	.word	LBB_RSHIFT		; >>
08545    	.byte	2,'<'
08546    	.word	LBB_LSHIFT		; <<
08547    	.byte	1,'>'
08548    	.word	$0000			; >
08549    	.byte	1,'='
08550    	.word	$0000			; =
08551    	.byte	1,'<'
08552    	.word	$0000			; <
08553    
08554    ; functions
08555    
08556    	.byte	4,'S'			;
08557    	.word	LBB_SGN		; SGN
08558    	.byte	4,'I'			;
08559    	.word	LBB_INT		; INT
08560    	.byte	4,'A'			;
08561    	.word	LBB_ABS		; ABS
08562    	.byte	4,'U'			;
08563    	.word	LBB_USR		; USR
08564    	.byte	4,'F'			;
08565    	.word	LBB_FRE		; FRE
08566    	.byte	4,'P'			;
08567    	.word	LBB_POS		; POS
08568    	.byte	4,'S'			;
08569    	.word	LBB_SQR		; SQR
08570    	.byte	4,'R'			;
08571    	.word	LBB_RND		; RND
08572    	.byte	4,'L'			;
08573    	.word	LBB_LOG		; LOG
08574    	.byte	4,'E'			;
08575    	.word	LBB_EXP		; EXP
08576    	.byte	4,'C'			;
08577    	.word	LBB_COS		; COS
08578    	.byte	4,'S'			;
08579    	.word	LBB_SIN		; SIN
08580    	.byte	4,'T'			;
08581    	.word	LBB_TAN		; TAN
08582    	.byte	4,'A'			;
08583    	.word	LBB_ATN		; ATN
08584    	.byte	5,'P'			;
08585    	.word	LBB_PEEK		; PEEK
08586    	.byte	5,'D'			;
08587    	.word	LBB_DEEK		; DEEK
08588    	.byte	5,'S'			;
08589    	.word	LBB_SADD		; SADD
08590    	.byte	4,'L'			;
08591    	.word	LBB_LEN		; LEN
08592    	.byte	5,'S'			;
08593    	.word	LBB_STRS		; STR$
08594    	.byte	4,'V'			;
08595    	.word	LBB_VAL		; VAL
08596    	.byte	4,'A'			;
08597    	.word	LBB_ASC		; ASC
08598    	.byte	7,'U'			;
08599    	.word	LBB_UCASES		; UCASE$
08600    	.byte	7,'L'			;
08601    	.word	LBB_LCASES		; LCASE$
08602    	.byte	5,'C'			;
08603    	.word	LBB_CHRS		; CHR$
08604    	.byte	5,'H'			;
08605    	.word	LBB_HEXS		; HEX$
08606    	.byte	5,'B'			;
08607    	.word	LBB_BINS		; BIN$
08608    	.byte	7,'B'			;
08609    	.word	LBB_BITTST		; BITTST
08610    	.byte	4,'M'			;
08611    	.word	LBB_MAX		; MAX
08612    	.byte	4,'M'			;
08613    	.word	LBB_MIN		; MIN
08614    	.byte	2,'P'			;
08615    	.word	LBB_PI		; PI
08616    	.byte	5,'T'			;
08617    	.word	LBB_TWOPI		; TWOPI
08618    	.byte	7,'V'			;
08619    	.word	LBB_VPTR		; VARPTR
08620    	.byte	6,'L'			;
08621    	.word	LBB_LEFTS		; LEFT$
08622    	.byte	7,'R'			;
08623    	.word	LBB_RIGHTS		; RIGHT$
08624    	.byte	5,'M'			;
08625    	.word	LBB_MIDS		; MID$
08626    
08627    ; BASIC messages, mostly error messages
08628    
08629    LAB_BAER
08630    	.word	ERR_NF		;$00 NEXT without FOR
08631    	.word	ERR_SN		;$02 syntax
08632    	.word	ERR_RG		;$04 RETURN without GOSUB
08633    	.word	ERR_OD		;$06 out of data
08634    	.word	ERR_FC		;$08 function call
08635    	.word	ERR_OV		;$0A overflow
08636    	.word	ERR_OM		;$0C out of memory
08637    	.word	ERR_US		;$0E undefined statement
08638    	.word	ERR_BS		;$10 array bounds
08639    	.word	ERR_DD		;$12 double dimension array
08640    	.word	ERR_D0		;$14 divide by 0
08641    	.word	ERR_ID		;$16 illegal direct
08642    	.word	ERR_TM		;$18 type mismatch
08643    	.word	ERR_LS		;$1A long string
08644    	.word	ERR_ST		;$1C string too complex
08645    	.word	ERR_CN		;$1E continue error
08646    	.word	ERR_UF		;$20 undefined function
08647    	.word ERR_LD		;$22 LOOP without DO
08648    
08649    ; I may implement these two errors to force definition of variables and
08650    ; dimensioning of arrays before use.
08651    
08652    ;	.word ERR_UV		;$24 undefined variable
08653    
08654    ; the above error has been tested and works (see code and comments below LAB_1D8B)
08655    
08656    ;	.word ERR_UA		;$26 undimensioned array
08657    
08658    ERR_NF	.byte	"NEXT without FOR",$00
08659    ERR_SN	.byte	"Syntax",$00
08660    ERR_RG	.byte	"RETURN without GOSUB",$00
08661    ERR_OD	.byte	"Out of DATA",$00
08662    ERR_FC	.byte	"Function call",$00
08663    ERR_OV	.byte	"Overflow",$00
08664    ERR_OM	.byte	"Out of memory",$00
08665    ERR_US	.byte	"Undefined statement",$00
08666    ERR_BS	.byte	"Array bounds",$00
08667    ERR_DD	.byte	"Double dimension",$00
08668    ERR_D0	.byte	"Divide by zero",$00
08669    ERR_ID	.byte	"Illegal direct",$00
08670    ERR_TM	.byte	"Type mismatch",$00
08671    ERR_LS	.byte	"String too long",$00
08672    ERR_ST	.byte	"String too complex",$00
08673    ERR_CN	.byte	"Can't continue",$00
08674    ERR_UF	.byte	"Undefined function",$00
08675    ERR_LD	.byte	"LOOP without DO",$00
08676    
08677    ;ERR_UV	.byte	"Undefined variable",$00
08678    
08679    ; the above error has been tested and works (see code and comments below LAB_1D8B)
08680    
08681    ;ERR_UA	.byte	"Undimensioned array",$00
08682    
08683    LAB_BMSG	.byte	$0D,$0A,"Break",$00
08684    LAB_EMSG	.byte	" Error",$00
08685    LAB_LMSG	.byte	" in line ",$00
08686    LAB_RMSG	.byte	$0D,$0A,"Ready",$0D,$0A,$00
08687    
08688    LAB_IMSG	.byte	" Extra ignored",$0D,$0A,$00
08689    LAB_REDO	.byte	" Redo from start",$0D,$0A,$00
08690    
08691    AA_end_basic
08692    AA_end_basic
08693    
08694    ; IO setup for the 2m5.de 6502 emulator environment
08695    
08696      BFF0             IO_PAGE	= $BFF0		; set I/O area +$f0 (internal registers)
08697    
08698      BFF0             ACIAtx	= IO_PAGE		; ACIA write port
08699      BFF0             ACIArx	= IO_PAGE		; ACIA read port
08700      BFF7             EEP_cmd	= IO_PAGE+7		; eep load/save dma command register
08701      BFF7             EEP_stat	= IO_PAGE+7		; eep load/save dma status (non $ff)
08702      BFF8             EEP_data	= IO_PAGE+8		; port to set prog#, start & end address
08703      BFFF             EMU_flag	= IO_PAGE+$f	; bit 0 = 10ms tick
08704      BFFC             EMU_diag	= IO_PAGE+$c	; bit 7 = force debugger
08705      BFFE             IR_mask	= IO_PAGE+$e	; interrupt enable mask
08706    
08707    ; now the code. all this does is set up the vectors and interrupt code
08708    ; and wait for the user to select [C]old or [W]arm start. nothing else
08709    ; fits in less than 256 bytes
08710    
08711    FE00               	*=	$FE00		; pretend this is in a 1/2K ROM
08712    
08713    ; reset vector points here
08714    
08715    RES_vec
08716    FE00  D8           	CLD			; clear decimal mode
08717    FE01  A2 FF        	LDX	#$FF		; empty stack
08718    FE03  9A           	TXS			; set the stack
08719    
08720    ; set up vectors and interrupt code, copy them to page 2
08721    
08722    FE04  A0 0C        	LDY	#END_vec-LAB_vec	; set index/count
08723    LAB_stlp
08724    FE06  B9 E9 FE     	LDA	LAB_vec-1,Y	; get byte from interrupt code
08725    FE09  99 04 02     	STA	VEC_IN-1,Y	; save to RAM
08726    FE0C  88           	DEY			; decrement index/count
08727    FE0D  D0 F7        	BNE	LAB_stlp	; loop if more to do
08728    
08729    ; now do the signon message, Y = $00 here
08730    
08731    LAB_signon
08732    FE0F  B9 13 FF     	LDA	LAB_mess,Y	; get byte from sign on message
08733    FE12  F0 06        	BEQ	LAB_nokey	; exit loop if done
08734    
08735    FE14  20 FA F0     	JSR	V_OUTP	; output character
08736    FE17  C8           	INY			; increment index
08737    FE18  D0 F5        	BNE	LAB_signon	; loop, branch always
08738    
08739    LAB_nokey
08740    FE1A  20 F7 F0     	JSR	V_INPT	; call scan input device
08741    FE1D  90 FB        	BCC	LAB_nokey	; loop if no key
08742    
08743    FE1F  29 DF        	AND	#$DF		; mask xx0x xxxx, ensure upper case
08744    FE21  C9 57        	CMP	#'W'		; compare with [W]arm start
08745    FE23  F0 07        	BEQ	LAB_dowarm	; branch if [W]arm start
08746    
08747    FE25  C9 43        	CMP	#'C'		; compare with [C]old start
08748    FE27  D0 D7        	BNE	RES_vec	; loop if not [C]old start
08749    
08750    FE29  4C 03 D0     	JMP	LAB_COLD	; do EhBASIC cold start
08751    
08752    LAB_dowarm
08753    FE2C  4C 00 00     	JMP	LAB_WARM	; do EhBASIC warm start
08754    
08755    ; byte out to emulated ACIA
08756    
08757    ACIAout
08758    FE2F  C9 08        	CMP	#8		; backspace?
08759    FE31  D0 0A        	BNE	skip_bs
08760    FE33  8D F0 BF     	STA	ACIAtx	; make erasing backspace
08761    FE36  A9 20        	LDA	#' '
08762    FE38  8D F0 BF     	STA	ACIAtx
08763    FE3B  A9 08        	LDA	#8
08764    skip_bs
08765    FE3D  8D F0 BF     	STA	ACIAtx	; send byte to ACIA
08766    FE40  60           	RTS
08767    
08768    ; byte in from emulated ACIA
08769    
08770    ACIAin
08771    FE41  AD F0 BF     	LDA	ACIArx	; test data available
08772    FE44  F0 35        	BEQ	LAB_nobyw	; branch if no byte waiting
08773    FE46  C9 7F        	CMP 	#127        ; convert delete to backspace
08774    FE48  D0 02        	BNE 	conv_bs2del
08775    FE4A  A9 08        	LDA 	#8
08776    conv_bs2del
08777    FE4C  C9 1B        	CMP 	#27         ; escape?
08778    FE4E  D0 27        	BNE 	skip_esc_no
08779    FE50  8A           	TXA       		; discard escape sequence
08780    FE51  48           	PHA
08781    FE52  A2 05        	LDX 	#5		; timer loop - 5*10ms
08782    skip_esc_next
08783    FE54  A9 01        	LDA 	#1		; ack last tick
08784    FE56  8D FF BF     	STA 	EMU_flag
08785    skip_esc_wait  
08786    FE59  AD FF BF     	LDA 	EMU_flag
08787    FE5C  29 01        	AND 	#1		; next tick
08788    FE5E  F0 F9        	BEQ 	skip_esc_wait
08789    FE60  CA           	DEX
08790    FE61  D0 F1        	BNE 	skip_esc_next
08791    skip_esc_discard  
08792    FE63  E8           	INX			; any data = X > 1
08793    FE64  AD F0 BF     	LDA 	ACIArx
08794    FE67  D0 FA        	BNE 	skip_esc_discard
08795    FE69  E0 01        	CPX 	#1
08796    FE6B  F0 06        	BEQ 	skip_esc_esc
08797    FE6D  68           	PLA			; was special key - skip
08798    FE6E  AA           	TAX
08799    FE6F  A9 00        	LDA 	#0
08800    FE71  18           	CLC
08801    FE72  60           	RTS
08802    skip_esc_esc		; escape only - send to basic  
08803    FE73  68           	PLA
08804    FE74  AA           	TAX
08805    FE75  A9 1B        	LDA 	#27
08806    
08807    skip_esc_no
08808    FE77  49 00        	EOR 	#0		; set flags NZ
08809    FE79  38           	SEC			; flag byte received
08810    FE7A  60           	RTS
08811    
08812    LAB_nobyw
08813    FE7B  18           	CLC			; flag no byte received
08814    FE7C  60           	RTS
08815    
08816    ; load a program from EEPROM by number
08817    
08818    load_eep
08819    FE7D  20 B8 FE     	JSR	check_prognum
08820    FE80  A9 07        	LDA	#7		; load command
08821    FE82  8D F7 BF     	STA	EEP_cmd
08822    FE85  2C F7 BF     	BIT	EEP_stat	; test for ack
08823    FE88  C9 FF        	CMP	#$ff
08824    FE8A  D0 03        	BNE	load_ok
08825    FE8C  4C C2 00     	JMP	LAB_GBYT	; continue
08826    load_ok
08827    FE8F  AD F8 BF     	LDA	EEP_data	; set end_address
08828    FE92  85 7B        	STA	Svarl
08829    FE94  AD F8 BF     	LDA	EEP_data
08830    FE97  85 7C        	STA	Svarh
08831    FE99  A9 04        	LDA	#<LAB_RMSG	; "READY"
08832    FE9B  A0 F8        	LDY	#>LAB_RMSG
08833    FE9D  20 C7 D8     	JSR	LAB_18C3
08834    FEA0  4C 07 D2     	JMP	LAB_1319	; rebuild line pointers	
08835    		
08836    ; save a program to EEPROM by number
08837    
08838    save_eep
08839    FEA3  20 B8 FE     	JSR	check_prognum
08840    FEA6  A5 7B        	LDA	Svarl		; set end address
08841    FEA8  8D F8 BF     	STA	EEP_data
08842    FEAB  A5 7C        	LDA	Svarh
08843    FEAD  8D F8 BF     	STA	EEP_data
08844    FEB0  A9 06        	LDA	#6		; save command
08845    FEB2  8D F7 BF     	STA	EEP_cmd
08846    FEB5  4C C2 00     	JMP	LAB_GBYT	; continue 
08847    
08848    ; check program number for validity (0-0xfe)
08849    ; 0xff drops to debugger to allow EEPROM utility commands
08850    
08851    check_prognum
08852    FEB8  20 C1 DA     	JSR	LAB_EVNM	; get program number to load
08853    FEBB  20 E5 E4     	JSR	LAB_F2FX	; convert to integer
08854    FEBE  A5 12        	LDA	Itemph	; filenumber range 0-0xfe
08855    FEC0  F0 05        	BEQ	prog_num_ok
08856    FEC2  68           	PLA			; discard return address
08857    FEC3  68           	PLA
08858    FEC4  4C 1D DF     	JMP	LAB_FCER	; msg "function call error"
08859    prog_num_ok	
08860    FEC7  A5 11        	LDA	Itempl
08861    FEC9  C9 FF        	CMP	#$ff		; special number
08862    FECB  D0 0A        	BNE	prog_set_start
08863    FECD  A9 80        	LDA	#$80		; drop to debugger
08864    FECF  8D FC BF     	STA	EMU_diag
08865    FED2  68           	PLA			; discard return address
08866    FED3  68           	PLA
08867    FED4  4C C2 00     	JMP	LAB_GBYT	; continue
08868    prog_set_start
08869    FED7  A2 00        	LDX	#0		; set eep command
08870    FED9  8E F7 BF     	STX	EEP_cmd
08871    FEDC  8D F8 BF     	STA	EEP_data	; set program number
08872    FEDF  A5 79        	LDA	Smeml		; set load address
08873    FEE1  8D F8 BF     	STA	EEP_data
08874    FEE4  A5 7A        	LDA	Smemh
08875    FEE6  8D F8 BF     	STA	EEP_data
08876    FEE9  60           	RTS
08877    
08878    ; vector tables
08879    
08880    LAB_vec
08881    	.word	ACIAin		; byte in from simulated ACIA
08882    	.word	ACIAout		; byte out to simulated ACIA
08883    	.word	load_eep		; load program from EEPROM
08884    	.word	save_eep		; save program to EEPROM
08885    	.word	IRQ_CODE		; vector to handle IRQ 
08886    	.word	NMI_CODE		; vector to handle IRQ 
08887    END_vec
08888    
08889    ; EhBASIC IRQ support
08890    
08891    IRQ_vec
08892    ;	JMP	(IRQ_indirect)	; jump through a vector in RAM
08893    					; uncomment if needed
08894    IRQ_CODE
08895    FEF6  85 E2        	STA	irq_a_reg		; save A
08896    FEF8  A5 DF        	LDA	IrqBase		; get the IRQ flag byte
08897    FEFA  D0 03        	BNE	IRQ_IS_SET		; Basic ready to handle?
08898    FEFC  8D FE BF     	STA	IR_mask		; no, silence internal interrupts 
08899    IRQ_IS_SET
08900    FEFF  09 20        	ORA	#$20			; 00100000 set IRQ pending
08901    FF01  85 DF        	STA	IrqBase		; save the new IRQ flag byte
08902    FF03  68           	PLA				; pop saved flags
08903    FF04  09 04        	ORA	#4			; set interrupt disable on stack
08904    FF06  48           	PHA				; save flags again for RTI
08905    FF07  A5 E2        	LDA	irq_a_reg		; restore A
08906    FF09  40           	RTI				; return disabled!
08907    	
08908    ; EhBASIC NMI support
08909    
08910    NMI_vec
08911    ;	JMP	(NMI_indirect)	; jump through a vector in RAM
08912    					; uncomment if needed
08913    NMI_CODE
08914    FF0A  48           	PHA				; save A
08915    FF0B  A5 DC        	LDA	NmiBase		; get the NMI flag byte
08916    FF0D  09 20        	ORA	#$20			; 00100000 set NMI pending
08917    FF0F  85 DC        	STA	NmiBase		; save the new NMI flag byte
08918    FF11  68           	PLA				; restore A
08919    FF12  40           	RTI
08920    
08921    LAB_mess
08922    	.byte	$0D,$0A,"6502 EhBASIC [C]old/[W]arm ?",$00
08923    					; sign on string
08924    
08925    ; system vectors
08926    
08927    FFFA               	*=	$FFFA
08928    
08929    	.word	NMI_vec		; NMI vector
08930    	.word	RES_vec		; RESET vector
08931    	.word	IRQ_vec		; IRQ vector
08932    
08933    
08934    
